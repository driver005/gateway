openapi: 3.0.0
info:
  version: 1.0.0
  title: Medusa Admin API
  description: ""
servers:
- url: http://localhost:9000
- url: https://api.medusa-commerce.com
paths:
  /admin/apps:
    get:
      operationId: GetApps
      summary: List Applications
      description: Retrieve a list of applications registered in the Medusa backend.
      x-authenticated: true
      x-codegen:
        method: list
      x-codeSamples:
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/apps' \
          -H x-medusa-access-token: "{api_token}"
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Apps Oauth
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminAppsListRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
  /admin/apps/authorizations:
    post:
      operationId: PostApps
      summary: Generate Token for App
      description: Use an app's Oauth provider to generate and store a new token for
        authentication.
      x-authenticated: true
      x-codegen:
        method: authorize
      x-codeSamples:
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/apps/authorizations' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "application_name": "example",
          "state": "ready",
          "code": "token"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Apps Oauth
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminAppsRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostAppsReq'
  /admin/auth:
    delete:
      operationId: DeleteAuth
      summary: User Logout
      description: Delete the current session for the logged in user. This will only
        work if you're using Cookie session for authentication. If the API token is
        still passed in the header, the user is still authorized to perform admin
        functionalities in other API Routes.
      x-authenticated: true
      x-codegen:
        method: deleteSession
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in
          medusa.admin.auth.deleteSession()
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteSession } from "medusa-react"
          const Logout = () => {
          const adminLogout = useAdminDeleteSession()
          // ...
          const handleLogout = () => {
          adminLogout.mutate(undefined, {
          onSuccess: () => {
          // user logged out.
          }
          })
          }
          // ...
          }
          export default Logout
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/auth' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Auth
      responses:
        "200":
          content: {}
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
    get:
      operationId: GetAuth
      summary: Get Current User
      description: Get the currently logged in user's details.
      x-authenticated: true
      x-codegen:
        method: getSession
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.auth.getSession()
          .then(({ user }) => {
          console.log(user.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminGetSession } from "medusa-react"
          const Profile = () => {
          const { user, isLoading } = useAdminGetSession()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {user && <span>{user.email}</span>}
          </div>
          )
          }
          export default Profile
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/auth' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Auth
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminAuthRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
    post:
      operationId: PostAuth
      summary: User Login
      description: Log a User in and includes the Cookie session in the response header.
        The cookie session can be used in subsequent requests to authorize the user
        to perform admin functionalities. When using Medusa's JS or Medusa React clients,
        the cookie is automatically attached to subsequent requests.
      x-codegen:
        method: createSession
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.admin.auth.createSession({
          email: "user@example.com",
          password: "supersecret"
          })
          .then(({ user }) => {
          console.log(user.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminLogin } from "medusa-react"
          const Login = () => {
          const adminLogin = useAdminLogin()
          // ...
          const handleLogin = () => {
          adminLogin.mutate({
          email: "user@example.com",
          password: "supersecret",
          }, {
          onSuccess: ({ user }) => {
          console.log(user)
          }
          })
          }
          // ...
          }
          export default Login
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/auth' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com",
          "password": "supersecret"
          }'
      tags:
      - Auth
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminAuthRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/incorrect_credentials'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostAuthReq'
  /admin/auth/token:
    post:
      operationId: PostToken
      summary: User Login (JWT)
      description: After a successful login, a JWT token is returned, which can be
        used to send authenticated requests.
      x-codegen:
        method: getToken
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.admin.auth.getToken({
          email: 'user@example.com',
          password: 'supersecret'
          })
          .then(({ access_token }) => {
          console.log(access_token);
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/admin/auth/token' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com",
          "password": "supersecret"
          }'
      tags:
      - Auth
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminBearerAuthRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/incorrect_credentials'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostAuthReq'
  /admin/batch-jobs:
    get:
      operationId: GetBatchJobs
      summary: List Batch Jobs
      description: Retrieve a list of Batch Jobs. The batch jobs can be filtered by
        fields such as `type` or `confirmed_at`. The batch jobs can also be sorted
        or paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetBatchParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.batchJobs.list()
          .then(({ batch_jobs, limit, offset, count }) => {
          console.log(batch_jobs.length)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminBatchJobs } from "medusa-react"
          const BatchJobs = () => {
          const {
          batch_jobs,
          limit,
          offset,
          count,
          isLoading
          } = useAdminBatchJobs()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {batch_jobs?.length && (
          <ul>
          {batch_jobs.map((batchJob) => (
          <li key={batchJob.id}>
          {batchJob.id}
          </li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default BatchJobs
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/batch-jobs' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Batch Jobs
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminBatchJobListRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (query) limit=10 {integer} Limit the number of batch jobs returned.
      - (query) offset=0 {integer} The number of batch jobs to skip when retrieving
        the batch jobs.
      - description: Filter by the batch ID
        explode: false
        in: query
        name: id
        oneOf: null
        schema: null
        style: form
      - description: batch job ID
        type: string
      - description: multiple batch job IDs
        items: null
        type: string
      - description: Filter by the batch type
        explode: false
        in: query
        items: null
        name: type
        schema: null
        style: form
        type: string
      - description: filter by dates greater than or equal to this date
        explode: false
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: confirmed_at
        properties: null
        schema: null
        style: form
        type: string
      - description: filter by dates greater than or equal to this date
        explode: false
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: pre_processed_at
        properties: null
        schema: null
        style: form
        type: string
      - description: filter by dates greater than or equal to this date
        explode: false
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: completed_at
        properties: null
        schema: null
        style: form
        type: string
      - description: filter by dates greater than or equal to this date
        explode: false
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: failed_at
        properties: null
        schema: null
        style: form
        type: string
      - description: filter by dates greater than or equal to this date
        explode: false
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: canceled_at
        properties: null
        schema: null
        style: form
        type: string
      - (query) order {string} A batch-job field to sort-order the retrieved batch
        jobs by.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned batch jobs.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned batch jobs.
      - description: filter by dates greater than or equal to this date
        explode: false
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        style: form
        type: string
      - description: filter by dates greater than or equal to this date
        explode: false
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        style: form
        type: string
    post:
      operationId: PostBatchJobs
      summary: Create a Batch Job
      description: Create a Batch Job to be executed asynchronously in the Medusa
        backend. If `dry_run` is set to `true`, the batch job will not be executed
        until the it is confirmed, which can be done using the Confirm Batch Job API
        Route.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.batchJobs.create({
          type: 'product-export',
          context: {},
          dry_run: false
          }).then((({ batch_job }) => {
          console.log(batch_job.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateBatchJob } from "medusa-react"
          const CreateBatchJob = () => {
          const createBatchJob = useAdminCreateBatchJob()
          // ...
          const handleCreateBatchJob = () => {
          createBatchJob.mutate({
          type: "publish-products",
          context: {},
          dry_run: true
          }, {
          onSuccess: ({ batch_job }) => {
          console.log(batch_job)
          }
          })
          }
          // ...
          }
          export default CreateBatchJob
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/batch-jobs' \
          -H 'Content-Type: application/json' \
          -H 'x-medusa-access-token: "{api_token}"' \
          --data-raw '{
          "type": "product-export",
          "context": { }
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Batch Jobs
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        É:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminBatchJobRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostBatchesReq'
      externalDocs:
        description: How to create a batch job
        url: https://docs.medusajs.com/development/batch-jobs/create#create-batch-job
  /admin/batch-jobs/{id}:
    get:
      operationId: GetBatchJobsBatchJob
      summary: Get a Batch Job
      description: Retrieve the details of a batch job.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.batchJobs.retrieve(batchJobId)
          .then(({ batch_job }) => {
          console.log(batch_job.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminBatchJob } from "medusa-react"
          type Props = {
          batchJobId: string
          }
          const BatchJob = ({ batchJobId }: Props) => {
          const { batch_job, isLoading } = useAdminBatchJob(batchJobId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {batch_job && <span>{batch_job.created_by}</span>}
          </div>
          )
          }
          export default BatchJob
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/batch-jobs/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Batch Jobs
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminBatchJobRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the Batch Job
  /admin/batch-jobs/{id}/cancel:
    post:
      operationId: PostBatchJobsBatchJobCancel
      summary: Cancel a Batch Job
      description: Mark a batch job as canceled. When a batch job is canceled, the
        processing of the batch job doesn’t automatically stop.
      x-authenticated: true
      x-codegen:
        method: cancel
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.batchJobs.cancel(batchJobId)
          .then(({ batch_job }) => {
          console.log(batch_job.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCancelBatchJob } from "medusa-react"
          type Props = {
          batchJobId: string
          }
          const BatchJob = ({ batchJobId }: Props) => {
          const cancelBatchJob = useAdminCancelBatchJob(batchJobId)
          // ...
          const handleCancel = () => {
          cancelBatchJob.mutate(undefined, {
          onSuccess: ({ batch_job }) => {
          console.log(batch_job)
          }
          })
          }
          // ...
          }
          export default BatchJob
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/batch-jobs/{id}/cancel' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Batch Jobs
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminBatchJobRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the batch job.
  /admin/batch-jobs/{id}/confirm:
    post:
      operationId: PostBatchJobsBatchJobConfirmProcessing
      summary: Confirm a Batch Job
      description: When a batch job is created, it is not executed automatically if
        `dry_run` is set to `true`. This API Route confirms that the batch job should
        be executed.
      x-authenticated: true
      x-codegen:
        method: confirm
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.batchJobs.confirm(batchJobId)
          .then(({ batch_job }) => {
          console.log(batch_job.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminConfirmBatchJob } from "medusa-react"
          type Props = {
          batchJobId: string
          }
          const BatchJob = ({ batchJobId }: Props) => {
          const confirmBatchJob = useAdminConfirmBatchJob(batchJobId)
          // ...
          const handleConfirm = () => {
          confirmBatchJob.mutate(undefined, {
          onSuccess: ({ batch_job }) => {
          console.log(batch_job)
          }
          })
          }
          // ...
          }
          export default BatchJob
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/batch-jobs/{id}/confirm' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Batch Jobs
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminBatchJobRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the batch job.
  /admin/collections:
    get:
      operationId: GetCollections
      summary: List Collections
      description: Retrieve a list of Product Collection. The product collections
        can be filtered by fields such as `handle` or `title`. The collections can
        also be sorted or paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetCollectionsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.collections.list()
          .then(({ collections, limit, offset, count }) => {
          console.log(collections.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCollections } from "medusa-react"
          const Collections = () => {
          const { collections, isLoading } = useAdminCollections()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {collections && !collections.length && <span>
          No Product Collections
          </span>}
          {collections && collections.length > 0 && (
          <ul>
          {collections.map((collection) => (
          <li key={collection.id}>{collection.title}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Collections
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/collections' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Collections
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCollectionsListRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (query) limit=10 {integer} The number of collections to return.
      - (query) offset=0 {integer} The number of collections to skip when retrieving
        the collections.
      - (query) title {string} Filter collections by their title.
      - (query) handle {string} Filter collections by their handle.
      - (query) q {string} a term to search collections by their title or handle.
      - (query) discount_condition_id {string} Filter collections by a discount condition
        ID associated with them.
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: deleted_at
        properties: null
        schema: null
        type: string
    post:
      operationId: PostCollections
      summary: Create a Collection
      description: Create a Product Collection.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.collections.create({
          title: "New Collection"
          })
          .then(({ collection }) => {
          console.log(collection.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateCollection } from "medusa-react"
          const CreateCollection = () => {
          const createCollection = useAdminCreateCollection()
          // ...
          const handleCreate = (title: string) => {
          createCollection.mutate({
          title
          }, {
          onSuccess: ({ collection }) => {
          console.log(collection.id)
          }
          })
          }
          // ...
          }
          export default CreateCollection
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/collections' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "title": "New Collection"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Collections
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCollectionsRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostCollectionsReq'
  /admin/collections/{id}:
    delete:
      operationId: DeleteCollectionsCollection
      summary: Delete a Collection
      description: Delete a Product Collection. This does not delete associated products.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.collections.delete(collectionId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteCollection } from "medusa-react"
          type Props = {
          collectionId: string
          }
          const Collection = ({ collectionId }: Props) => {
          const deleteCollection = useAdminDeleteCollection(collectionId)
          // ...
          const handleDelete = (title: string) => {
          deleteCollection.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default Collection
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/collections/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Collections
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCollectionsDeleteRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the Collection.
    get:
      operationId: GetCollectionsCollection
      summary: Get a Collection
      description: Retrieve a Product Collection by its ID. The products associated
        with it are expanded and returned as well.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.collections.retrieve(collectionId)
          .then(({ collection }) => {
          console.log(collection.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCollection } from "medusa-react"
          type Props = {
          collectionId: string
          }
          const Collection = ({ collectionId }: Props) => {
          const { collection, isLoading } = useAdminCollection(collectionId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {collection && <span>{collection.title}</span>}
          </div>
          )
          }
          export default Collection
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/collections/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Collections
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCollectionsRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the Product Collection
    post:
      operationId: PostCollectionsCollection
      summary: Update a Collection
      description: Update a Product Collection's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.collections.update(collectionId, {
          title: "New Collection"
          })
          .then(({ collection }) => {
          console.log(collection.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateCollection } from "medusa-react"
          type Props = {
          collectionId: string
          }
          const Collection = ({ collectionId }: Props) => {
          const updateCollection = useAdminUpdateCollection(collectionId)
          // ...
          const handleUpdate = (title: string) => {
          updateCollection.mutate({
          title
          }, {
          onSuccess: ({ collection }) => {
          console.log(collection.id)
          }
          })
          }
          // ...
          }
          export default Collection
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/collections/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "title": "New Collection"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Collections
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCollectionsRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the Collection.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostCollectionsCollectionReq'
  /admin/collections/{id}/products/batch:
    delete:
      operationId: DeleteProductsFromCollection
      summary: Remove Products from Collection
      description: Remove a list of products from a collection. This would not delete
        the product, only the association between the product and the collection.
      x-authenticated: true
      x-codegen:
        method: removeProducts
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.collections.removeProducts(collectionId, {
          product_ids: [
          productId1,
          productId2
          ]
          })
          .then(({ id, object, removed_products }) => {
          console.log(removed_products)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminRemoveProductsFromCollection } from "medusa-react"
          type Props = {
          collectionId: string
          }
          const Collection = ({ collectionId }: Props) => {
          const removeProducts = useAdminRemoveProductsFromCollection(collectionId)
          // ...
          const handleRemoveProducts = (productIds: string[]) => {
          removeProducts.mutate({
          product_ids: productIds
          }, {
          onSuccess: ({ id, object, removed_products }) => {
          console.log(removed_products)
          }
          })
          }
          // ...
          }
          export default Collection
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/collections/{id}/products/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "product_ids": [
          "prod_01G1G5V2MBA328390B5AXJ610F"
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Collections
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDeleteProductsFromCollectionRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the Product Collection.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminDeleteProductsFromCollectionReq'
    post:
      operationId: PostProductsToCollection
      summary: Add Products to Collection
      description: Add products to a product collection.
      x-authenticated: true
      x-codegen:
        method: addProducts
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.collections.addProducts(collectionId, {
          product_ids: [
          productId1,
          productId2
          ]
          })
          .then(({ collection }) => {
          console.log(collection.products)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminAddProductsToCollection } from "medusa-react"
          type Props = {
          collectionId: string
          }
          const Collection = ({ collectionId }: Props) => {
          const addProducts = useAdminAddProductsToCollection(collectionId)
          // ...
          const handleAddProducts = (productIds: string[]) => {
          addProducts.mutate({
          product_ids: productIds
          }, {
          onSuccess: ({ collection }) => {
          console.log(collection.products)
          }
          })
          }
          // ...
          }
          export default Collection
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/collections/{id}/products/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "product_ids": [
          "prod_01G1G5V2MBA328390B5AXJ610F"
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Collections
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCollectionsRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the product collection.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostProductsToCollectionReq'
  /admin/currencies:
    get:
      operationId: GetCurrencies
      summary: List Currency
      description: Retrieve a list of currencies. The currencies can be filtered by
        fields such as `code`. The currencies can also be sorted or paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetCurrenciesParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.currencies.list()
          .then(({ currencies, count, offset, limit }) => {
          console.log(currencies.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCurrencies } from "medusa-react"
          const Currencies = () => {
          const { currencies, isLoading } = useAdminCurrencies()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {currencies && !currencies.length && (
          <span>No Currencies</span>
          )}
          {currencies && currencies.length > 0 && (
          <ul>
          {currencies.map((currency) => (
          <li key={currency.code}>{currency.name}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Currencies
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/currencies' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Currencies
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCurrenciesListRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (query) code {string} filter by currency code.
      - description: filter currencies by whether they include taxes or not.
        in: query
        name: includes_tax
        schema: null
        type: boolean
        x-featureFlag: tax_inclusive_pricing
      - (query) order {string} A field to sort order the retrieved currencies by.
      - (query) q {string} Term used to search currencies' name and code.
      - (query) offset=0 {number} The number of currencies to skip when retrieving
        the currencies.
      - (query) limit=20 {number} The number of currencies to return.
  /admin/currencies/{code}:
    post:
      operationId: PostCurrenciesCurrency
      summary: Update a Currency
      description: Update a Currency's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.currencies.update(code, {
          includes_tax: true
          })
          .then(({ currency }) => {
          console.log(currency.code);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateCurrency } from "medusa-react"
          type Props = {
          currencyCode: string
          }
          const Currency = ({ currencyCode }: Props) => {
          const updateCurrency = useAdminUpdateCurrency(currencyCode)
          // ...
          const handleUpdate = (includes_tax: boolean) => {
          updateCurrency.mutate({
          includes_tax,
          }, {
          onSuccess: ({ currency }) => {
          console.log(currency)
          }
          })
          }
          // ...
          }
          export default Currency
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/currencies/{code}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "includes_tax": true
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Currencies
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCurrenciesRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) code=* {string} The code of the Currency.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostCurrenciesCurrencyReq'
  /admin/customer-groups:
    get:
      operationId: GetCustomerGroups
      summary: List Customer Groups
      description: Retrieve a list of customer groups. The customer groups can be
        filtered by fields such as `name` or `id. The customer groups can also be
        sorted or paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetCustomerGroupsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.customerGroups.list()
          .then(({ customer_groups, limit, offset, count }) => {
          console.log(customer_groups.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCustomerGroups } from "medusa-react"
          const CustomerGroups = () => {
          const {
          customer_groups,
          isLoading,
          } = useAdminCustomerGroups()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {customer_groups && !customer_groups.length && (
          <span>No Customer Groups</span>
          )}
          {customer_groups && customer_groups.length > 0 && (
          <ul>
          {customer_groups.map(
          (customerGroup) => (
          <li key={customerGroup.id}>
          {customerGroup.name}
          </li>
          )
          )}
          </ul>
          )}
          </div>
          )
          }
          export default CustomerGroups
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/customer-groups' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customer Groups
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCustomerGroupsListRes'
          description: OK
      parameters:
      - (query) q {string} term to search customer groups by name.
      - (query) offset=0 {integer} The number of customer groups to skip when retrieving
        the customer groups.
      - (query) order {string} A field to sort order the retrieved customer groups
        by.
      - (query) discount_condition_id {string} Filter by discount condition ID.
      - description: Filter by the customer group ID
        explode: false
        in: query
        name: id
        oneOf: null
        schema: null
        style: form
      - description: customer group ID
        type: string
      - description: an array of customer group IDs
        items: null
        type: string
      - description: filter by IDs greater than or equal to this ID
        gt: null
        gte: null
        lt: null
        lte: null
        properties: null
        type: string
      - description: customer group name
        explode: false
        in: query
        items: null
        name: name
        schema: null
        style: form
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      - (query) limit=10 {integer} The number of customer groups to return.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned customer groups.
    post:
      operationId: PostCustomerGroups
      summary: Create a Customer Group
      description: Create a Customer Group.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.customerGroups.create({
          name: "VIP"
          })
          .then(({ customer_group }) => {
          console.log(customer_group.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateCustomerGroup } from "medusa-react"
          const CreateCustomerGroup = () => {
          const createCustomerGroup = useAdminCreateCustomerGroup()
          // ...
          const handleCreate = (name: string) => {
          createCustomerGroup.mutate({
          name,
          })
          }
          // ...
          }
          export default CreateCustomerGroup
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/customer-groups' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "VIP"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customer Groups
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCustomerGroupsRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostCustomerGroupsReq'
  /admin/customer-groups/{id}:
    delete:
      operationId: DeleteCustomerGroupsCustomerGroup
      summary: Delete a Customer Group
      description: Delete a customer group. This doesn't delete the customers associated
        with the customer group.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.customerGroups.delete(customerGroupId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteCustomerGroup } from "medusa-react"
          type Props = {
          customerGroupId: string
          }
          const CustomerGroup = ({ customerGroupId }: Props) => {
          const deleteCustomerGroup = useAdminDeleteCustomerGroup(
          customerGroupId
          )
          // ...
          const handleDeleteCustomerGroup = () => {
          deleteCustomerGroup.mutate()
          }
          // ...
          }
          export default CustomerGroup
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/customer-groups/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customer Groups
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCustomerGroupsDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Customer Group
    get:
      operationId: GetCustomerGroupsGroup
      summary: Get a Customer Group
      description: Retrieve a Customer Group by its ID. You can expand the customer
        group's relations or select the fields that should be returned.
      x-authenticated: true
      x-codegen:
        method: retrieve
        queryParams: AdminGetCustomerGroupsGroupParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.customerGroups.retrieve(customerGroupId)
          .then(({ customer_group }) => {
          console.log(customer_group.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCustomerGroup } from "medusa-react"
          type Props = {
          customerGroupId: string
          }
          const CustomerGroup = ({ customerGroupId }: Props) => {
          const { customer_group, isLoading } = useAdminCustomerGroup(
          customerGroupId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {customer_group && <span>{customer_group.name}</span>}
          </div>
          )
          }
          export default CustomerGroup
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/customer-groups/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customer Groups
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCustomerGroupsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Customer Group.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned customer group.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned customer group.
    post:
      operationId: PostCustomerGroupsGroup
      summary: Update a Customer Group
      description: Update a Customer Group's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.customerGroups.update(customerGroupId, {
          name: "VIP"
          })
          .then(({ customer_group }) => {
          console.log(customer_group.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateCustomerGroup } from "medusa-react"
          type Props = {
          customerGroupId: string
          }
          const CustomerGroup = ({ customerGroupId }: Props) => {
          const updateCustomerGroup = useAdminUpdateCustomerGroup(
          customerGroupId
          )
          // ..
          const handleUpdate = (name: string) => {
          updateCustomerGroup.mutate({
          name,
          })
          }
          // ...
          }
          export default CustomerGroup
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/customer-groups/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "VIP"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customer Groups
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCustomerGroupsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the customer group.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostCustomerGroupsGroupReq'
  /admin/customer-groups/{id}/customers:
    get:
      operationId: GetCustomerGroupsGroupCustomers
      summary: List Customers
      description: Retrieve a list of customers in a customer group. The customers
        can be filtered by the `q` field. The customers can also be paginated.
      x-authenticated: true
      x-codegen:
        method: listCustomers
        queryParams: AdminGetGroupsGroupCustomersParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.customerGroups.listCustomers(customerGroupId)
          .then(({ customers }) => {
          console.log(customers.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCustomerGroupCustomers } from "medusa-react"
          type Props = {
          customerGroupId: string
          }
          const CustomerGroup = ({ customerGroupId }: Props) => {
          const {
          customers,
          isLoading,
          } = useAdminCustomerGroupCustomers(
          customerGroupId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {customers && !customers.length && (
          <span>No customers</span>
          )}
          {customers && customers.length > 0 && (
          <ul>
          {customers.map((customer) => (
          <li key={customer.id}>{customer.first_name}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default CustomerGroup
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/customer-groups/{id}/customers' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customer Groups
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCustomersListRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the customer group.
      - (query) limit=50 {integer} The number of customers to return.
      - (query) offset=0 {integer} The number of customers to skip when retrieving
        the customers.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned customers.
      - (query) q {string} a term to search customers by email, first_name, and last_name.
  /admin/customer-groups/{id}/customers/batch:
    delete:
      operationId: DeleteCustomerGroupsGroupCustomerBatch
      summary: Remove Customers from Group
      description: Remove a list of customers from a customer group. This doesn't
        delete the customer, only the association between the customer and the customer
        group.
      x-authenticated: true
      x-codegen:
        method: removeCustomers
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.customerGroups.removeCustomers(customerGroupId, {
          customer_ids: [
          {
          id: customerId
          }
          ]
          })
          .then(({ customer_group }) => {
          console.log(customer_group.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminRemoveCustomersFromCustomerGroup,
          } from "medusa-react"
          type Props = {
          customerGroupId: string
          }
          const CustomerGroup = ({ customerGroupId }: Props) => {
          const removeCustomers =
          useAdminRemoveCustomersFromCustomerGroup(
          customerGroupId
          )
          // ...
          const handleRemoveCustomer = (customerId: string) => {
          removeCustomers.mutate({
          customer_ids: [
          {
          id: customerId,
          },
          ],
          })
          }
          // ...
          }
          export default CustomerGroup
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/customer-groups/{id}/customers/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "customer_ids": [
          {
          "id": "cus_01G2Q4BS9GAHDBMDEN4ZQZCJB2"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customer Groups
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCustomerGroupsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the customer group.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminDeleteCustomerGroupsGroupCustomerBatchReq'
    post:
      operationId: PostCustomerGroupsGroupCustomersBatch
      summary: Add Customers to Group
      description: Add a list of customers to a customer group.
      x-authenticated: true
      x-codegen:
        method: addCustomers
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.customerGroups.addCustomers(customerGroupId, {
          customer_ids: [
          {
          id: customerId
          }
          ]
          })
          .then(({ customer_group }) => {
          console.log(customer_group.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminAddCustomersToCustomerGroup,
          } from "medusa-react"
          type Props = {
          customerGroupId: string
          }
          const CustomerGroup = ({ customerGroupId }: Props) => {
          const addCustomers = useAdminAddCustomersToCustomerGroup(
          customerGroupId
          )
          // ...
          const handleAddCustomers= (customerId: string) => {
          addCustomers.mutate({
          customer_ids: [
          {
          id: customerId,
          },
          ],
          })
          }
          // ...
          }
          export default CustomerGroup
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/customer-groups/{id}/customers/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "customer_ids": [
          {
          "id": "cus_01G2Q4BS9GAHDBMDEN4ZQZCJB2"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customer Groups
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCustomerGroupsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the customer group.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostCustomerGroupsGroupCustomersBatchReq'
  /admin/customers:
    get:
      operationId: GetCustomers
      summary: List Customers
      description: Retrieve a list of Customers. The customers can be filtered by
        fields such as `q` or `groups`. The customers can also be paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetCustomersParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.customers.list()
          .then(({ customers, limit, offset, count }) => {
          console.log(customers.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCustomers } from "medusa-react"
          const Customers = () => {
          const { customers, isLoading } = useAdminCustomers()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {customers && !customers.length && (
          <span>No customers</span>
          )}
          {customers && customers.length > 0 && (
          <ul>
          {customers.map((customer) => (
          <li key={customer.id}>{customer.first_name}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Customers
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/customers' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customers
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCustomersListRes'
          description: OK
      parameters:
      - (query) limit=50 {integer} The number of customers to return.
      - (query) offset=0 {integer} The number of customers to skip when retrieving
        the customers.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned customer.
      - (query) q {string} term to search customers' email, first_name, and last_name
        fields.
      - description: Filter by customer group IDs.
        explode: false
        in: query
        items: null
        name: groups
        schema: null
        style: form
        type: string
    post:
      operationId: PostCustomers
      summary: Create a Customer
      description: Create a customer as an admin.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.customers.create({
          email: "user@example.com",
          first_name: "Caterina",
          last_name: "Yost",
          password: "supersecret"
          })
          .then(({ customer }) => {
          console.log(customer.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateCustomer } from "medusa-react"
          type CustomerData = {
          first_name: string
          last_name: string
          email: string
          password: string
          }
          const CreateCustomer = () => {
          const createCustomer = useAdminCreateCustomer()
          // ...
          const handleCreate = (customerData: CustomerData) => {
          createCustomer.mutate(customerData, {
          onSuccess: ({ customer }) => {
          console.log(customer.id)
          }
          })
          }
          // ...
          }
          export default CreateCustomer
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/customers' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com",
          "first_name": "Caterina",
          "last_name": "Yost",
          "password": "supersecret"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customers
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        É:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCustomersRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostCustomersReq'
  /admin/customers/{id}:
    get:
      operationId: GetCustomersCustomer
      summary: Get a Customer
      description: Retrieve the details of a customer.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.customers.retrieve(customerId)
          .then(({ customer }) => {
          console.log(customer.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCustomer } from "medusa-react"
          type Props = {
          customerId: string
          }
          const Customer = ({ customerId }: Props) => {
          const { customer, isLoading } = useAdminCustomer(
          customerId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {customer && <span>{customer.first_name}</span>}
          </div>
          )
          }
          export default Customer
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/customers/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customers
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCustomersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Customer.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned customer.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned customer.
    post:
      operationId: PostCustomersCustomer
      summary: Update a Customer
      description: Update a Customer's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.customers.update(customerId, {
          first_name: "Dolly"
          })
          .then(({ customer }) => {
          console.log(customer.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateCustomer } from "medusa-react"
          type CustomerData = {
          first_name: string
          last_name: string
          email: string
          password: string
          }
          type Props = {
          customerId: string
          }
          const Customer = ({ customerId }: Props) => {
          const updateCustomer = useAdminUpdateCustomer(customerId)
          // ...
          const handleUpdate = (customerData: CustomerData) => {
          updateCustomer.mutate(customerData)
          }
          // ...
          }
          export default Customer
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/customers/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "first_name": "Dolly"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customers
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminCustomersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Customer.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned customer.
      - (query) fields {string} Comma-separated fields that should be retrieved in
        the returned customer.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostCustomersCustomerReq'
  /admin/discounts:
    get:
      operationId: GetDiscounts
      summary: List Discounts
      description: Retrieve a list of Discounts. The discounts can be filtered by
        fields such as `rule` or `is_dynamic`. The discounts can also be paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetDiscountsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.list()
          .then(({ discounts, limit, offset, count }) => {
          console.log(discounts.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDiscounts } from "medusa-react"
          const Discounts = () => {
          const { discounts, isLoading } = useAdminDiscounts()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {discounts && !discounts.length && (
          <span>No customers</span>
          )}
          {discounts && discounts.length > 0 && (
          <ul>
          {discounts.map((discount) => (
          <li key={discount.id}>{discount.code}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Discounts
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/discounts' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsListRes'
          description: OK
      parameters:
      - (query) q {string} term to search discounts' code field.
      - allocation: null
        description: Filter discounts by allocation type.
        enum:
        - total
        - item
        in: query
        name: rule
        properties: null
        schema: null
        type: string
      - (query) is_dynamic {boolean} Filter discounts by whether they're dynamic or
        not.
      - (query) is_disabled {boolean} Filter discounts by whether they're disabled
        or not.
      - (query) limit=20 {number} The number of discounts to return
      - (query) offset=0 {number} The number of discounts to skip when retrieving
        the discounts.
      - (query) expand {string} Comma-separated relations that should be expanded
        in each returned discount.
    post:
      operationId: PostDiscounts
      summary: Create a Discount
      description: Create a Discount with a given set of rules that defines how the
        Discount is applied.
      x-authenticated: true
      x-codegen:
        method: create
        queryParams: AdminPostDiscountsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          import { AllocationType, DiscountRuleType } from "@medusajs/medusa"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.create({
            code: "TEST",
            rule: {
              type: DiscountRuleType.FIXED,
              value: 10,
              allocation: AllocationType.ITEM
            },
            regions: ["reg_XXXXXXXX"],
            is_dynamic: false,
            is_disabled: false
          })
          .then(({ discount }) => {
            console.log(discount.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
            useAdminCreateDiscount,
          } from "medusa-react"
          import {
            AllocationType,
            DiscountRuleType,
          } from "@medusajs/medusa"
          const CreateDiscount = () => {
            const createDiscount = useAdminCreateDiscount()
            // ...
            const handleCreate = (
              currencyCode: string,
              regionId: string
            ) => {
              // ...
              createDiscount.mutate({
                code: currencyCode,
                rule: {
                  type: DiscountRuleType.FIXED,
                  value: 10,
                  allocation: AllocationType.ITEM,
                },
                regions: [
                    regionId,
                ],
                is_dynamic: false,
                is_disabled: false,
              })
            }
            // ...
          }
          export default CreateDiscount
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/discounts' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
              "code": "TEST",
              "rule": {
                 "type": "fixed",
                 "value": 10,
                 "allocation": "item"
              },
              "regions": ["reg_XXXXXXXX"]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content: {}
        "401":
          content: {}
        "404":
          content: {}
        "409":
          content: {}
        "422":
          content: {}
        "500":
          content: {}
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsRes'
          description: OK
      parameters:
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned discount.
      - (query) fields {string} Comma-separated fields that should be retrieved in
        the returned discount.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostDiscountsReq'
  /admin/discounts/{discount_id}/conditions:
    post:
      operationId: PostDiscountsDiscountConditions
      summary: Create a Condition
      description: Create a Discount Condition. Only one of `products`, `product_types`,
        `product_collections`, `product_tags`, and `customer_groups` should be provided,
        based on the type of discount condition. For example, if the discount condition's
        type is `products`, the `products` field should be provided in the request
        body.
      x-authenticated: true
      x-codegen:
        method: createCondition
        queryParams: AdminPostDiscountsDiscountConditionsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          import { DiscountConditionOperator } from "@medusajs/medusa"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.createCondition(discountId, {
          operator: DiscountConditionOperator.IN,
          products: [productId]
          })
          .then(({ discount }) => {
          console.log(discount.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { DiscountConditionOperator } from "@medusajs/medusa"
          import { useAdminDiscountCreateCondition } from "medusa-react"
          type Props = {
          discountId: string
          }
          const Discount = ({ discountId }: Props) => {
          const createCondition = useAdminDiscountCreateCondition(discountId)
          // ...
          const handleCreateCondition = (
          operator: DiscountConditionOperator,
          products: string[]
          ) => {
          createCondition.mutate({
          operator,
          products
          }, {
          onSuccess: ({ discount }) => {
          console.log(discount.id)
          }
          })
          }
          // ...
          }
          export default Discount
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/discounts/{id}/conditions' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "operator": "in"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsRes'
          description: OK
      parameters:
      - (path) discount_id=* {string} The ID of the discount.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned discount.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned discount.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostDiscountsDiscountConditions'
  /admin/discounts/{discount_id}/conditions/{condition_id}:
    delete:
      operationId: DeleteDiscountsDiscountConditionsCondition
      summary: Delete a Condition
      description: Delete a Discount Condition. This does not delete resources associated
        to the discount condition.
      x-authenticated: true
      x-codegen:
        method: deleteCondition
        queryParams: AdminDeleteDiscountsDiscountConditionsConditionParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.deleteCondition(discountId, conditionId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminDiscountRemoveCondition
          } from "medusa-react"
          type Props = {
          discountId: string
          }
          const Discount = ({ discountId }: Props) => {
          const deleteCondition = useAdminDiscountRemoveCondition(
          discountId
          )
          // ...
          const handleDelete = (
          conditionId: string
          ) => {
          deleteCondition.mutate(conditionId, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(deleted)
          }
          })
          }
          // ...
          }
          export default Discount
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/discounts/{id}/conditions/{condition_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountConditionsDeleteRes'
          description: OK
      parameters:
      - (path) discount_id=* {string} The ID of the Discount
      - (path) condition_id=* {string} The ID of the Discount Condition
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned discount.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned discount.
    get:
      operationId: GetDiscountsDiscountConditionsCondition
      summary: Get a Condition
      description: Retrieve a Discount Condition's details.
      x-authenticated: true
      x-codegen:
        method: getCondition
        queryParams: AdminGetDiscountsDiscountConditionsConditionParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.getCondition(discountId, conditionId)
          .then(({ discount_condition }) => {
          console.log(discount_condition.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminGetDiscountCondition } from "medusa-react"
          type Props = {
          discountId: string
          discountConditionId: string
          }
          const DiscountCondition = ({
          discountId,
          discountConditionId
          }: Props) => {
          const {
          discount_condition,
          isLoading
          } = useAdminGetDiscountCondition(
          discountId,
          discountConditionId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {discount_condition && (
          <span>{discount_condition.type}</span>
          )}
          </div>
          )
          }
          export default DiscountCondition
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/discounts/{id}/conditions/{condition_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountConditionsRes'
          description: OK
      parameters:
      - (path) discount_id=* {string} The ID of the Discount.
      - (path) condition_id=* {string} The ID of the Discount Condition.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned discount condition.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned discount condition.
    post:
      operationId: PostDiscountsDiscountConditionsCondition
      summary: Update a Condition
      description: Update a Discount Condition. Only one of `products`, `product_types`,
        `product_collections`, `product_tags`, and `customer_groups` should be provided,
        based on the type of discount condition. For example, if the discount condition's
        type is `products`, the `products` field should be provided in the request
        body.
      x-authenticated: true
      x-codegen:
        method: updateCondition
        queryParams: AdminPostDiscountsDiscountConditionsConditionParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.updateCondition(discountId, conditionId, {
          products: [
          productId
          ]
          })
          .then(({ discount }) => {
          console.log(discount.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDiscountUpdateCondition } from "medusa-react"
          type Props = {
          discountId: string
          conditionId: string
          }
          const DiscountCondition = ({
          discountId,
          conditionId
          }: Props) => {
          const update = useAdminDiscountUpdateCondition(
          discountId,
          conditionId
          )
          // ...
          const handleUpdate = (
          products: string[]
          ) => {
          update.mutate({
          products
          }, {
          onSuccess: ({ discount }) => {
          console.log(discount.id)
          }
          })
          }
          // ...
          }
          export default DiscountCondition
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/discounts/{id}/conditions/{condition}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "products": [
          "prod_01G1G5V2MBA328390B5AXJ610F"
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsRes'
          description: OK
      parameters:
      - (path) discount_id=* {string} The ID of the Discount.
      - (path) condition_id=* {string} The ID of the Discount Condition.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned discount.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned discount.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostDiscountsDiscountConditionsCondition'
  /admin/discounts/{discount_id}/conditions/{condition_id}/batch:
    delete:
      operationId: DeleteDiscountsDiscountConditionsConditionBatch
      summary: Remove Batch Resources
      description: Remove a batch of resources from a discount condition. This will
        only remove the association between the resource and the discount condition,
        not the resource itself.
      x-authenticated: true
      x-codegen:
        method: deleteConditionResourceBatch
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.deleteConditionResourceBatch(discountId, conditionId, {
          resources: [{ id: itemId }]
          })
          .then(({ discount }) => {
          console.log(discount.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminDeleteDiscountConditionResourceBatch
          } from "medusa-react"
          type Props = {
          discountId: string
          conditionId: string
          }
          const DiscountCondition = ({
          discountId,
          conditionId
          }: Props) => {
          const deleteConditionResource = useAdminDeleteDiscountConditionResourceBatch(
          discountId,
          conditionId,
          )
          // ...
          const handleDelete = (itemId: string) => {
          deleteConditionResource.mutate({
          resources: [
          {
          id: itemId
          }
          ]
          }, {
          onSuccess: ({ discount }) => {
          console.log(discount.id)
          }
          })
          }
          // ...
          }
          export default DiscountCondition
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/discounts/{id}/conditions/{condition_id}/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "resources": [{ "id": "item_id" }]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsRes'
          description: OK
      parameters:
      - (path) discount_id=* {string} The ID of the discount.
      - (path) condition_id=* {string} The ID of the condition to remove the resources
        from.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned discount.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned discount.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminDeleteDiscountsDiscountConditionsConditionBatchReq'
    post:
      operationId: PostDiscountsDiscountConditionsConditionBatch
      summary: Add Batch Resources
      description: Add a batch of resources to a discount condition. The type of resource
        depends on the type of discount condition. For example, if the discount condition's
        type is `products`, the resources being added should be products.
      x-authenticated: true
      x-codegen:
        method: addConditionResourceBatch
        queryParams: AdminPostDiscountsDiscountConditionsConditionBatchParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.addConditionResourceBatch(discountId, conditionId, {
          resources: [{ id: itemId }]
          })
          .then(({ discount }) => {
          console.log(discount.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminAddDiscountConditionResourceBatch
          } from "medusa-react"
          type Props = {
          discountId: string
          conditionId: string
          }
          const DiscountCondition = ({
          discountId,
          conditionId
          }: Props) => {
          const addConditionResources = useAdminAddDiscountConditionResourceBatch(
          discountId,
          conditionId
          )
          // ...
          const handleAdd = (itemId: string) => {
          addConditionResources.mutate({
          resources: [
          {
          id: itemId
          }
          ]
          }, {
          onSuccess: ({ discount }) => {
          console.log(discount.id)
          }
          })
          }
          // ...
          }
          export default DiscountCondition
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/discounts/{id}/conditions/{condition_id}/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "resources": [{ "id": "item_id" }]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsRes'
          description: OK
      parameters:
      - (path) discount_id=* {string} The ID of the discount the condition belongs
        to.
      - (path) condition_id=* {string} The ID of the discount condition on which to
        add the item.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned discount.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned discount.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostDiscountsDiscountConditionsConditionBatchReq'
  /admin/discounts/{id}:
    delete:
      operationId: DeleteDiscountsDiscount
      summary: Delete a Discount
      description: Delete a Discount. Deleting the discount will make it unavailable
        for customers to use.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.delete(discountId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteDiscount } from "medusa-react"
          const Discount = () => {
          const deleteDiscount = useAdminDeleteDiscount(discount_id)
          // ...
          const handleDelete = () => {
          deleteDiscount.mutate()
          }
          // ...
          }
          export default Discount
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/discounts/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Discount
    get:
      operationId: GetDiscountsDiscount
      summary: Get a Discount
      description: Retrieve a Discount.
      x-authenticated: true
      x-codegen:
        method: retrieve
        queryParams: AdminGetDiscountParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.retrieve(discountId)
          .then(({ discount }) => {
          console.log(discount.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDiscount } from "medusa-react"
          type Props = {
          discountId: string
          }
          const Discount = ({ discountId }: Props) => {
          const { discount, isLoading } = useAdminDiscount(
          discountId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {discount && <span>{discount.code}</span>}
          </div>
          )
          }
          export default Discount
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/discounts/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Discount
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned discount.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned discount.
    post:
      operationId: PostDiscountsDiscount
      summary: Update a Discount
      description: Update a Discount with a given set of rules that define how the
        Discount is applied.
      x-authenticated: true
      x-codegen:
        method: update
        queryParams: AdminPostDiscountsDiscountParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.update(discountId, {
          code: "TEST"
          })
          .then(({ discount }) => {
          console.log(discount.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateDiscount } from "medusa-react"
          type Props = {
          discountId: string
          }
          const Discount = ({ discountId }: Props) => {
          const updateDiscount = useAdminUpdateDiscount(discountId)
          // ...
          const handleUpdate = (isDisabled: boolean) => {
          updateDiscount.mutate({
          is_disabled: isDisabled,
          })
          }
          // ...
          }
          export default Discount
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/discounts/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "code": "TEST"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Discount.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned discount.
      - (query) fields {string} Comma-separated fields that should be retrieved in
        the returned discount.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostDiscountsDiscountReq'
  /admin/discounts/{id}/dynamic-codes:
    post:
      operationId: PostDiscountsDiscountDynamicCodes
      summary: Create a Dynamic Code
      description: Create a dynamic unique code that can map to a parent Discount.
        This is useful if you want to automatically generate codes with the same rules
        and conditions.
      x-authenticated: true
      x-codegen:
        method: createDynamicCode
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.createDynamicCode(discountId, {
          code: "TEST",
          usage_limit: 1
          })
          .then(({ discount }) => {
          console.log(discount.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateDynamicDiscountCode } from "medusa-react"
          type Props = {
          discountId: string
          }
          const Discount = ({ discountId }: Props) => {
          const createDynamicDiscount = useAdminCreateDynamicDiscountCode(discountId)
          // ...
          const handleCreate = (
          code: string,
          usageLimit: number
          ) => {
          createDynamicDiscount.mutate({
          code,
          usage_limit: usageLimit
          }, {
          onSuccess: ({ discount }) => {
          console.log(discount.is_dynamic)
          }
          })
          }
          // ...
          }
          export default Discount
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/discounts/{id}/dynamic-codes' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "code": "TEST"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Discount to create the dynamic code for."
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostDiscountsDiscountDynamicCodesReq'
  /admin/discounts/{id}/dynamic-codes/{code}:
    delete:
      operationId: DeleteDiscountsDiscountDynamicCodesCode
      summary: Delete a Dynamic Code
      description: Delete a dynamic code from a Discount.
      x-authenticated: true
      x-codegen:
        method: deleteDynamicCode
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.deleteDynamicCode(discountId, code)
          .then(({ discount }) => {
          console.log(discount.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteDynamicDiscountCode } from "medusa-react"
          type Props = {
          discountId: string
          }
          const Discount = ({ discountId }: Props) => {
          const deleteDynamicDiscount = useAdminDeleteDynamicDiscountCode(discountId)
          // ...
          const handleDelete = (code: string) => {
          deleteDynamicDiscount.mutate(code, {
          onSuccess: ({ discount }) => {
          console.log(discount.is_dynamic)
          }
          })
          }
          // ...
          }
          export default Discount
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/discounts/{id}/dynamic-codes/{code}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Discount
      - (path) code=* {string} The dynamic code to delete
  /admin/discounts/{id}/regions/{region_id}:
    delete:
      operationId: DeleteDiscountsDiscountRegionsRegion
      summary: Remove Region
      description: Remove a Region from the list of Regions that a Discount can be
        used in. This does not delete a region, only the association between it and
        the discount.
      x-authenticated: true
      x-codegen:
        method: removeRegion
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.removeRegion(discountId, regionId)
          .then(({ discount }) => {
          console.log(discount.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDiscountRemoveRegion } from "medusa-react"
          type Props = {
          discountId: string
          }
          const Discount = ({ discountId }: Props) => {
          const deleteRegion = useAdminDiscountRemoveRegion(discountId)
          // ...
          const handleDelete = (regionId: string) => {
          deleteRegion.mutate(regionId, {
          onSuccess: ({ discount }) => {
          console.log(discount.regions)
          }
          })
          }
          // ...
          }
          export default Discount
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/discounts/{id}/regions/{region_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Discount.
      - (path) region_id=* {string} The ID of the Region.
    post:
      operationId: PostDiscountsDiscountRegionsRegion
      summary: Add Region to Discount
      description: Add a Region to the list of Regions a Discount can be used in.
      x-authenticated: true
      x-codegen:
        method: addRegion
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.addRegion(discountId, regionId)
          .then(({ discount }) => {
          console.log(discount.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDiscountAddRegion } from "medusa-react"
          type Props = {
          discountId: string
          }
          const Discount = ({ discountId }: Props) => {
          const addRegion = useAdminDiscountAddRegion(discountId)
          // ...
          const handleAdd = (regionId: string) => {
          addRegion.mutate(regionId, {
          onSuccess: ({ discount }) => {
          console.log(discount.regions)
          }
          })
          }
          // ...
          }
          export default Discount
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/discounts/{id}/regions/{region_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Discount.
      - (path) region_id=* {string} The ID of the Region.
  /admin/discounts/code/{code}:
    get:
      operationId: GetDiscountsDiscountCode
      summary: Get Discount by Code
      description: Retrieve a Discount's details by its discount code
      x-authenticated: true
      x-codegen:
        method: retrieveByCode
        queryParams: AdminGetDiscountsDiscountCodeParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.discounts.retrieveByCode(code)
          .then(({ discount }) => {
          console.log(discount.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminGetDiscountByCode } from "medusa-react"
          type Props = {
          discountCode: string
          }
          const Discount = ({ discountCode }: Props) => {
          const { discount, isLoading } = useAdminGetDiscountByCode(
          discountCode
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {discount && <span>{discount.code}</span>}
          </div>
          )
          }
          export default Discount
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/discounts/code/{code}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Discounts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDiscountsRes'
          description: OK
      parameters:
      - (path) code=* {string} The code of the Discount
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned discount.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned discount.
  /admin/draft-orders:
    get:
      operationId: GetDraftOrders
      summary: List Draft Orders
      description: Retrieve an list of Draft Orders. The draft orders can be filtered
        by fields such as `q`. The draft orders can also paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetDraftOrdersParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.draftOrders.list()
          .then(({ draft_orders, limit, offset, count }) => {
          console.log(draft_orders.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDraftOrders } from "medusa-react"
          const DraftOrders = () => {
          const { draft_orders, isLoading } = useAdminDraftOrders()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {draft_orders && !draft_orders.length && (
          <span>No Draft Orders</span>
          )}
          {draft_orders && draft_orders.length > 0 && (
          <ul>
          {draft_orders.map((order) => (
          <li key={order.id}>{order.display_id}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default DraftOrders
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/draft-orders' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Draft Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDraftOrdersListRes'
          description: OK
      parameters:
      - (query) offset=0 {number} The number of draft orders to skip when retrieving
        the draft orders.
      - (query) limit=50 {number} Limit the number of draft orders returned.
      - (query) q {string} a term to search draft orders' display IDs and emails in
        the draft order's cart
    post:
      operationId: PostDraftOrders
      summary: Create a Draft Order
      description: Create a Draft Order. A draft order is not transformed into an
        order until payment is captured.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.draftOrders.create({
          email: "user@example.com",
          region_id,
          items: [
          {
          quantity: 1
          }
          ],
          shipping_methods: [
          {
          option_id
          }
          ],
          })
          .then(({ draft_order }) => {
          console.log(draft_order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateDraftOrder } from "medusa-react"
          type DraftOrderData = {
          email: string
          region_id: string
          items: {
          quantity: number,
          variant_id: string
          }[]
          shipping_methods: {
          option_id: string
          price: number
          }[]
          }
          const CreateDraftOrder = () => {
          const createDraftOrder = useAdminCreateDraftOrder()
          // ...
          const handleCreate = (data: DraftOrderData) => {
          createDraftOrder.mutate(data, {
          onSuccess: ({ draft_order }) => {
          console.log(draft_order.id)
          }
          })
          }
          // ...
          }
          export default CreateDraftOrder
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/draft-orders' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com",
          "region_id": "{region_id}"
          "items": [
          {
          "quantity": 1
          }
          ],
          "shipping_methods": [
          {
          "option_id": "{option_id}"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Draft Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDraftOrdersRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostDraftOrdersReq'
  /admin/draft-orders/{id}:
    delete:
      operationId: DeleteDraftOrdersDraftOrder
      summary: Delete a Draft Order
      description: Delete a Draft Order.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.draftOrders.delete(draftOrderId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteDraftOrder } from "medusa-react"
          type Props = {
          draftOrderId: string
          }
          const DraftOrder = ({ draftOrderId }: Props) => {
          const deleteDraftOrder = useAdminDeleteDraftOrder(
          draftOrderId
          )
          // ...
          const handleDelete = () => {
          deleteDraftOrder.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default DraftOrder
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/draft-orders/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Draft Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDraftOrdersDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Draft Order.
    get:
      operationId: GetDraftOrdersDraftOrder
      summary: Get a Draft Order
      description: Retrieve a Draft Order's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.draftOrders.retrieve(draftOrderId)
          .then(({ draft_order }) => {
          console.log(draft_order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDraftOrder } from "medusa-react"
          type Props = {
          draftOrderId: string
          }
          const DraftOrder = ({ draftOrderId }: Props) => {
          const {
          draft_order,
          isLoading,
          } = useAdminDraftOrder(draftOrderId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {draft_order && <span>{draft_order.display_id}</span>}
          </div>
          )
          }
          export default DraftOrder
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/draft-orders/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Draft Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDraftOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Draft Order.
    post:
      operationId: PostDraftOrdersDraftOrder
      summary: Update a Draft Order
      description: Update a Draft Order's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.draftOrders.update(draftOrderId, {
          email: "user@example.com"
          })
          .then(({ draft_order }) => {
          console.log(draft_order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateDraftOrder } from "medusa-react"
          type Props = {
          draftOrderId: string
          }
          const DraftOrder = ({ draftOrderId }: Props) => {
          const updateDraftOrder = useAdminUpdateDraftOrder(
          draftOrderId
          )
          // ...
          const handleUpdate = (email: string) => {
          updateDraftOrder.mutate({
          email,
          }, {
          onSuccess: ({ draft_order }) => {
          console.log(draft_order.id)
          }
          })
          }
          // ...
          }
          export default DraftOrder
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/draft-orders/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Draft Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDraftOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Draft Order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostDraftOrdersDraftOrderReq'
  /admin/draft-orders/{id}/line-items:
    post:
      operationId: PostDraftOrdersDraftOrderLineItems
      summary: Create a Line Item
      description: Create a Line Item in the Draft Order.
      x-authenticated: true
      x-codegen:
        method: addLineItem
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.draftOrders.addLineItem(draftOrderId, {
          quantity: 1
          })
          .then(({ draft_order }) => {
          console.log(draft_order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDraftOrderAddLineItem } from "medusa-react"
          type Props = {
          draftOrderId: string
          }
          const DraftOrder = ({ draftOrderId }: Props) => {
          const addLineItem = useAdminDraftOrderAddLineItem(
          draftOrderId
          )
          // ...
          const handleAdd = (quantity: number) => {
          addLineItem.mutate({
          quantity,
          }, {
          onSuccess: ({ draft_order }) => {
          console.log(draft_order.cart)
          }
          })
          }
          // ...
          }
          export default DraftOrder
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/draft-orders/{id}/line-items' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "quantity": 1
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Draft Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDraftOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Draft Order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostDraftOrdersDraftOrderLineItemsReq'
  /admin/draft-orders/{id}/line-items/{line_id}:
    delete:
      operationId: DeleteDraftOrdersDraftOrderLineItemsItem
      summary: Delete a Line Item
      description: Delete a Line Item from a Draft Order.
      x-authenticated: true
      x-codegen:
        method: removeLineItem
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.draftOrders.removeLineItem(draftOrderId, itemId)
          .then(({ draft_order }) => {
          console.log(draft_order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDraftOrderRemoveLineItem } from "medusa-react"
          type Props = {
          draftOrderId: string
          }
          const DraftOrder = ({ draftOrderId }: Props) => {
          const deleteLineItem = useAdminDraftOrderRemoveLineItem(
          draftOrderId
          )
          // ...
          const handleDelete = (itemId: string) => {
          deleteLineItem.mutate(itemId, {
          onSuccess: ({ draft_order }) => {
          console.log(draft_order.cart)
          }
          })
          }
          // ...
          }
          export default DraftOrder
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/draft-orders/{id}/line-items/{line_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Draft Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDraftOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Draft Order.
      - (path) line_id=* {string} The ID of the line item.
    post:
      operationId: PostDraftOrdersDraftOrderLineItemsItem
      summary: Update a Line Item
      description: Update a Line Item in a Draft Order.
      x-authenticated: true
      x-codegen:
        method: updateLineItem
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.draftOrders.updateLineItem(draftOrderId, lineId, {
          quantity: 1
          })
          .then(({ draft_order }) => {
          console.log(draft_order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDraftOrderUpdateLineItem } from "medusa-react"
          type Props = {
          draftOrderId: string
          }
          const DraftOrder = ({ draftOrderId }: Props) => {
          const updateLineItem = useAdminDraftOrderUpdateLineItem(
          draftOrderId
          )
          // ...
          const handleUpdate = (
          itemId: string,
          quantity: number
          ) => {
          updateLineItem.mutate({
          item_id: itemId,
          quantity,
          })
          }
          // ...
          }
          export default DraftOrder
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/draft-orders/{id}/line-items/{line_id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "quantity": 1
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Draft Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDraftOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Draft Order.
      - (path) line_id=* {string} The ID of the Line Item.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostDraftOrdersDraftOrderLineItemsItemReq'
  /admin/draft-orders/{id}/pay:
    post:
      operationId: PostDraftOrdersDraftOrderRegisterPayment
      summary: Mark Paid
      description: Capture the draft order's payment. This will also set the draft
        order's status to `completed` and create an Order from the draft order. The
        payment is captured through Medusa's system payment, which is manual payment
        that isn't integrated with any third-party payment provider. It is assumed
        that the payment capturing is handled manually by the admin.
      x-authenticated: true
      x-codegen:
        method: markPaid
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.draftOrders.markPaid(draftOrderId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDraftOrderRegisterPayment } from "medusa-react"
          type Props = {
          draftOrderId: string
          }
          const DraftOrder = ({ draftOrderId }: Props) => {
          const registerPayment = useAdminDraftOrderRegisterPayment(
          draftOrderId
          )
          // ...
          const handlePayment = () => {
          registerPayment.mutate(void 0, {
          onSuccess: ({ order }) => {
          console.log(order.id)
          }
          })
          }
          // ...
          }
          export default DraftOrder
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/draft-orders/{id}/pay' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Draft Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPostDraftOrdersDraftOrderRegisterPaymentRes'
          description: OK
      parameters:
      - (path) id=* {string} The Draft Order ID.
  /admin/gift-cards:
    get:
      operationId: GetGiftCards
      summary: List Gift Cards
      description: Retrieve a list of Gift Cards. The gift cards can be filtered by
        fields such as `q`. The gift cards can also paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetGiftCardsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.giftCards.list()
          .then(({ gift_cards, limit, offset, count }) => {
          console.log(gift_cards.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { GiftCard } from "@medusajs/medusa"
          import { useAdminGiftCards } from "medusa-react"
          const CustomGiftCards = () => {
          const { gift_cards, isLoading } = useAdminGiftCards()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {gift_cards && !gift_cards.length && (
          <span>No custom gift cards...</span>
          )}
          {gift_cards && gift_cards.length > 0 && (
          <ul>
          {gift_cards.map((giftCard: GiftCard) => (
          <li key={giftCard.id}>{giftCard.code}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default CustomGiftCards
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/gift-cards' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Gift Cards
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminGiftCardsListRes'
          description: OK
      parameters:
      - (query) offset=0 {number} The number of gift cards to skip when retrieving
        the gift cards.
      - (query) limit=50 {number} Limit the number of gift cards returned.
      - (query) q {string} a term to search gift cards' code or display ID
    post:
      operationId: PostGiftCards
      summary: Create a Gift Card
      description: Create a Gift Card that can redeemed by its unique code. The Gift
        Card is only valid within 1 region.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.giftCards.create({
          region_id
          })
          .then(({ gift_card }) => {
          console.log(gift_card.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateGiftCard } from "medusa-react"
          const CreateCustomGiftCards = () => {
          const createGiftCard = useAdminCreateGiftCard()
          // ...
          const handleCreate = (
          regionId: string,
          value: number
          ) => {
          createGiftCard.mutate({
          region_id: regionId,
          value,
          }, {
          onSuccess: ({ gift_card }) => {
          console.log(gift_card.id)
          }
          })
          }
          // ...
          }
          export default CreateCustomGiftCards
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/gift-cards' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "region_id": "{region_id}"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Gift Cards
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminGiftCardsRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostGiftCardsReq'
  /admin/gift-cards/{id}:
    delete:
      operationId: DeleteGiftCardsGiftCard
      summary: Delete a Gift Card
      description: Delete a Gift Card. Once deleted, it can't be used by customers.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.giftCards.delete(giftCardId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteGiftCard } from "medusa-react"
          type Props = {
          customGiftCardId: string
          }
          const CustomGiftCard = ({ customGiftCardId }: Props) => {
          const deleteGiftCard = useAdminDeleteGiftCard(
          customGiftCardId
          )
          // ...
          const handleDelete = () => {
          deleteGiftCard.mutate(void 0, {
          onSuccess: ({ id, object, deleted}) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default CustomGiftCard
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/gift-cards/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Gift Cards
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminGiftCardsDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Gift Card to delete.
    get:
      operationId: GetGiftCardsGiftCard
      summary: Get a Gift Card
      description: Retrieve a Gift Card's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.giftCards.retrieve(giftCardId)
          .then(({ gift_card }) => {
          console.log(gift_card.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminGiftCard } from "medusa-react"
          type Props = {
          giftCardId: string
          }
          const CustomGiftCard = ({ giftCardId }: Props) => {
          const { gift_card, isLoading } = useAdminGiftCard(giftCardId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {gift_card && <span>{gift_card.code}</span>}
          </div>
          )
          }
          export default CustomGiftCard
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/gift-cards/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Gift Cards
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminGiftCardsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Gift Card.
    post:
      operationId: PostGiftCardsGiftCard
      summary: Update a Gift Card
      description: Update a Gift Card's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.giftCards.update(giftCardId, {
          region_id
          })
          .then(({ gift_card }) => {
          console.log(gift_card.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateGiftCard } from "medusa-react"
          type Props = {
          customGiftCardId: string
          }
          const CustomGiftCard = ({ customGiftCardId }: Props) => {
          const updateGiftCard = useAdminUpdateGiftCard(
          customGiftCardId
          )
          // ...
          const handleUpdate = (regionId: string) => {
          updateGiftCard.mutate({
          region_id: regionId,
          }, {
          onSuccess: ({ gift_card }) => {
          console.log(gift_card.id)
          }
          })
          }
          // ...
          }
          export default CustomGiftCard
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/gift-cards/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "region_id": "{region_id}"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Gift Cards
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminGiftCardsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Gift Card.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostGiftCardsGiftCardReq'
  /admin/invites:
    get:
      operationId: GetInvites
      summary: Lists Invites
      description: Retrieve a list of invites.
      x-authenticated: true
      x-codegen:
        method: list
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.invites.list()
          .then(({ invites }) => {
          console.log(invites.length);
          })
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/invites' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Invites
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminListInvitesRes'
          description: OK
    post:
      operationId: PostInvites
      summary: Create an Invite
      description: Create an Invite. This will generate a token associated with the
        invite and trigger an `invite.created` event. If you have a Notification Provider
        installed that handles this event, a notification should be sent to the email
        associated with the invite to allow them to accept the invite.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.invites.create({
          user: "user@example.com",
          role: "admin"
          })
          .then(() => {
          // successful
          })
          .catch(() => {
          // an error occurred
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/invites' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "user": "user@example.com",
          "role": "admin"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Invites
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content: {}
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostInvitesReq'
  /admin/invites/{invite_id}:
    delete:
      operationId: DeleteInvitesInvite
      summary: Delete an Invite
      description: Delete an Invite. Only invites that weren't accepted can be deleted.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.invites.delete(inviteId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteInvite } from "medusa-react"
          type Props = {
          inviteId: string
          }
          const DeleteInvite = ({ inviteId }: Props) => {
          const deleteInvite = useAdminDeleteInvite(inviteId)
          // ...
          const handleDelete = () => {
          deleteInvite.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default Invite
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/invites/{invite_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Invites
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminInviteDeleteRes'
          description: OK
      parameters:
      - (path) invite_id=* {string} The ID of the Invite
  /admin/invites/{invite_id}/resend:
    post:
      operationId: PostInvitesInviteResend
      summary: Resend an Invite
      description: Resend an Invite. This renews the expiry date by 7 days and generates
        a new token for the invite. It also triggers the `invite.created` event, so
        if you have a Notification Provider installed that handles this event, a notification
        should be sent to the email associated with the invite to allow them to accept
        the invite.
      x-authenticated: true
      x-codegen:
        method: resend
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.invites.resend(inviteId)
          .then(() => {
          // successful
          })
          .catch(() => {
          // an error occurred
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminResendInvite } from "medusa-react"
          type Props = {
          inviteId: string
          }
          const ResendInvite = ({ inviteId }: Props) => {
          const resendInvite = useAdminResendInvite(inviteId)
          // ...
          const handleResend = () => {
          resendInvite.mutate(void 0, {
          onSuccess: () => {
          // invite resent successfully
          }
          })
          }
          // ...
          }
          export default ResendInvite
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/invites/{invite_id}/resend' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Invites
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content: {}
          description: OK
      parameters:
      - (path) invite_id=* {string} The ID of the Invite
  /admin/invites/accept:
    post:
      operationId: PostInvitesInviteAccept
      summary: Accept an Invite
      description: Accept an Invite. This will also delete the invite and create a
        new user that can log in and perform admin functionalities. The user will
        have the email associated with the invite, and the password provided in the
        request body.
      x-codegen:
        method: accept
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.invites.accept({
          token,
          user: {
          first_name: "Brigitte",
          last_name: "Collier",
          password: "supersecret"
          }
          })
          .then(() => {
          // successful
          })
          .catch(() => {
          // an error occurred
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminAcceptInvite } from "medusa-react"
          const AcceptInvite = () => {
          const acceptInvite = useAdminAcceptInvite()
          // ...
          const handleAccept = (
          token: string,
          firstName: string,
          lastName: string,
          password: string
          ) => {
          acceptInvite.mutate({
          token,
          user: {
          first_name: firstName,
          last_name: lastName,
          password,
          },
          }, {
          onSuccess: () => {
          // invite accepted successfully.
          }
          })
          }
          // ...
          }
          export default AcceptInvite
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/invites/accept' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "token": "{token}",
          "user": {
          "first_name": "Brigitte",
          "last_name": "Collier",
          "password": "supersecret"
          }
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Invites
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content: {}
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostInvitesInviteAcceptReq'
  /admin/notes:
    get:
      operationId: GetNotes
      summary: List Notes
      description: Retrieve a list of notes. The notes can be filtered by fields such
        as `resource_id`. The notes can also be paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetNotesParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.notes.list()
          .then(({ notes, limit, offset, count }) => {
          console.log(notes.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminNotes } from "medusa-react"
          const Notes = () => {
          const { notes, isLoading } = useAdminNotes()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {notes && !notes.length && <span>No Notes</span>}
          {notes && notes.length > 0 && (
          <ul>
          {notes.map((note) => (
          <li key={note.id}>{note.resource_type}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Notes
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/notes' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Notes
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminNotesListRes'
          description: OK
      parameters:
      - (query) limit=50 {number} Limit the number of notes returned.
      - (query) offset=0 {number} The number of notes to skip when retrieving the
        notes.
      - (query) resource_id {string} Filter by resource ID
    post:
      operationId: PostNotes
      summary: Create a Note
      description: Create a Note which can be associated with any resource.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.notes.create({
          resource_id,
          resource_type: "order",
          value: "We delivered this order"
          })
          .then(({ note }) => {
          console.log(note.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateNote } from "medusa-react"
          const CreateNote = () => {
          const createNote = useAdminCreateNote()
          // ...
          const handleCreate = () => {
          createNote.mutate({
          resource_id: "order_123",
          resource_type: "order",
          value: "We delivered this order"
          }, {
          onSuccess: ({ note }) => {
          console.log(note.id)
          }
          })
          }
          // ...
          }
          export default CreateNote
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/notes' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "resource_id": "{resource_id}",
          "resource_type": "order",
          "value": "We delivered this order"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Notes
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminNotesRes'
          description: OK
  /admin/notes/{id}:
    delete:
      operationId: DeleteNotesNote
      summary: Delete a Note
      description: Delete a Note.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.notes.delete(noteId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteNote } from "medusa-react"
          type Props = {
          noteId: string
          }
          const Note = ({ noteId }: Props) => {
          const deleteNote = useAdminDeleteNote(noteId)
          // ...
          const handleDelete = () => {
          deleteNote.mutate()
          }
          // ...
          }
          export default Note
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/notes/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Notes
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminNotesDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Note to delete.
    get:
      operationId: GetNotesNote
      summary: Get a Note
      description: Retrieve a note's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.notes.retrieve(noteId)
          .then(({ note }) => {
          console.log(note.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminNote } from "medusa-react"
          type Props = {
          noteId: string
          }
          const Note = ({ noteId }: Props) => {
          const { note, isLoading } = useAdminNote(noteId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {note && <span>{note.resource_type}</span>}
          </div>
          )
          }
          export default Note
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/notes/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Notes
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminNotesRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the note.
    post:
      operationId: PostNotesNote
      summary: Update a Note
      description: Update a Note's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.notes.update(noteId, {
          value: "We delivered this order"
          })
          .then(({ note }) => {
          console.log(note.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateNote } from "medusa-react"
          type Props = {
          noteId: string
          }
          const Note = ({ noteId }: Props) => {
          const updateNote = useAdminUpdateNote(noteId)
          // ...
          const handleUpdate = (
          value: string
          ) => {
          updateNote.mutate({
          value
          }, {
          onSuccess: ({ note }) => {
          console.log(note.value)
          }
          })
          }
          // ...
          }
          export default Note
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/notes/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "value": "We delivered this order"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Notes
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminNotesRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Note
  /admin/notifications:
    get:
      operationId: GetNotifications
      summary: List Notifications
      description: Retrieve a list of notifications. The notifications can be filtered
        by fields such as `event_name` or `resource_type`. The notifications can also
        be paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetNotificationsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.notifications.list()
          .then(({ notifications }) => {
          console.log(notifications.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminNotifications } from "medusa-react"
          const Notifications = () => {
          const { notifications, isLoading } = useAdminNotifications()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {notifications && !notifications.length && (
          <span>No Notifications</span>
          )}
          {notifications && notifications.length > 0 && (
          <ul>
          {notifications.map((notification) => (
          <li key={notification.id}>{notification.to}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Notifications
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/notifications' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Notifications
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminNotificationsListRes'
          description: OK
      parameters:
      - (query) offset=0 {integer} The number of inventory items to skip when retrieving
        the inventory items.
      - (query) limit=50 {integer} Limit the number of notifications returned.
      - (query) fields {string} Comma-separated fields that should be included in
        each returned notification.
      - (query) expand {string} Comma-separated relations that should be expanded
        in each returned notification.
      - (query) event_name {string} Filter by the name of the event that triggered
        sending this notification.
      - (query) resource_type {string} Filter by the resource type.
      - (query) resource_id {string} Filter by the resource ID.
      - (query) to {string} Filter by the address that the Notification was sent to.
        This will usually be an email address, but it can also represent other addresses
        such as a chat bot user id.
      - (query) include_resends {string} A boolean indicating whether the result set
        should include resent notifications or not
  /admin/notifications/{id}/resend:
    post:
      operationId: PostNotificationsNotificationResend
      summary: Resend Notification
      description: Resend a previously sent notifications, with the same data but
        optionally to a different address.
      x-authenticated: true
      x-codegen:
        method: resend
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.notifications.resend(notificationId)
          .then(({ notification }) => {
          console.log(notification.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminResendNotification } from "medusa-react"
          type Props = {
          notificationId: string
          }
          const Notification = ({ notificationId }: Props) => {
          const resendNotification = useAdminResendNotification(
          notificationId
          )
          // ...
          const handleResend = () => {
          resendNotification.mutate({}, {
          onSuccess: ({ notification }) => {
          console.log(notification.id)
          }
          })
          }
          // ...
          }
          export default Notification
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/notifications/{id}/resend' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Notifications
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminNotificationsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Notification
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostNotificationsNotificationResendReq'
  /admin/order-edits:
    get:
      operationId: GetOrderEdits
      summary: List Order Edits
      description: Retrieve a list of order edits. The order edits can be filtered
        by fields such as `q` or `order_id`. The order edits can also be paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: GetOrderEditsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orderEdits.list()
          .then(({ order_edits, count, limit, offset }) => {
          console.log(order_edits.length)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminOrderEdits } from "medusa-react"
          const OrderEdits = () => {
          const { order_edits, isLoading } = useAdminOrderEdits()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {order_edits && !order_edits.length && (
          <span>No Order Edits</span>
          )}
          {order_edits && order_edits.length > 0 && (
          <ul>
          {order_edits.map((orderEdit) => (
          <li key={orderEdit.id}>
          {orderEdit.status}
          </li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default OrderEdits
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/order-edits' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrderEditsListRes'
          description: OK
      parameters:
      - (query) q {string} term to search order edits' internal note.
      - (query) order_id {string} Filter by order ID
      - (query) limit=20 {number} Limit the number of order edits returned.
      - (query) offset=0 {number} The number of order edits to skip when retrieving
        the order edits.
      - (query) expand {string} Comma-separated relations that should be expanded
        in each returned order edit.
      - (query) fields {string} Comma-separated fields that should be included in
        each returned order edit.
    post:
      operationId: PostOrderEdits
      summary: Create an OrderEdit
      description: Create an Order Edit.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orderEdits.create({ orderId })
          .then(({ order_edit }) => {
          console.log(order_edit.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateOrderEdit } from "medusa-react"
          const CreateOrderEdit = () => {
          const createOrderEdit = useAdminCreateOrderEdit()
          const handleCreateOrderEdit = (orderId: string) => {
          createOrderEdit.mutate({
          order_id: orderId,
          }, {
          onSuccess: ({ order_edit }) => {
          console.log(order_edit.id)
          }
          })
          }
          // ...
          }
          export default CreateOrderEdit
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/order-edits' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{ "order_id": "my_order_id", "internal_note": "my_optional_note" }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrderEditsRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrderEditsReq'
  /admin/order-edits/{id}:
    delete:
      operationId: DeleteOrderEditsOrderEdit
      summary: Delete an Order Edit
      description: Delete an Order Edit. Only order edits that have the status `created`
        can be deleted.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orderEdits.delete(orderEditId)
          .then(({ id, object, deleted }) => {
          console.log(id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteOrderEdit } from "medusa-react"
          type Props = {
          orderEditId: string
          }
          const OrderEdit = ({ orderEditId }: Props) => {
          const deleteOrderEdit = useAdminDeleteOrderEdit(
          orderEditId
          )
          const handleDelete = () => {
          deleteOrderEdit.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default OrderEdit
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/order-edits/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrderEditDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order Edit to delete.
    get:
      operationId: GetOrderEditsOrderEdit
      summary: Get an Order Edit
      description: Retrieve an Order Edit's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
        queryParams: GetOrderEditsOrderEditParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orderEdits.retrieve(orderEditId)
          .then(({ order_edit }) => {
          console.log(order_edit.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminOrderEdit } from "medusa-react"
          type Props = {
          orderEditId: string
          }
          const OrderEdit = ({ orderEditId }: Props) => {
          const {
          order_edit,
          isLoading,
          } = useAdminOrderEdit(orderEditId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {order_edit && <span>{order_edit.status}</span>}
          </div>
          )
          }
          export default OrderEdit
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/order-edits/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrderEditsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the OrderEdit.
      - (query) expand {string} Comma-separated relations that should be expanded
        in each returned order edit.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order edit.
    post:
      operationId: PostOrderEditsOrderEdit
      summary: Update an Order Edit
      description: Update an Order Edit's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orderEdits.update(orderEditId, {
          internal_note: "internal reason XY"
          })
          .then(({ order_edit }) => {
          console.log(order_edit.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateOrderEdit } from "medusa-react"
          type Props = {
          orderEditId: string
          }
          const OrderEdit = ({ orderEditId }: Props) => {
          const updateOrderEdit = useAdminUpdateOrderEdit(
          orderEditId,
          )
          const handleUpdate = (
          internalNote: string
          ) => {
          updateOrderEdit.mutate({
          internal_note: internalNote
          }, {
          onSuccess: ({ order_edit }) => {
          console.log(order_edit.internal_note)
          }
          })
          }
          // ...
          }
          export default OrderEdit
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/order-edits/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "internal_note": "internal reason XY"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrderEditsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the OrderEdit.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrderEditsOrderEditReq'
  /admin/order-edits/{id}/cancel:
    post:
      operationId: PostOrderEditsOrderEditCancel
      summary: Cancel an Order Edit
      description: Cancel an Order Edit.
      x-authenticated: true
      x-codegen:
        method: cancel
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orderEdits.cancel(orderEditId)
          .then(({ order_edit }) => {
          console.log(order_edit.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminCancelOrderEdit
          } from "medusa-react"
          type Props = {
          orderEditId: string
          }
          const OrderEdit = ({ orderEditId }: Props) => {
          const cancelOrderEdit =
          useAdminCancelOrderEdit(
          orderEditId
          )
          const handleCancel = () => {
          cancelOrderEdit.mutate(void 0, {
          onSuccess: ({ order_edit }) => {
          console.log(
          order_edit.id
          )
          }
          })
          }
          // ...
          }
          export default OrderEdit
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/order-edits/{id}/cancel' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrderEditsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the OrderEdit.
  /admin/order-edits/{id}/changes/{change_id}:
    delete:
      operationId: DeleteOrderEditsOrderEditItemChange
      summary: Delete a Line Item Change
      description: Delete a line item change that indicates the addition, deletion,
        or update of a line item in the original order.
      x-authenticated: true
      x-codegen:
        method: deleteItemChange
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orderEdits.deleteItemChange(orderEdit_id, itemChangeId)
          .then(({ id, object, deleted }) => {
          console.log(id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteOrderEditItemChange } from "medusa-react"
          type Props = {
          orderEditId: string
          itemChangeId: string
          }
          const OrderEditItemChange = ({
          orderEditId,
          itemChangeId
          }: Props) => {
          const deleteItemChange = useAdminDeleteOrderEditItemChange(
          orderEditId,
          itemChangeId
          )
          const handleDeleteItemChange = () => {
          deleteItemChange.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default OrderEditItemChange
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/order-edits/{id}/changes/{change_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrderEditItemChangeDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order Edit.
      - (path) change_id=* {string} The ID of the Line Item Change to delete.
  /admin/order-edits/{id}/confirm:
    post:
      operationId: PostOrderEditsOrderEditConfirm
      summary: Confirm an OrderEdit
      description: Confirm an Order Edit. This will reflect the changes in the order
        edit on the associated order.
      x-authenticated: true
      x-codegen:
        method: confirm
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orderEdits.confirm(orderEditId)
          .then(({ order_edit }) => {
          console.log(order_edit.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminConfirmOrderEdit } from "medusa-react"
          type Props = {
          orderEditId: string
          }
          const OrderEdit = ({ orderEditId }: Props) => {
          const confirmOrderEdit = useAdminConfirmOrderEdit(
          orderEditId
          )
          const handleConfirmOrderEdit = () => {
          confirmOrderEdit.mutate(void 0, {
          onSuccess: ({ order_edit }) => {
          console.log(
          order_edit.confirmed_at,
          order_edit.confirmed_by
          )
          }
          })
          }
          // ...
          }
          export default OrderEdit
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/order-edits/{id}/confirm' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrderEditsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the order edit.
  /admin/order-edits/{id}/items:
    post:
      operationId: PostOrderEditsEditLineItems
      summary: Add a Line Item
      description: Create a line item change in the order edit that indicates adding
        an item in the original order. The item will not be added to the original
        order until the order edit is confirmed.
      x-authenticated: true
      x-codegen:
        method: addLineItem
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orderEdits.addLineItem(orderEditId, {
          variant_id,
          quantity
          })
          .then(({ order_edit }) => {
          console.log(order_edit.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminOrderEditAddLineItem } from "medusa-react"
          type Props = {
          orderEditId: string
          }
          const OrderEdit = ({ orderEditId }: Props) => {
          const addLineItem = useAdminOrderEditAddLineItem(
          orderEditId
          )
          const handleAddLineItem =
          (quantity: number, variantId: string) => {
          addLineItem.mutate({
          quantity,
          variant_id: variantId,
          }, {
          onSuccess: ({ order_edit }) => {
          console.log(order_edit.changes)
          }
          })
          }
          // ...
          }
          export default OrderEdit
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/order-edits/{id}/items' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{ "variant_id": "variant_01G1G5V2MRX2V3PVSR2WXYPFB6", "quantity": 3 }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrderEditsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order Edit.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrderEditsEditLineItemsReq'
  /admin/order-edits/{id}/items/{item_id}:
    delete:
      operationId: DeleteOrderEditsOrderEditLineItemsLineItem
      summary: Delete Line Item
      description: Create a line item change in the order edit that indicates deleting
        an item in the original order. The item in the original order will not be
        deleted until the order edit is confirmed.
      x-authenticated: true
      x-codegen:
        method: removeLineItem
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orderEdits.removeLineItem(orderEditId, lineItemId)
          .then(({ order_edit }) => {
          console.log(order_edit.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminOrderEditDeleteLineItem } from "medusa-react"
          type Props = {
          orderEditId: string
          itemId: string
          }
          const OrderEditLineItem = ({
          orderEditId,
          itemId
          }: Props) => {
          const removeLineItem = useAdminOrderEditDeleteLineItem(
          orderEditId,
          itemId
          )
          const handleRemoveLineItem = () => {
          removeLineItem.mutate(void 0, {
          onSuccess: ({ order_edit }) => {
          console.log(order_edit.changes)
          }
          })
          }
          // ...
          }
          export default OrderEditLineItem
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/order-edits/{id}/items/{item_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrderEditsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order Edit.
      - (path) item_id=* {string} The ID of line item in the original order.
    post:
      operationId: PostOrderEditsEditLineItemsLineItem
      summary: Upsert Line Item Change
      description: Create or update a line item change in the order edit that indicates
        addition, deletion, or update of a line item into an original order. Line
        item changes are only reflected on the original order after the order edit
        is confirmed.
      x-authenticated: true
      x-codegen:
        method: updateLineItem
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orderEdits.updateLineItem(orderEditId, lineItemId, {
          quantity: 5
          })
          .then(({ order_edit }) => {
          console.log(order_edit.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminOrderEditUpdateLineItem } from "medusa-react"
          type Props = {
          orderEditId: string
          itemId: string
          }
          const OrderEditItemChange = ({
          orderEditId,
          itemId
          }: Props) => {
          const updateLineItem = useAdminOrderEditUpdateLineItem(
          orderEditId,
          itemId
          )
          const handleUpdateLineItem = (quantity: number) => {
          updateLineItem.mutate({
          quantity,
          }, {
          onSuccess: ({ order_edit }) => {
          console.log(order_edit.items)
          }
          })
          }
          // ...
          }
          export default OrderEditItemChange
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/order-edits/{id}/items/{item_id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{ "quantity": 5 }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrderEditsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order Edit.
      - (path) item_id=* {string} The ID of the line item in the original order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrderEditsEditLineItemsLineItemReq'
  /admin/order-edits/{id}/request:
    post:
      operationId: PostOrderEditsOrderEditRequest
      summary: Request Confirmation
      description: Request customer confirmation of an Order Edit. This would emit
        the event `order-edit.requested` which Notification Providers listen to and
        send a notification to the customer about the order edit.
      x-authenticated: true
      x-codegen:
        method: requestConfirmation
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orderEdits.requestConfirmation(orderEditId)
          .then({ order_edit }) => {
          console.log(order_edit.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminRequestOrderEditConfirmation,
          } from "medusa-react"
          type Props = {
          orderEditId: string
          }
          const OrderEdit = ({ orderEditId }: Props) => {
          const requestOrderConfirmation =
          useAdminRequestOrderEditConfirmation(
          orderEditId
          )
          const handleRequestConfirmation = () => {
          requestOrderConfirmation.mutate(void 0, {
          onSuccess: ({ order_edit }) => {
          console.log(
          order_edit.requested_at,
          order_edit.requested_by
          )
          }
          })
          }
          // ...
          }
          export default OrderEdit
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/order-edits/{id}/request' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrderEditsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order Edit.
  /admin/orders:
    get:
      operationId: GetOrders
      summary: List Orders
      description: Retrieve a list of Orders. The orders can be filtered by fields
        such as `status` or `display_id`. The order can also be paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetOrdersParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.list()
          .then(({ orders, limit, offset, count }) => {
          console.log(orders.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminOrders } from "medusa-react"
          const Orders = () => {
          const { orders, isLoading } = useAdminOrders()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {orders && !orders.length && <span>No Orders</span>}
          {orders && orders.length > 0 && (
          <ul>
          {orders.map((order) => (
          <li key={order.id}>{order.display_id}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Orders
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/orders' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersListRes'
          description: OK
      parameters:
      - (query) q {string} term to search orders' shipping address, first name, email,
        and display ID
      - (query) id {string} Filter by ID.
      - description: Filter by status
        enum:
        - pending
        - completed
        - archived
        - canceled
        - requires_action
        explode: false
        in: query
        items: null
        name: status
        schema: null
        style: form
        type: string
      - description: Filter by fulfillment status
        enum:
        - not_fulfilled
        - fulfilled
        - partially_fulfilled
        - shipped
        - partially_shipped
        - canceled
        - returned
        - partially_returned
        - requires_action
        explode: false
        in: query
        items: null
        name: fulfillment_status
        schema: null
        style: form
        type: string
      - description: Filter by payment status
        enum:
        - captured
        - awaiting
        - not_paid
        - refunded
        - partially_refunded
        - canceled
        - requires_action
        explode: false
        in: query
        items: null
        name: payment_status
        schema: null
        style: form
        type: string
      - (query) display_id {string} Filter by display ID
      - (query) cart_id {string} Filter by cart ID
      - (query) customer_id {string} Filter by customer ID
      - (query) email {string} Filter by email
      - description: Filter by region IDs.
        explode: false
        in: query
        name: region_id
        oneOf: null
        schema: null
        style: form
      - description: ID of a Region.
        type: string
      - description: ID of a Region.
        items: null
        type: string
      - description: See a list of codes.
        explode: false
        externalDocs: null
        in: query
        name: currency_code
        schema: null
        style: form
        type: string
        url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
      - (query) tax_rate {string} Filter by tax rate.
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: canceled_at
        properties: null
        schema: null
        type: string
      - description: The ID of a Sales Channel
        explode: false
        in: query
        items: null
        name: sales_channel_id
        schema: null
        style: form
        type: string
      - (query) offset=0 {integer} The number of orders to skip when retrieving the
        orders.
      - (query) limit=50 {integer} Limit the number of orders returned.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      - (query) order {string} A order field to sort-order the retrieved orders by.
  /admin/orders/{id}:
    get:
      operationId: GetOrdersOrder
      summary: Get an Order
      description: Retrieve an Order's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
        queryParams: AdminGetOrdersOrderParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.retrieve(orderId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminOrder } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const {
          order,
          isLoading,
          } = useAdminOrder(orderId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {order && <span>{order.display_id}</span>}
          </div>
          )
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/orders/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
    post:
      operationId: PostOrdersOrder
      summary: Update an Order
      description: Update and order's details.
      x-authenticated: true
      x-codegen:
        method: update
        params: AdminPostOrdersOrderParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.update(orderId, {
          email: "user@example.com"
          })
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateOrder } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const updateOrder = useAdminUpdateOrder(
          orderId
          )
          const handleUpdate = (
          email: string
          ) => {
          updateOrder.mutate({
          email,
          }, {
          onSuccess: ({ order }) => {
          console.log(order.email)
          }
          })
          }
          // ...
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/adasda' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderReq'
  /admin/orders/{id}/archive:
    post:
      operationId: PostOrdersOrderArchive
      summary: Archive Order
      description: Archive an order and change its status.
      x-authenticated: true
      x-codegen:
        method: archive
        params: AdminPostOrdersOrderArchiveParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.archive(orderId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminArchiveOrder } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const archiveOrder = useAdminArchiveOrder(
          orderId
          )
          // ...
          const handleArchivingOrder = () => {
          archiveOrder.mutate(void 0, {
          onSuccess: ({ order }) => {
          console.log(order.status)
          }
          })
          }
          // ...
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/archive' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
  /admin/orders/{id}/cancel:
    post:
      operationId: PostOrdersOrderCancel
      summary: Cancel an Order
      description: Cancel an order and change its status. This will also cancel any
        associated Fulfillments and Payments, and it may fail if the Payment or Fulfillment
        Provider is unable to cancel the Payment/Fulfillment.
      x-authenticated: true
      x-codegen:
        method: cancel
        params: AdminPostOrdersOrderCancel
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.cancel(orderId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCancelOrder } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const cancelOrder = useAdminCancelOrder(
          orderId
          )
          // ...
          const handleCancel = () => {
          cancelOrder.mutate(void 0, {
          onSuccess: ({ order }) => {
          console.log(order.status)
          }
          })
          }
          // ...
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/cancel' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
  /admin/orders/{id}/capture:
    post:
      operationId: PostOrdersOrderCapture
      summary: Capture an Order's Payments
      description: Capture all the Payments associated with an Order. The payment
        of canceled orders can't be captured.
      x-authenticated: true
      x-codegen:
        method: capturePayment
        params: AdminPostOrdersOrderCaptureParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.capturePayment(orderId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCapturePayment } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const capturePayment = useAdminCapturePayment(
          orderId
          )
          // ...
          const handleCapture = () => {
          capturePayment.mutate(void 0, {
          onSuccess: ({ order }) => {
          console.log(order.status)
          }
          })
          }
          // ...
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/capture' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
  /admin/orders/{id}/claims:
    post:
      operationId: PostOrdersOrderClaims
      summary: Create a Claim
      description: Create a Claim for an order. If a return shipping method is specified,
        a return will also be created and associated with the claim. If the claim's
        type is `refund`, the refund is processed as well.
      x-authenticated: true
      x-codegen:
        method: createClaim
        params: AdminPostOrdersOrderClaimsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.createClaim(orderId, {
            type: 'refund',
            claim_items: [
              {
                item_id,
                quantity: 1
              }
            ]
          })
          .then(({ order }) => {
            console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateClaim } from "medusa-react"
          type Props = {
            orderId: string
          }
      responses: {}
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderClaimsReq'
      externalDocs:
        description: How are claims created
        url: https://docs.medusajs.com/modules/orders/claims#how-are-claims-created
  /admin/orders/{id}/claims/{claim_id}:
    post:
      operationId: PostOrdersOrderClaimsClaim
      summary: Update a Claim
      description: Update a Claim's details.
      x-authenticated: true
      x-codegen:
        method: updateClaim
        params: AdminPostOrdersOrderClaimsClaimParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.updateClaim(orderId, claimId, {
          no_notification: true
          })
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateClaim } from "medusa-react"
          type Props = {
          orderId: string
          claimId: string
          }
          const Claim = ({ orderId, claimId }: Props) => {
          const updateClaim = useAdminUpdateClaim(orderId)
          // ...
          const handleUpdate = () => {
          updateClaim.mutate({
          claim_id: claimId,
          no_notification: false
          }, {
          onSuccess: ({ order }) => {
          console.log(order.claims)
          }
          })
          }
          // ...
          }
          export default Claim
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/claims/{claim_id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "no_notification": true
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order associated with the claim.
      - (path) claim_id=* {string} The ID of the Claim.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderClaimsClaimReq'
  /admin/orders/{id}/claims/{claim_id}/cancel:
    post:
      operationId: PostOrdersClaimCancel
      summary: Cancel a Claim
      description: Cancel a Claim and change its status. A claim can't be canceled
        if it has a refund, if its fulfillments haven't been canceled, of if its associated
        return hasn't been canceled.
      x-authenticated: true
      x-codegen:
        method: cancelClaim
        params: AdminPostOrdersClaimCancel
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.cancelClaim(orderId, claimId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCancelClaim } from "medusa-react"
          type Props = {
          orderId: string
          claimId: string
          }
          const Claim = ({ orderId, claimId }: Props) => {
          const cancelClaim = useAdminCancelClaim(orderId)
          // ...
          const handleCancel = () => {
          cancelClaim.mutate(claimId)
          }
          // ...
          }
          export default Claim
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/claims/{claim_id}/cancel' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the order the claim is associated with.
      - (path) claim_id=* {string} The ID of the Claim.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      externalDocs:
        description: Canceling a claim
        url: https://docs.medusajs.com/modules/orders/claims#cancel-a-claim
  /admin/orders/{id}/claims/{claim_id}/fulfillments:
    post:
      operationId: PostOrdersOrderClaimsClaimFulfillments
      summary: Create a Claim Fulfillment
      description: Create a Fulfillment for a Claim, and change its fulfillment status
        to `partially_fulfilled` or `fulfilled` depending on whether all the items
        were fulfilled. It may also change the status to `requires_action` if any
        actions are required.
      x-authenticated: true
      x-codegen:
        method: fulfillClaim
        params: AdminPostOrdersOrderClaimsClaimFulfillmentsReq
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.fulfillClaim(orderId, claimId, {
          })
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminFulfillClaim } from "medusa-react"
          type Props = {
          orderId: string
          claimId: string
          }
          const Claim = ({ orderId, claimId }: Props) => {
          const fulfillClaim = useAdminFulfillClaim(orderId)
          // ...
          const handleFulfill = () => {
          fulfillClaim.mutate({
          claim_id: claimId,
          }, {
          onSuccess: ({ order }) => {
          console.log(order.claims)
          }
          })
          }
          // ...
          }
          export default Claim
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/claims/{claim_id}/fulfillments' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order the claim is associated with.
      - (path) claim_id=* {string} The ID of the Claim.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderClaimsClaimFulfillmentsReq'
      externalDocs:
        description: Fulfill a claim
        url: https://docs.medusajs.com/modules/orders/claims#fulfill-a-claim
  /admin/orders/{id}/claims/{claim_id}/fulfillments/{fulfillment_id}/cancel:
    post:
      operationId: PostOrdersClaimFulfillmentsCancel
      summary: Cancel Claim's Fulfillment
      description: Cancel a claim's fulfillment and change its fulfillment status
        to `canceled`.
      x-authenticated: true
      x-codegen:
        method: cancelClaimFulfillment
        params: AdminPostOrdersClaimFulfillmentsCancelParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.cancelClaimFulfillment(orderId, claimId, fulfillmentId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCancelClaimFulfillment } from "medusa-react"
          type Props = {
          orderId: string
          claimId: string
          }
          const Claim = ({ orderId, claimId }: Props) => {
          const cancelFulfillment = useAdminCancelClaimFulfillment(
          orderId
          )
          // ...
          const handleCancel = (fulfillmentId: string) => {
          cancelFulfillment.mutate({
          claim_id: claimId,
          fulfillment_id: fulfillmentId,
          }, {
          onSuccess: ({ order }) => {
          console.log(order.claims)
          }
          })
          }
          // ...
          }
          export default Claim
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/claims/{claim_id}/fulfillments/{fulfillment_id}/cancel' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the order the claim is associated with.
      - (path) claim_id=* {string} The ID of the claim.
      - (path) fulfillment_id=* {string} The ID of the fulfillment.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
  /admin/orders/{id}/claims/{claim_id}/shipments:
    post:
      operationId: PostOrdersOrderClaimsClaimShipments
      summary: Ship a Claim's Fulfillment
      description: Create a shipment for the claim and mark its fulfillment as shipped.
        This changes the claim's fulfillment status to either `partially_shipped`
        or `shipped`, depending on whether all the items were shipped.
      x-authenticated: true
      x-codegen:
        method: createClaimShipment
        params: AdminPostOrdersOrderClaimsClaimShipmentsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.createClaimShipment(orderId, claimId, {
          fulfillment_id
          })
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateClaimShipment } from "medusa-react"
          type Props = {
          orderId: string
          claimId: string
          }
          const Claim = ({ orderId, claimId }: Props) => {
          const createShipment = useAdminCreateClaimShipment(orderId)
          // ...
          const handleCreateShipment = (fulfillmentId: string) => {
          createShipment.mutate({
          claim_id: claimId,
          fulfillment_id: fulfillmentId,
          }, {
          onSuccess: ({ order }) => {
          console.log(order.claims)
          }
          })
          }
          // ...
          }
          export default Claim
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/claims/{claim_id}/shipments' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "fulfillment_id": "{fulfillment_id}"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order the claim is associated with.
      - (path) claim_id=* {string} The ID of the Claim.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderClaimsClaimShipmentsReq'
      externalDocs:
        description: Fulfill a claim
        url: https://docs.medusajs.com/modules/orders/claims#fulfill-a-claim
  /admin/orders/{id}/complete:
    post:
      operationId: PostOrdersOrderComplete
      summary: Complete an Order
      description: Complete an Order and change its status. A canceled order can't
        be completed.
      x-authenticated: true
      x-codegen:
        method: complete
        params: AdminPostOrdersOrderCompleteParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.complete(orderId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCompleteOrder } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const completeOrder = useAdminCompleteOrder(
          orderId
          )
          // ...
          const handleComplete = () => {
          completeOrder.mutate(void 0, {
          onSuccess: ({ order }) => {
          console.log(order.status)
          }
          })
          }
          // ...
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/complete' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
  /admin/orders/{id}/fulfillment:
    post:
      operationId: PostOrdersOrderFulfillments
      summary: Create a Fulfillment
      description: Create a Fulfillment of an Order using the fulfillment provider,
        and change the order's fulfillment status to either `partially_fulfilled`
        or `fulfilled`, depending on whether all the items were fulfilled.
      x-authenticated: true
      x-codegen:
        method: createFulfillment
        params: AdminPostOrdersOrderFulfillmentsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.createFulfillment(orderId, {
          items: [
          {
          item_id,
          quantity: 1
          }
          ]
          })
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateFulfillment } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const createFulfillment = useAdminCreateFulfillment(
          orderId
          )
          // ...
          const handleCreateFulfillment = (
          itemId: string,
          quantity: number
          ) => {
          createFulfillment.mutate({
          items: [
          {
          item_id: itemId,
          quantity,
          },
          ],
          }, {
          onSuccess: ({ order }) => {
          console.log(order.fulfillments)
          }
          })
          }
          // ...
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/fulfillment' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "items": [
          {
          "item_id": "{item_id}",
          "quantity": 1
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderFulfillmentsReq'
      externalDocs:
        description: Fulfillments of orders
        url: https://docs.medusajs.com/modules/orders/#fulfillments-in-orders
  /admin/orders/{id}/fulfillments/{fulfillment_id}/cancel:
    post:
      operationId: PostOrdersOrderFulfillmentsCancel
      summary: Cancel a Fulfilmment
      description: Cancel an order's fulfillment and change its fulfillment status
        to `canceled`.
      x-authenticated: true
      x-codegen:
        method: cancelFulfillment
        params: AdminPostOrdersOrderFulfillementsCancelParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.cancelFulfillment(orderId, fulfillmentId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCancelFulfillment } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const cancelFulfillment = useAdminCancelFulfillment(
          orderId
          )
          // ...
          const handleCancel = (
          fulfillmentId: string
          ) => {
          cancelFulfillment.mutate(fulfillmentId, {
          onSuccess: ({ order }) => {
          console.log(order.fulfillments)
          }
          })
          }
          // ...
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/fulfillments/{fulfillment_id}/cancel' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (path) fulfillment_id=* {string} The ID of the Fulfillment.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
  /admin/orders/{id}/line-items/{line_item_id}/reserve:
    post:
      operationId: PostOrdersOrderLineItemReservations
      summary: Create a Reservation
      description: Create a Reservation for a line item at a specified location, optionally
        for a partial quantity.
      x-authenticated: true
      x-codeSamples:
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/line-items/{line_item_id}/reserve' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "location_id": "loc_1"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPostReservationsReq'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (path) line_item_id=* {string} The ID of the Line item.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminOrdersOrderLineItemReservationReq'
  /admin/orders/{id}/refund:
    post:
      operationId: PostOrdersOrderRefunds
      summary: Create a Refund
      description: Refund an amount for an order. The amount must be less than or
        equal the `refundable_amount` of the order.
      x-authenticated: true
      x-codegen:
        method: refundPayment
        params: AdminPostOrdersOrderRefundsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.refundPayment(orderId, {
          amount: 1000,
          reason: "Do not like it"
          })
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminRefundPayment } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const refundPayment = useAdminRefundPayment(
          orderId
          )
          // ...
          const handleRefund = (
          amount: number,
          reason: string
          ) => {
          refundPayment.mutate({
          amount,
          reason,
          }, {
          onSuccess: ({ order }) => {
          console.log(order.refunds)
          }
          })
          }
          // ...
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/adasda/refund' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "amount": 1000,
          "reason": "Do not like it"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderRefundsReq'
  /admin/orders/{id}/reservations:
    get:
      operationId: GetOrdersOrderReservations
      summary: Get Order Reservations
      description: Retrieve the list of reservations of an Order
      x-authenticated: true
      x-codeSamples:
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/orders/{id}/reservations' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminReservationsListRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) offset=0 {integer} The number of reservations to skip when retrieving
        the reservations.
      - (query) limit=20 {integer} Limit the number of reservations returned.
  /admin/orders/{id}/return:
    post:
      operationId: PostOrdersOrderReturns
      summary: Request a Return
      description: Request and create a Return for items in an order. If the return
        shipping method is specified, it will be automatically fulfilled.
      x-authenticated: true
      x-codegen:
        method: requestReturn
        params: AdminPostOrdersOrderReturnsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.requestReturn(orderId, {
          items: [
          {
          item_id,
          quantity: 1
          }
          ]
          })
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminRequestReturn } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const requestReturn = useAdminRequestReturn(
          orderId
          )
          // ...
          const handleRequestingReturn = (
          itemId: string,
          quantity: number
          ) => {
          requestReturn.mutate({
          items: [
          {
          item_id: itemId,
          quantity
          }
          ]
          }, {
          onSuccess: ({ order }) => {
          console.log(order.returns)
          }
          })
          }
          // ...
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/return' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "items": [
          {
          "item_id": "{item_id}",
          "quantity": 1
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderReturnsReq'
      externalDocs:
        description: Return creation process
        url: https://docs.medusajs.com/modules/orders/returns#returns-process
  /admin/orders/{id}/shipment:
    post:
      operationId: PostOrdersOrderShipment
      summary: Ship a Fulfillment
      description: Create a shipment and mark a fulfillment as shipped. This changes
        the order's fulfillment status to either `partially_shipped` or `shipped`,
        depending on whether all the items were shipped.
      x-authenticated: true
      x-codegen:
        method: createShipment
        params: AdminPostOrdersOrderShipmentParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.createShipment(order_id, {
          fulfillment_id
          })
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateShipment } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const createShipment = useAdminCreateShipment(
          orderId
          )
          // ...
          const handleCreate = (
          fulfillmentId: string
          ) => {
          createShipment.mutate({
          fulfillment_id: fulfillmentId,
          }, {
          onSuccess: ({ order }) => {
          console.log(order.fulfillment_status)
          }
          })
          }
          // ...
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/shipment' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "fulfillment_id": "{fulfillment_id}"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderShipmentReq'
      externalDocs:
        description: Fulfillments of orders
        url: https://docs.medusajs.com/modules/orders/#fulfillments-in-orders
  /admin/orders/{id}/shipping-methods:
    post:
      operationId: PostOrdersOrderShippingMethods
      summary: Add a Shipping Method
      description: Add a Shipping Method to an Order. If another Shipping Method exists
        with the same Shipping Profile, the previous Shipping Method will be replaced.
      x-authenticated: true
      x-codegen:
        method: addShippingMethod
        params: AdminPostOrdersOrderShippingMethodsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.addShippingMethod(orderId, {
          price: 1000,
          option_id
          })
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminAddShippingMethod } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const addShippingMethod = useAdminAddShippingMethod(
          orderId
          )
          // ...
          const handleAddShippingMethod = (
          optionId: string,
          price: number
          ) => {
          addShippingMethod.mutate({
          option_id: optionId,
          price
          }, {
          onSuccess: ({ order }) => {
          console.log(order.shipping_methods)
          }
          })
          }
          // ...
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/shipping-methods' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "price": 1000,
          "option_id": "{option_id}"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderShippingMethodsReq'
  /admin/orders/{id}/swaps:
    post:
      operationId: PostOrdersOrderSwaps
      summary: Create a Swap
      description: Create a Swap. This includes creating a return that is associated
        with the swap.
      x-authenticated: true
      x-codegen:
        method: createSwap
        queryParams: AdminPostOrdersOrderSwapsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.createSwap(orderId, {
          return_items: [
          {
          item_id,
          quantity: 1
          }
          ]
          })
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateSwap } from "medusa-react"
          type Props = {
          orderId: string
          }
          const CreateSwap = ({ orderId }: Props) => {
          const createSwap = useAdminCreateSwap(orderId)
          // ...
          const handleCreate = (
          returnItems: {
          item_id: string,
          quantity: number
          }[]
          ) => {
          createSwap.mutate({
          return_items: returnItems
          }, {
          onSuccess: ({ order }) => {
          console.log(order.swaps)
          }
          })
          }
          // ...
          }
          export default CreateSwap
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/swaps' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "return_items": [
          {
          "item_id": "asfasf",
          "quantity": 1
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderSwapsReq'
      externalDocs:
        description: How are swaps created
        url: https://docs.medusajs.com/modules/orders/swaps#how-are-swaps-created
  /admin/orders/{id}/swaps/{swap_id}/cancel:
    post:
      operationId: PostOrdersSwapCancel
      summary: Cancel a Swap
      description: Cancel a Swap and change its status.
      x-authenticated: true
      x-codegen:
        method: cancelSwap
        params: AdminPostOrdersSwapCancelParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.cancelSwap(orderId, swapId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCancelSwap } from "medusa-react"
          type Props = {
          orderId: string,
          swapId: string
          }
          const Swap = ({
          orderId,
          swapId
          }: Props) => {
          const cancelSwap = useAdminCancelSwap(
          orderId
          )
          // ...
          const handleCancel = () => {
          cancelSwap.mutate(swapId, {
          onSuccess: ({ order }) => {
          console.log(order.swaps)
          }
          })
          }
          // ...
          }
          export default Swap
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{order_id}/swaps/{swap_id}/cancel' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order the swap is associated with.
      - (path) swap_id=* {string} The ID of the Swap.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      externalDocs:
        description: Canceling a swap
        url: https://docs.medusajs.com/modules/orders/swaps#canceling-a-swap
  /admin/orders/{id}/swaps/{swap_id}/fulfillments:
    post:
      operationId: PostOrdersOrderSwapsSwapFulfillments
      summary: Create a Swap Fulfillment
      description: Create a Fulfillment for a Swap and change its fulfillment status
        to `fulfilled`. If it requires any additional actions, its fulfillment status
        may change to `requires_action`.
      x-authenticated: true
      x-codegen:
        method: fulfillSwap
        params: AdminPostOrdersOrderSwapsSwapFulfillmentsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
      responses: {}
      parameters:
      - (path) id=* {string} The ID of the Order the swap is associated with.
      - (path) swap_id=* {string} The ID of the Swap.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderSwapsSwapFulfillmentsReq'
      externalDocs:
        description: Handling a swap's fulfillment
        url: https://docs.medusajs.com/modules/orders/swaps#handling-swap-fulfillment
  /admin/orders/{id}/swaps/{swap_id}/fulfillments/{fulfillment_id}/cancel:
    post:
      operationId: PostOrdersSwapFulfillmentsCancel
      summary: Cancel Swap's Fulfilmment
      description: Cancel a swap's fulfillment and change its fulfillment status to
        `canceled`.
      x-authenticated: true
      x-codegen:
        method: cancelSwapFulfillment
        params: AdminPostOrdersSwapFulfillementsCancelParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.cancelSwapFulfillment(orderId, swapId, fulfillmentId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCancelSwapFulfillment } from "medusa-react"
          type Props = {
          orderId: string,
          swapId: string
          }
          const Swap = ({
          orderId,
          swapId
          }: Props) => {
          const cancelFulfillment = useAdminCancelSwapFulfillment(
          orderId
          )
          // ...
          const handleCancelFulfillment = (
          fulfillmentId: string
          ) => {
          cancelFulfillment.mutate({
          swap_id: swapId,
          fulfillment_id: fulfillmentId,
          })
          }
          // ...
          }
          export default Swap
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/swaps/{swap_id}/fulfillments/{fulfillment_id}/cancel' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the order the swap is associated with.
      - (path) swap_id=* {string} The ID of the swap.
      - (path) fulfillment_id=* {string} The ID of the fulfillment.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
  /admin/orders/{id}/swaps/{swap_id}/process-payment:
    post:
      operationId: PostOrdersOrderSwapsSwapProcessPayment
      summary: Process a Swap Payment
      description: Process a swap's payment either by refunding or issuing a payment.
        This depends on the `difference_due` of the swap. If `difference_due` is negative,
        the amount is refunded. If `difference_due` is positive, the amount is captured.
      x-authenticated: true
      x-codegen:
        method: processSwapPayment
        params: AdminPostOrdersOrderSwapsSwapProcessPaymentParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.processSwapPayment(orderId, swapId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminProcessSwapPayment } from "medusa-react"
          type Props = {
          orderId: string,
          swapId: string
          }
          const Swap = ({
          orderId,
          swapId
          }: Props) => {
          const processPayment = useAdminProcessSwapPayment(
          orderId
          )
          // ...
          const handleProcessPayment = () => {
          processPayment.mutate(swapId, {
          onSuccess: ({ order }) => {
          console.log(order.swaps)
          }
          })
          }
          // ...
          }
          export default Swap
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/swaps/{swap_id}/process-payment' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the order the swap is associated with.
      - (path) swap_id=* {string} The ID of the swap.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      externalDocs:
        description: Handling a swap's payment
        url: https://docs.medusajs.com/modules/orders/swaps#handling-swap-payment
  /admin/orders/{id}/swaps/{swap_id}/shipments:
    post:
      operationId: PostOrdersOrderSwapsSwapShipments
      summary: Ship a Swap's Fulfillment
      description: Create a shipment for a swap and mark its fulfillment as shipped.
        This changes the swap's fulfillment status to either `partially_shipped` or
        `shipped`, depending on whether all the items were shipped.
      x-authenticated: true
      x-codegen:
        method: createSwapShipment
        params: AdminPostOrdersOrderSwapsSwapShipmentsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.orders.createSwapShipment(orderId, swapId, {
          fulfillment_id
          })
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateSwapShipment } from "medusa-react"
          type Props = {
          orderId: string,
          swapId: string
          }
          const Swap = ({
          orderId,
          swapId
          }: Props) => {
          const createShipment = useAdminCreateSwapShipment(
          orderId
          )
          // ...
          const handleCreateShipment = (
          fulfillmentId: string
          ) => {
          createShipment.mutate({
          swap_id: swapId,
          fulfillment_id: fulfillmentId,
          }, {
          onSuccess: ({ order }) => {
          console.log(order.swaps)
          }
          })
          }
          // ...
          }
          export default Swap
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/orders/{id}/swaps/{swap_id}/shipments' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "fulfillment_id": "{fulfillment_id}"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (path) swap_id=* {string} The ID of the Swap.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned order.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostOrdersOrderSwapsSwapShipmentsReq'
      externalDocs:
        description: Handling swap fulfillments
        url: https://docs.medusajs.com/modules/orders/swaps#handling-swap-fulfillment
  /admin/payment-collections/{id}:
    delete:
      operationId: DeletePaymentCollectionsPaymentCollection
      summary: Delete a Payment Collection
      description: Delete a Payment Collection. Only payment collections with the
        statuses `canceled` or `not_paid` can be deleted.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.paymentCollections.delete(paymentCollectionId)
          .then(({ id, object, deleted }) => {
          console.log(id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeletePaymentCollection } from "medusa-react"
          type Props = {
          paymentCollectionId: string
          }
          const PaymentCollection = ({ paymentCollectionId }: Props) => {
          const deleteCollection = useAdminDeletePaymentCollection(
          paymentCollectionId
          )
          // ...
          const handleDelete = () => {
          deleteCollection.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default PaymentCollection
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/payment-collections/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payment Collections
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPaymentCollectionDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Payment Collection.
    get:
      operationId: GetPaymentCollectionsPaymentCollection
      summary: Get a Payment Collection
      description: Retrieve a Payment Collection's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
        queryParams: AdminGetPaymentCollectionsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.paymentCollections.retrieve(paymentCollectionId)
          .then(({ payment_collection }) => {
          console.log(payment_collection.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminPaymentCollection } from "medusa-react"
          type Props = {
          paymentCollectionId: string
          }
          const PaymentCollection = ({ paymentCollectionId }: Props) => {
          const {
          payment_collection,
          isLoading,
          } = useAdminPaymentCollection(paymentCollectionId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {payment_collection && (
          <span>{payment_collection.status}</span>
          )}
          </div>
          )
          }
          export default PaymentCollection
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/payment-collections/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payment Collections
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPaymentCollectionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Payment Collection.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned payment collection.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned payment collection.
    post:
      operationId: PostPaymentCollectionsPaymentCollection
      summary: Update Payment Collection
      description: Update a Payment Collection's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.paymentCollections.update(paymentCollectionId, {
          description
          })
          .then(({ payment_collection }) => {
          console.log(payment_collection.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdatePaymentCollection } from "medusa-react"
          type Props = {
          paymentCollectionId: string
          }
          const PaymentCollection = ({ paymentCollectionId }: Props) => {
          const updateCollection = useAdminUpdatePaymentCollection(
          paymentCollectionId
          )
          // ...
          const handleUpdate = (
          description: string
          ) => {
          updateCollection.mutate({
          description
          }, {
          onSuccess: ({ payment_collection }) => {
          console.log(payment_collection.description)
          }
          })
          }
          // ...
          }
          export default PaymentCollection
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/payment-collections/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "description": "Description of payment collection"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payment Collections
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPaymentCollectionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Payment Collection.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminUpdatePaymentCollectionsReq'
  /admin/payment-collections/{id}/authorize:
    post:
      operationId: PostPaymentCollectionsPaymentCollectionAuthorize
      summary: Mark Authorized
      description: Set the status of a Payment Collection as `authorized`. This will
        also change the `authorized_amount` of the payment collection.
      x-authenticated: true
      x-codegen:
        method: markAsAuthorized
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.paymentCollections.markAsAuthorized(paymentCollectionId)
          .then(({ payment_collection }) => {
          console.log(payment_collection.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminMarkPaymentCollectionAsAuthorized } from "medusa-react"
          type Props = {
          paymentCollectionId: string
          }
          const PaymentCollection = ({ paymentCollectionId }: Props) => {
          const markAsAuthorized = useAdminMarkPaymentCollectionAsAuthorized(
          paymentCollectionId
          )
          // ...
          const handleAuthorization = () => {
          markAsAuthorized.mutate(void 0, {
          onSuccess: ({ payment_collection }) => {
          console.log(payment_collection.status)
          }
          })
          }
          // ...
          }
          export default PaymentCollection
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/payment-collections/{id}/authorize' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payment Collections
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPaymentCollectionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Payment Collection.
  /admin/payments/{id}:
    get:
      operationId: GetPaymentsPayment
      summary: Get Payment details
      description: Retrieve a Payment's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
        queryParams: GetPaymentsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.payments.retrieve(paymentId)
          .then(({ payment }) => {
          console.log(payment.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminPayment } from "medusa-react"
          type Props = {
          paymentId: string
          }
          const Payment = ({ paymentId }: Props) => {
          const {
          payment,
          isLoading,
          } = useAdminPayment(paymentId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {payment && <span>{payment.amount}</span>}
          </div>
          )
          }
          export default Payment
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/payments/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payments
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPaymentRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Payment.
  /admin/payments/{id}/capture:
    post:
      operationId: PostPaymentsPaymentCapture
      summary: Capture a Payment
      description: Capture a Payment.
      x-authenticated: true
      x-codegen:
        method: capturePayment
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.payments.capturePayment(paymentId)
          .then(({ payment }) => {
          console.log(payment.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminPaymentsCapturePayment } from "medusa-react"
          type Props = {
          paymentId: string
          }
          const Payment = ({ paymentId }: Props) => {
          const capture = useAdminPaymentsCapturePayment(
          paymentId
          )
          // ...
          const handleCapture = () => {
          capture.mutate(void 0, {
          onSuccess: ({ payment }) => {
          console.log(payment.amount)
          }
          })
          }
          // ...
          }
          export default Payment
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/payments/{id}/capture' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payments
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPaymentRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Payment.
  /admin/payments/{id}/refund:
    post:
      operationId: PostPaymentsPaymentRefunds
      summary: Refund Payment
      description: Refund a payment. The payment must be captured first.
      x-authenticated: true
      x-codegen:
        method: refundPayment
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.payments.refundPayment(paymentId, {
          amount: 1000,
          reason: "return",
          note: "Do not like it",
          })
          .then(({ payment }) => {
          console.log(payment.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { RefundReason } from "@medusajs/medusa"
          import { useAdminPaymentsRefundPayment } from "medusa-react"
          type Props = {
          paymentId: string
          }
          const Payment = ({ paymentId }: Props) => {
          const refund = useAdminPaymentsRefundPayment(
          paymentId
          )
          // ...
          const handleRefund = (
          amount: number,
          reason: RefundReason,
          note: string
          ) => {
          refund.mutate({
          amount,
          reason,
          note
          }, {
          onSuccess: ({ refund }) => {
          console.log(refund.amount)
          }
          })
          }
          // ...
          }
          export default Payment
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/payments/pay_123/refund' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "amount": 1000,
          "reason": "return",
          "note": "Do not like it"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payments
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminRefundRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Payment.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostPaymentRefundsReq'
  /admin/price-lists:
    get:
      operationId: GetPriceLists
      summary: List Price Lists
      description: Retrieve a list of price lists. The price lists can be filtered
        by fields such as `q` or `status`. The price lists can also be sorted or paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetPriceListPaginationParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.priceLists.list()
          .then(({ price_lists, limit, offset, count }) => {
          console.log(price_lists.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminPriceLists } from "medusa-react"
          const PriceLists = () => {
          const { price_lists, isLoading } = useAdminPriceLists()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {price_lists && !price_lists.length && (
          <span>No Price Lists</span>
          )}
          {price_lists && price_lists.length > 0 && (
          <ul>
          {price_lists.map((price_list) => (
          <li key={price_list.id}>{price_list.name}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default PriceLists
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/price-lists' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Price Lists
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPriceListsListRes'
          description: OK
      parameters:
      - (query) limit=10 {number} Limit the number of price lists returned.
      - (query) offset=0 {number} The number of price lists to skip when retrieving
        the price lists.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned price lists.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned price lists.
      - (query) order {string} A price-list field to sort-order the retrieved price
        lists by.
      - (query) id {string} Filter by ID
      - (query) q {string} term to search price lists' description, name, and customer
        group's name.
      - description: Filter by status.
        enum:
        - active
        - draft
        explode: false
        in: query
        items: null
        name: status
        schema: null
        style: form
        type: string
      - (query) name {string} Filter by name
      - description: Filter by customer-group IDs.
        explode: false
        in: query
        items: null
        name: customer_groups
        schema: null
        style: form
        type: string
      - description: Filter by type.
        enum:
        - sale
        - override
        explode: false
        in: query
        items: null
        name: type
        schema: null
        style: form
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: deleted_at
        properties: null
        schema: null
        type: string
    post:
      operationId: PostPriceListsPriceList
      summary: Create a Price List
      description: Create a Price List.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          import { PriceListType } from "@medusajs/medusa"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.priceLists.create({
          name: "New Price List",
          description: "A new price list",
          type: PriceListType.SALE,
          prices: [
          {
          amount: 1000,
          variant_id,
          currency_code: "eur"
          }
          ]
          })
          .then(({ price_list }) => {
          console.log(price_list.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          PriceListStatus,
          PriceListType,
          } from "@medusajs/medusa"
          import { useAdminCreatePriceList } from "medusa-react"
          type CreateData = {
          name: string
          description: string
          type: PriceListType
          status: PriceListStatus
          prices: {
          amount: number
          variant_id: string
          currency_code: string
          max_quantity: number
          }[]
          }
          const CreatePriceList = () => {
          const createPriceList = useAdminCreatePriceList()
          // ...
          const handleCreate = (
          data: CreateData
          ) => {
          createPriceList.mutate(data, {
          onSuccess: ({ price_list }) => {
          console.log(price_list.id)
          }
          })
          }
          // ...
          }
          export default CreatePriceList
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/price-lists' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "New Price List",
          "description": "A new price list",
          "type": "sale",
          "prices": [
          {
          "amount": 1000,
          "variant_id": "afafa",
          "currency_code": "eur"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Price Lists
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPriceListRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostPriceListsPriceListReq'
  /admin/price-lists/{id}:
    delete:
      operationId: DeletePriceListsPriceList
      summary: Delete a Price List
      description: Delete a Price List and its associated prices.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.priceLists.delete(priceListId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeletePriceList } from "medusa-react"
          type Props = {
          priceListId: string
          }
          const PriceList = ({
          priceListId
          }: Props) => {
          const deletePriceList = useAdminDeletePriceList(priceListId)
          // ...
          const handleDelete = () => {
          deletePriceList.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default PriceList
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/price-lists/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Price Lists
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPriceListDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Price List.
    get:
      operationId: GetPriceListsPriceList
      summary: Get a Price List
      description: Retrieve a Price List's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.priceLists.retrieve(priceListId)
          .then(({ price_list }) => {
          console.log(price_list.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminPriceList } from "medusa-react"
          type Props = {
          priceListId: string
          }
          const PriceList = ({
          priceListId
          }: Props) => {
          const {
          price_list,
          isLoading,
          } = useAdminPriceList(priceListId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {price_list && <span>{price_list.name}</span>}
          </div>
          )
          }
          export default PriceList
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/price-lists/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Price Lists
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPriceListRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Price List.
    post:
      operationId: PostPriceListsPriceListPriceList
      summary: Update a Price List
      description: Update a Price List's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.priceLists.update(priceListId, {
          name: "New Price List"
          })
          .then(({ price_list }) => {
          console.log(price_list.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdatePriceList } from "medusa-react"
          type Props = {
          priceListId: string
          }
          const PriceList = ({
          priceListId
          }: Props) => {
          const updatePriceList = useAdminUpdatePriceList(priceListId)
          // ...
          const handleUpdate = (
          endsAt: Date
          ) => {
          updatePriceList.mutate({
          ends_at: endsAt,
          }, {
          onSuccess: ({ price_list }) => {
          console.log(price_list.ends_at)
          }
          })
          }
          // ...
          }
          export default PriceList
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/price-lists/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "New Price List"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Price Lists
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPriceListRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Price List.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostPriceListsPriceListPriceListReq'
  /admin/price-lists/{id}/prices/batch:
    delete:
      operationId: DeletePriceListsPriceListPricesBatch
      summary: Delete Prices
      description: Delete a list of prices in a Price List
      x-authenticated: true
      x-codegen:
        method: deletePrices
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.priceLists.deletePrices(priceListId, {
          price_ids: [
          price_id
          ]
          })
          .then(({ ids, object, deleted }) => {
          console.log(ids.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeletePriceListPrices } from "medusa-react"
          const PriceList = (
          priceListId: string
          ) => {
          const deletePrices = useAdminDeletePriceListPrices(priceListId)
          // ...
          const handleDeletePrices = (priceIds: string[]) => {
          deletePrices.mutate({
          price_ids: priceIds
          }, {
          onSuccess: ({ ids, deleted, object }) => {
          console.log(ids)
          }
          })
          }
          // ...
          }
          export default PriceList
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/price-lists/{id}/prices/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "price_ids": [
          "adasfa"
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Price Lists
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPriceListDeleteBatchRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Price List
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminDeletePriceListPricesPricesReq'
    post:
      operationId: PostPriceListsPriceListPricesBatch
      summary: Add or Update Prices
      description: Add or update a list of prices in a Price List.
      x-authenticated: true
      x-codegen:
        method: addPrices
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.priceLists.addPrices(priceListId, {
          prices: [
          {
          amount: 1000,
          variant_id,
          currency_code: "eur"
          }
          ]
          })
          .then(({ price_list }) => {
          console.log(price_list.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreatePriceListPrices } from "medusa-react"
          type PriceData = {
          amount: number
          variant_id: string
          currency_code: string
          }
          type Props = {
          priceListId: string
          }
          const PriceList = ({
          priceListId
          }: Props) => {
          const addPrices = useAdminCreatePriceListPrices(priceListId)
          // ...
          const handleAddPrices = (prices: PriceData[]) => {
          addPrices.mutate({
          prices
          }, {
          onSuccess: ({ price_list }) => {
          console.log(price_list.prices)
          }
          })
          }
          // ...
          }
          export default PriceList
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/price-lists/{id}/prices/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "prices": [
          {
          "amount": 100,
          "variant_id": "afasfa",
          "currency_code": "eur"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Price Lists
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPriceListRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Price List.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostPriceListPricesPricesReq'
  /admin/price-lists/{id}/products:
    get:
      operationId: GetPriceListsPriceListProducts
      summary: List Products
      description: Retrieve a price list's products. The products can be filtered
        by fields such as `q` or `status`. The products can also be sorted or paginated.
      x-authenticated: true
      x-codegen:
        method: listProducts
        queryParams: AdminGetPriceListsPriceListProductsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.priceLists.listProducts(priceListId)
          .then(({ products, limit, offset, count }) => {
          console.log(products.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminPriceListProducts } from "medusa-react"
          type Props = {
          priceListId: string
          }
          const PriceListProducts = ({
          priceListId
          }: Props) => {
          const { products, isLoading } = useAdminPriceListProducts(
          priceListId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {products && !products.length && (
          <span>No Price Lists</span>
          )}
          {products && products.length > 0 && (
          <ul>
          {products.map((product) => (
          <li key={product.id}>{product.title}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default PriceListProducts
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/price-lists/{id}/products' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Price Lists
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPriceListsProductsListRes'
          description: OK
      parameters:
      - (path) id=* {string} ID of the price list.
      - (query) q {string} term used to search products' title, description, product
        variant's title and sku, and product collection's title.
      - (query) id {string} Filter by product ID
      - description: Filter by product status
        enum:
        - draft
        - proposed
        - published
        - rejected
        explode: false
        in: query
        items: null
        name: status
        schema: null
        style: form
        type: string
      - description: Filter by product collection ID. Only products in the specified
          collections are retrieved.
        explode: false
        in: query
        items: null
        name: collection_id
        schema: null
        style: form
        type: string
      - description: Filter by tag IDs. Only products having the specified tags are
          retrieved.
        explode: false
        in: query
        items: null
        name: tags
        schema: null
        style: form
        type: string
      - (query) title {string} Filter by title
      - (query) description {string} Filter by description
      - (query) handle {string} Filter by handle
      - (query) is_giftcard {string} A boolean value to filter by whether the product
        is a gift card or not.
      - (query) type {string} Filter product type.
      - (query) order {string} A product field to sort-order the retrieved products
        by.
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: deleted_at
        properties: null
        schema: null
        type: string
      - (query) offset=0 {integer} The number of products to skip when retrieving
        the products.
      - (query) limit=50 {integer} Limit the number of products returned.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned products.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned products.
  /admin/price-lists/{id}/products/{product_id}/prices:
    delete:
      operationId: DeletePriceListsPriceListProductsProductPrices
      summary: Delete a Product's Prices
      description: Delete all the prices related to a specific product in a price
        list.
      x-authenticated: true
      x-codegen:
        method: deleteProductPrices
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.priceLists.deleteProductPrices(priceListId, productId)
          .then(({ ids, object, deleted }) => {
          console.log(ids.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminDeletePriceListProductPrices
          } from "medusa-react"
          type Props = {
          priceListId: string
          productId: string
          }
          const PriceListProduct = ({
          priceListId,
          productId
          }: Props) => {
          const deleteProductPrices = useAdminDeletePriceListProductPrices(
          priceListId,
          productId
          )
          // ...
          const handleDeleteProductPrices = () => {
          deleteProductPrices.mutate(void 0, {
          onSuccess: ({ ids, deleted, object }) => {
          console.log(ids)
          }
          })
          }
          // ...
          }
          export default PriceListProduct
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/price-lists/{id}/products/{product_id}/prices' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Price Lists
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPriceListDeleteProductPricesRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Price List.
      - (path) product_id=* {string} The ID of the product from which the prices will
        be deleted.
  /admin/price-lists/{id}/products/prices/batch:
    delete:
      operationId: DeletePriceListsPriceListProductsPricesBatch
      summary: Delete Product Prices
      description: Delete all the prices associated with multiple products in a price
        list.
      x-authenticated: true
      x-codegen:
        method: deleteProductsPrices
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.priceLists.deleteProductsPrices(priceListId, {
          product_ids: [
          productId1,
          productId2,
          ]
          })
          .then(({ ids, object, deleted }) => {
          console.log(ids.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeletePriceListProductsPrices } from "medusa-react"
          type Props = {
          priceListId: string
          }
          const PriceList = ({
          priceListId
          }: Props) => {
          const deleteProductsPrices = useAdminDeletePriceListProductsPrices(
          priceListId
          )
          // ...
          const handleDeleteProductsPrices = (productIds: string[]) => {
          deleteProductsPrices.mutate({
          product_ids: productIds
          }, {
          onSuccess: ({ ids, deleted, object }) => {
          console.log(ids)
          }
          })
          }
          // ...
          }
          export default PriceList
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/price-lists/{id}/products/prices/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "product_ids": [
          "prod_1",
          "prod_2"
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Price Lists
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPriceListDeleteProductPricesRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Price List
  /admin/price-lists/{id}/variants/{variant_id}/prices:
    delete:
      operationId: DeletePriceListsPriceListVariantsVariantPrices
      summary: Delete a Variant's Prices
      description: Delete all the prices related to a specific variant in a price
        list.
      x-authenticated: true
      x-codegen:
        method: deleteVariantPrices
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.priceLists.deleteVariantPrices(priceListId, variantId)
          .then(({ ids, object, deleted }) => {
          console.log(ids);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminDeletePriceListVariantPrices
          } from "medusa-react"
          type Props = {
          priceListId: string
          variantId: string
          }
          const PriceListVariant = ({
          priceListId,
          variantId
          }: Props) => {
          const deleteVariantPrices = useAdminDeletePriceListVariantPrices(
          priceListId,
          variantId
          )
          // ...
          const handleDeleteVariantPrices = () => {
          deleteVariantPrices.mutate(void 0, {
          onSuccess: ({ ids, deleted, object }) => {
          console.log(ids)
          }
          })
          }
          // ...
          }
          export default PriceListVariant
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/price-lists/{id}/variants/{variant_id}/prices' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Price Lists
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPriceListDeleteVariantPricesRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Price List.
      - (path) variant_id=* {string} The ID of the variant.
  /admin/product-categories:
    get:
      operationId: GetProductCategories
      summary: List Product Categories
      description: Retrieve a list of product categories. The product categories can
        be filtered by fields such as `q` or `handle`. The product categories can
        also be paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetProductCategoriesParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.productCategories.list()
          .then(({ product_categories, limit, offset, count }) => {
          console.log(product_categories.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminProductCategories } from "medusa-react"
          function Categories() {
          const {
          product_categories,
          isLoading
          } = useAdminProductCategories()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {product_categories && !product_categories.length && (
          <span>No Categories</span>
          )}
          {product_categories && product_categories.length > 0 && (
          <ul>
          {product_categories.map(
          (category) => (
          <li key={category.id}>{category.name}</li>
          )
          )}
          </ul>
          )}
          </div>
          )
          }
          export default Categories
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/product-categories' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Categories
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductCategoriesListRes'
          description: OK
      parameters:
      - (query) q {string} term to search product categories' names and handles.
      - (query) handle {string} Filter by handle.
      - (query) is_internal {boolean} Filter by whether the category is internal or
        not.
      - (query) is_active {boolean} Filter by whether the category is active or not.
      - (query) include_descendants_tree {boolean} If set to `true`, all nested descendants
        of a category are included in the response.
      - (query) parent_category_id {string} Filter by the ID of a parent category.
      - (query) offset=0 {integer} The number of product categories to skip when retrieving
        the product categories.
      - (query) limit=100 {integer} Limit the number of product categories returned.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned product categories.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned product categories.
    post:
      operationId: PostProductCategories
      summary: Create a Product Category
      description: Create a Product Category.
      x-authenticated: true
      x-codegen:
        method: create
        queryParams: AdminPostProductCategoriesParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.productCategories.create({
          name: "Skinny Jeans",
          })
          .then(({ product_category }) => {
          console.log(product_category.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateProductCategory } from "medusa-react"
          const CreateCategory = () => {
          const createCategory = useAdminCreateProductCategory()
          // ...
          const handleCreate = (
          name: string
          ) => {
          createCategory.mutate({
          name,
          }, {
          onSuccess: ({ product_category }) => {
          console.log(product_category.id)
          }
          })
          }
          // ...
          }
          export default CreateCategory
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/product-categories' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "Skinny Jeans"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Categories
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductCategoriesCategoryRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned product category.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned product category.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostProductCategoriesReq'
  /admin/product-categories/{id}:
    delete:
      operationId: DeleteProductCategoriesCategory
      summary: Delete a Product Category
      description: Delete a Product Category. This does not delete associated products.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.productCategories.delete(productCategoryId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteProductCategory } from "medusa-react"
          type Props = {
          productCategoryId: string
          }
          const Category = ({
          productCategoryId
          }: Props) => {
          const deleteCategory = useAdminDeleteProductCategory(
          productCategoryId
          )
          // ...
          const handleDelete = () => {
          deleteCategory.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default Category
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/product-categories/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Categories
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductCategoriesCategoryDeleteRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the Product Category
    get:
      operationId: GetProductCategoriesCategory
      summary: Get a Product Category
      description: Retrieve a Product Category's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
        queryParams: AdminGetProductCategoryParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.productCategories.retrieve(productCategoryId)
          .then(({ product_category }) => {
          console.log(product_category.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminProductCategory } from "medusa-react"
          type Props = {
          productCategoryId: string
          }
          const Category = ({
          productCategoryId
          }: Props) => {
          const {
          product_category,
          isLoading,
          } = useAdminProductCategory(productCategoryId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {product_category && (
          <span>{product_category.name}</span>
          )}
          </div>
          )
          }
          export default Category
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/product-categories/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Categories
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductCategoriesCategoryRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the Product Category
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned product category.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned product category.
    post:
      operationId: PostProductCategoriesCategory
      summary: Update a Product Category
      description: Updates a Product Category.
      x-authenticated: true
      x-codegen:
        method: update
        queryParams: AdminPostProductCategoriesCategoryParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.productCategories.update(productCategoryId, {
          name: "Skinny Jeans"
          })
          .then(({ product_category }) => {
          console.log(product_category.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateProductCategory } from "medusa-react"
          type Props = {
          productCategoryId: string
          }
          const Category = ({
          productCategoryId
          }: Props) => {
          const updateCategory = useAdminUpdateProductCategory(
          productCategoryId
          )
          // ...
          const handleUpdate = (
          name: string
          ) => {
          updateCategory.mutate({
          name,
          }, {
          onSuccess: ({ product_category }) => {
          console.log(product_category.id)
          }
          })
          }
          // ...
          }
          export default Category
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/product-categories/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "Skinny Jeans"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Categories
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductCategoriesCategoryRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the Product Category.
      - (query) expand {string} (Comma separated) Which fields should be expanded
        in each product category.
      - (query) fields {string} (Comma separated) Which fields should be retrieved
        in each product category.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostProductCategoriesCategoryReq'
  /admin/product-categories/{id}/products/batch:
    delete:
      operationId: DeleteProductCategoriesCategoryProductsBatch
      summary: Remove Products from Category
      description: Remove a list of products from a product category.
      x-authenticated: true
      x-codegen:
        method: removeProducts
        queryParams: AdminDeleteProductCategoriesCategoryProductsBatchParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.productCategories.removeProducts(productCategoryId, {
          product_ids: [
          {
          id: productId
          }
          ]
          })
          .then(({ product_category }) => {
          console.log(product_category.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteProductsFromCategory } from "medusa-react"
          type ProductsData = {
          id: string
          }
          type Props = {
          productCategoryId: string
          }
          const Category = ({
          productCategoryId
          }: Props) => {
          const deleteProducts = useAdminDeleteProductsFromCategory(
          productCategoryId
          )
          // ...
          const handleDeleteProducts = (
          productIds: ProductsData[]
          ) => {
          deleteProducts.mutate({
          product_ids: productIds
          }, {
          onSuccess: ({ product_category }) => {
          console.log(product_category.products)
          }
          })
          }
          // ...
          }
          export default Category
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/product-categories/{id}/products/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "product_ids": [
          {
          "id": "{product_id}"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Categories
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductCategoriesCategoryRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the Product Category.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned product category.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned product category.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminDeleteProductCategoriesCategoryProductsBatchReq'
    post:
      operationId: PostProductCategoriesCategoryProductsBatch
      summary: Add Products to a Category
      description: Add a list of products to a product category.
      x-authenticated: true
      x-codegen:
        method: addProducts
        queryParams: AdminPostProductCategoriesCategoryProductsBatchParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.productCategories.addProducts(productCategoryId, {
          product_ids: [
          {
          id: productId
          }
          ]
          })
          .then(({ product_category }) => {
          console.log(product_category.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminAddProductsToCategory } from "medusa-react"
          type ProductsData = {
          id: string
          }
          type Props = {
          productCategoryId: string
          }
          const Category = ({
          productCategoryId
          }: Props) => {
          const addProducts = useAdminAddProductsToCategory(
          productCategoryId
          )
          // ...
          const handleAddProducts = (
          productIds: ProductsData[]
          ) => {
          addProducts.mutate({
          product_ids: productIds
          }, {
          onSuccess: ({ product_category }) => {
          console.log(product_category.products)
          }
          })
          }
          // ...
          }
          export default Category
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/product-categories/{id}/products/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "product_ids": [
          {
          "id": "{product_id}"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Categories
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductCategoriesCategoryRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product Category.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned product category.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned product category.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostProductCategoriesCategoryProductsBatchReq'
  /admin/product-tags:
    get:
      operationId: GetProductTags
      summary: List Product Tags
      description: Retrieve a list of product tags. The product tags can be filtered
        by fields such as `q` or `value`. The product tags can also be sorted or paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetProductTagsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.productTags.list()
          .then(({ product_tags }) => {
          console.log(product_tags.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminProductTags } from "medusa-react"
          function ProductTags() {
          const {
          product_tags,
          isLoading
          } = useAdminProductTags()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {product_tags && !product_tags.length && (
          <span>No Product Tags</span>
          )}
          {product_tags && product_tags.length > 0 && (
          <ul>
          {product_tags.map(
          (tag) => (
          <li key={tag.id}>{tag.value}</li>
          )
          )}
          </ul>
          )}
          </div>
          )
          }
          export default ProductTags
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/product-tags' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Tags
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductTagsListRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (query) limit=10 {integer} Limit the number of product tags returned.
      - (query) offset=0 {integer} The number of product tags to skip when retrieving
        the product tags.
      - (query) order {string} A product tag field to sort-order the retrieved product
        tags by.
      - (query) discount_condition_id {string} Filter by the ID of a discount condition.
        Only product tags that this discount condition is applied to will be retrieved.
      - description: Filter by tag value.
        explode: false
        in: query
        items: null
        name: value
        schema: null
        style: form
        type: string
      - (query) q {string} term to search product tags' values.
      - description: Filter by tag IDs.
        explode: false
        in: query
        items: null
        name: id
        schema: null
        style: form
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
  /admin/product-types:
    get:
      operationId: GetProductTypes
      summary: List Product Types
      description: Retrieve a list of product types. The product types can be filtered
        by fields such as `q` or `value`. The product types can also be sorted or
        paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetProductTypesParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.productTypes.list()
          .then(({ product_types }) => {
          console.log(product_types.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminProductTypes } from "medusa-react"
          function ProductTypes() {
          const {
          product_types,
          isLoading
          } = useAdminProductTypes()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {product_types && !product_types.length && (
          <span>No Product Tags</span>
          )}
          {product_types && product_types.length > 0 && (
          <ul>
          {product_types.map(
          (type) => (
          <li key={type.id}>{type.value}</li>
          )
          )}
          </ul>
          )}
          </div>
          )
          }
          export default ProductTypes
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/product-types' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Types
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductTypesListRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (query) limit=20 {integer} Limit the number of product types returned.
      - (query) offset=0 {integer} The number of product types to skip when retrieving
        the product types.
      - (query) order {string} A product type field to sort-order the retrieved product
        types by.
      - (query) discount_condition_id {string} Filter by the ID of a discount condition.
        Only product types that this discount condition is applied to will be retrieved.
      - description: Filter by value.
        explode: false
        in: query
        items: null
        name: value
        schema: null
        style: form
        type: string
      - description: Filter by product type IDs.
        explode: false
        in: query
        items: null
        name: id
        schema: null
        style: form
        type: string
      - (query) q {string} term to search product types' values.
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
  /admin/products:
    get:
      operationId: GetProducts
      summary: List Products
      description: Retrieve a list of products. The products can be filtered by fields
        such as `q` or `status`. The products can also be sorted or paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetProductsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.list()
          .then(({ products, limit, offset, count }) => {
          console.log(products.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminProducts } from "medusa-react"
          const Products = () => {
          const { products, isLoading } = useAdminProducts()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {products && !products.length && <span>No Products</span>}
          {products && products.length > 0 && (
          <ul>
          {products.map((product) => (
          <li key={product.id}>{product.title}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Products
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/products' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsListRes'
          description: OK
      parameters:
      - (query) q {string} term to search products' title, description, variants'
        title and sku, and collections' title.
      - (query) discount_condition_id {string} Filter by the ID of a discount condition.
        Only products that this discount condition is applied to will be retrieved.
      - description: Filter by product IDs.
        explode: false
        in: query
        name: id
        oneOf: null
        schema: null
        style: form
      - description: ID of the product.
        type: string
      - description: ID of a product.
        items: null
        type: string
      - description: Filter by status.
        enum:
        - draft
        - proposed
        - published
        - rejected
        explode: false
        in: query
        items: null
        name: status
        schema: null
        style: form
        type: string
      - description: Filter by product collection IDs. Only products that are associated
          with the specified collections will be retrieved.
        explode: false
        in: query
        items: null
        name: collection_id
        schema: null
        style: form
        type: string
      - description: Filter by product tag IDs. Only products that are associated
          with the specified tags will be retrieved.
        explode: false
        in: query
        items: null
        name: tags
        schema: null
        style: form
        type: string
      - description: Filter by IDs of price lists. Only products that these price
          lists are applied to will be retrieved.
        explode: false
        in: query
        items: null
        name: price_list_id
        schema: null
        style: form
        type: string
      - description: Filter by sales channel IDs. Only products that are available
          in the specified sales channels will be retrieved.
        explode: false
        in: query
        items: null
        name: sales_channel_id
        schema: null
        style: form
        type: string
      - description: Filter by product type IDs. Only products that are associated
          with the specified types will be retrieved.
        explode: false
        in: query
        items: null
        name: type_id
        schema: null
        style: form
        type: string
      - description: Filter by product category IDs. Only products that are associated
          with the specified categories will be retrieved.
        explode: false
        in: query
        items: null
        name: category_id
        schema: null
        style: form
        type: string
        x-featureFlag: product_categories
      - description: whether to include product category children when filtering by
          `category_id`
        explode: false
        in: query
        name: include_category_children
        schema: null
        style: form
        type: boolean
        x-featureFlag: product_categories
      - (query) title {string} Filter by title.
      - (query) description {string} Filter by description.
      - (query) handle {string} Filter by handle.
      - (query) is_giftcard {boolean} Whether to retrieve gift cards or regular products.
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: deleted_at
        properties: null
        schema: null
        type: string
      - (query) offset=0 {integer} The number of products to skip when retrieving
        the products.
      - (query) limit=50 {integer} Limit the number of products returned.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned products.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned products.
      - (query) order {string} A product field to sort-order the retrieved products
        by.
    post:
      operationId: PostProducts
      summary: Create a Product
      description: Create a new Product. This API Route can also be used to create
        a gift card if the `is_giftcard` field is set to `true`.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.create({
          title: "Shirt",
          is_giftcard: false,
          discountable: true
          })
          .then(({ product }) => {
          console.log(product.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateProduct } from "medusa-react"
          type CreateProductData = {
          title: string
          is_giftcard: boolean
          discountable: boolean
          options: {
          title: string
          }[]
          variants: {
          title: string
          prices: {
          amount: number
          currency_code :string
          }[]
          options: {
          value: string
          }[]
          }[],
          collection_id: string
          categories: {
          id: string
          }[]
          type: {
          value: string
          }
          tags: {
          value: string
          }[]
          }
          const CreateProduct = () => {
          const createProduct = useAdminCreateProduct()
          // ...
          const handleCreate = (productData: CreateProductData) => {
          createProduct.mutate(productData, {
          onSuccess: ({ product }) => {
          console.log(product.id)
          }
          })
          }
          // ...
          }
          export default CreateProduct
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/products' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "title": "Shirt"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostProductsReq'
  /admin/products/{id}:
    delete:
      operationId: DeleteProductsProduct
      summary: Delete a Product
      description: Delete a Product and its associated product variants and options.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.delete(productId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteProduct } from "medusa-react"
          type Props = {
          productId: string
          }
          const Product = ({ productId }: Props) => {
          const deleteProduct = useAdminDeleteProduct(
          productId
          )
          // ...
          const handleDelete = () => {
          deleteProduct.mutate(void 0, {
          onSuccess: ({ id, object, deleted}) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default Product
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/products/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product.
    get:
      operationId: GetProductsProduct
      summary: Get a Product
      description: Retrieve a Product's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.retrieve(productId)
          .then(({ product }) => {
          console.log(product.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminProduct } from "medusa-react"
          type Props = {
          productId: string
          }
          const Product = ({ productId }: Props) => {
          const {
          product,
          isLoading,
          } = useAdminProduct(productId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {product && <span>{product.title}</span>}
          </div>
          )
          }
          export default Product
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/products/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product.
    post:
      operationId: PostProductsProduct
      summary: Update a Product
      description: Update a Product's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.update(productId, {
          title: "Shirt",
          })
          .then(({ product }) => {
          console.log(product.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateProduct } from "medusa-react"
          type Props = {
          productId: string
          }
          const Product = ({ productId }: Props) => {
          const updateProduct = useAdminUpdateProduct(
          productId
          )
          // ...
          const handleUpdate = (
          title: string
          ) => {
          updateProduct.mutate({
          title,
          }, {
          onSuccess: ({ product }) => {
          console.log(product.id)
          }
          })
          }
          // ...
          }
          export default Product
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/products/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "title": "Size"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostProductsProductReq'
  /admin/products/{id}/metadata:
    post:
      operationId: PostProductsProductMetadata
      summary: Set Metadata
      description: Set the metadata of a Product. It can be any key-value pair, which
        allows adding custom data to a product.
      x-authenticated: true
      x-codegen:
        method: setMetadata
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.setMetadata(productId, {
          key: "test",
          value: "true"
          })
          .then(({ product }) => {
          console.log(product.id);
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/products/{id}/metadata' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "key": "test",
          "value": "true"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostProductsProductMetadataReq'
      externalDocs:
        description: Learn about the metadata attribute, and how to delete and update
          it.
        url: https://docs.medusajs.com/development/entities/overview#metadata-attribute
  /admin/products/{id}/options:
    post:
      operationId: PostProductsProductOptions
      summary: Add a Product Option
      description: Add a Product Option to a Product.
      x-authenticated: true
      x-codegen:
        method: addOption
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.addOption(productId, {
          title: "Size"
          })
          .then(({ product }) => {
          console.log(product.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateProductOption } from "medusa-react"
          type Props = {
          productId: string
          }
          const CreateProductOption = ({ productId }: Props) => {
          const createOption = useAdminCreateProductOption(
          productId
          )
          // ...
          const handleCreate = (
          title: string
          ) => {
          createOption.mutate({
          title
          }, {
          onSuccess: ({ product }) => {
          console.log(product.options)
          }
          })
          }
          // ...
          }
          export default CreateProductOption
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/products/{id}/options' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "title": "Size"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostProductsProductOptionsReq'
  /admin/products/{id}/options/{option_id}:
    delete:
      operationId: DeleteProductsProductOptionsOption
      summary: Delete a Product Option
      description: Delete a Product Option. If there are product variants that use
        this product option, they must be deleted before deleting the product option.
      x-authenticated: true
      x-codegen:
        method: deleteOption
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.deleteOption(productId, optionId)
          .then(({ option_id, object, deleted, product }) => {
          console.log(product.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteProductOption } from "medusa-react"
          type Props = {
          productId: string
          optionId: string
          }
          const ProductOption = ({
          productId,
          optionId
          }: Props) => {
          const deleteOption = useAdminDeleteProductOption(
          productId
          )
          // ...
          const handleDelete = () => {
          deleteOption.mutate(optionId, {
          onSuccess: ({ option_id, object, deleted, product }) => {
          console.log(product.options)
          }
          })
          }
          // ...
          }
          export default ProductOption
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/products/{id}/options/{option_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsDeleteOptionRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product.
      - (path) option_id=* {string} The ID of the Product Option.
    post:
      operationId: PostProductsProductOptionsOption
      summary: Update a Product Option
      description: Update a Product Option's details.
      x-authenticated: true
      x-codegen:
        method: updateOption
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.updateOption(productId, optionId, {
          title: "Size"
          })
          .then(({ product }) => {
          console.log(product.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateProductOption } from "medusa-react"
          type Props = {
          productId: string
          optionId: string
          }
          const ProductOption = ({
          productId,
          optionId
          }: Props) => {
          const updateOption = useAdminUpdateProductOption(
          productId
          )
          // ...
          const handleUpdate = (
          title: string
          ) => {
          updateOption.mutate({
          option_id: optionId,
          title,
          }, {
          onSuccess: ({ product }) => {
          console.log(product.options)
          }
          })
          }
          // ...
          }
          export default ProductOption
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/products/{id}/options/{option_id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "title": "Size"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product.
      - (path) option_id=* {string} The ID of the Product Option.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostProductsProductOptionsOption'
  /admin/products/{id}/variants:
    get:
      operationId: GetProductsProductVariants
      summary: List a Product's Variants
      description: |
        Retrieve a list of Product Variants associated with a Product. The variants can be paginated.
        By default, each variant will only have the `id` and `variant_id` fields. You can use the `expand` and `fields` request parameters to retrieve more fields or relations.
      x-authenticated: true
      x-codegen:
        method: listVariants
        queryParams: AdminGetProductsVariantsParams
      x-codeSamples:
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/products/{id}/variants' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsListVariantsRes'
          description: OK
      parameters:
      - (path) id=* {string} ID of the product.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned product variants.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned product variants.
      - (query) offset=0 {integer} The number of product variants to skip when retrieving
        the product variants.
      - (query) limit=100 {integer} Limit the number of product variants returned.
    post:
      operationId: PostProductsProductVariants
      summary: Create a Product Variant
      description: Create a Product Variant associated with a Product. Each product
        variant must have a unique combination of Product Option values.
      x-authenticated: true
      x-codegen:
        method: createVariant
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.createVariant(productId, {
          title: "Color",
          prices: [
          {
          amount: 1000,
          currency_code: "eur"
          }
          ],
          options: [
          {
          option_id,
          value: "S"
          }
          ],
          inventory_quantity: 100
          })
          .then(({ product }) => {
          console.log(product.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateVariant } from "medusa-react"
          type CreateVariantData = {
          title: string
          prices: {
          amount: number
          currency_code: string
          }[]
          options: {
          option_id: string
          value: string
          }[]
          }
          type Props = {
          productId: string
          }
          const CreateProductVariant = ({ productId }: Props) => {
          const createVariant = useAdminCreateVariant(
          productId
          )
          // ...
          const handleCreate = (
          variantData: CreateVariantData
          ) => {
          createVariant.mutate(variantData, {
          onSuccess: ({ product }) => {
          console.log(product.variants)
          }
          })
          }
          // ...
          }
          export default CreateProductVariant
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/products/{id}/variants' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "title": "Color",
          "prices": [
          {
          "amount": 1000,
          "currency_code": "eur"
          }
          ],
          "options": [
          {
          "option_id": "asdasf",
          "value": "S"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostProductsProductVariantsReq'
  /admin/products/{id}/variants/{variant_id}:
    delete:
      operationId: DeleteProductsProductVariantsVariant
      summary: Delete a Product Variant
      description: Delete a Product Variant.
      x-authenticated: true
      x-codegen:
        method: deleteVariant
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.deleteVariant(productId, variantId)
          .then(({ variant_id, object, deleted, product }) => {
          console.log(product.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteVariant } from "medusa-react"
          type Props = {
          productId: string
          variantId: string
          }
          const ProductVariant = ({
          productId,
          variantId
          }: Props) => {
          const deleteVariant = useAdminDeleteVariant(
          productId
          )
          // ...
          const handleDelete = () => {
          deleteVariant.mutate(variantId, {
          onSuccess: ({ variant_id, object, deleted, product }) => {
          console.log(product.variants)
          }
          })
          }
          // ...
          }
          export default ProductVariant
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/products/{id}/variants/{variant_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsDeleteVariantRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product.
      - (path) variant_id=* {string} The ID of the Product Variant.
    post:
      operationId: PostProductsProductVariantsVariant
      summary: Update a Product Variant
      description: Update a Product Variant's details.
      x-authenticated: true
      x-codegen:
        method: updateVariant
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.updateVariant(productId, variantId, {
          title: "Color",
          prices: [
          {
          amount: 1000,
          currency_code: "eur"
          }
          ],
          options: [
          {
          option_id,
          value: "S"
          }
          ],
          inventory_quantity: 100
          })
          .then(({ product }) => {
          console.log(product.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateVariant } from "medusa-react"
          type Props = {
          productId: string
          variantId: string
          }
          const ProductVariant = ({
          productId,
          variantId
          }: Props) => {
          const updateVariant = useAdminUpdateVariant(
          productId
          )
          // ...
          const handleUpdate = (title: string) => {
          updateVariant.mutate({
          variant_id: variantId,
          title,
          }, {
          onSuccess: ({ product }) => {
          console.log(product.variants)
          }
          })
          }
          // ...
          }
          export default ProductVariant
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/products/{id}/variants/{variant_id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "title": "Color",
          "prices": [
          {
          "amount": 1000,
          "currency_code": "eur"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product.
      - (path) variant_id=* {string} The ID of the Product Variant.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostProductsProductVariantsVariantReq'
  /admin/products/tag-usage:
    get:
      operationId: GetProductsTagUsage
      summary: List Tags Usage Number
      description: Retrieve a list of Product Tags with how many times each is used
        in products.
      x-authenticated: true
      x-codegen:
        method: listTags
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.listTags()
          .then(({ tags }) => {
          console.log(tags.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminProductTagUsage } from "medusa-react"
          const ProductTags = (productId: string) => {
          const { tags, isLoading } = useAdminProductTagUsage()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {tags && !tags.length && <span>No Product Tags</span>}
          {tags && tags.length > 0 && (
          <ul>
          {tags.map((tag) => (
          <li key={tag.id}>{tag.value} - {tag.usage_count}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default ProductTags
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/products/tag-usage' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsListTagsRes'
          description: OK
  /admin/products/types:
    get:
      operationId: GetProductsTypes
      summary: List Product Types
      description: Retrieve a list of Product Types.
      x-authenticated: true
      x-codegen:
        method: listTypes
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.products.listTypes()
          .then(({ types }) => {
          console.log(types.length);
          })
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/products/types' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminProductsListTypesRes'
          description: OK
      deprecated: true
  /admin/publishable-api-keys:
    get:
      operationId: GetPublishableApiKeys
      summary: List Publishable API keys
      description: Retrieve a list of publishable API keys. The publishable API keys
        can be filtered by fields such as `q`. The publishable API keys can also be
        paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: GetPublishableApiKeysParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.publishableApiKeys.list()
          .then(({ publishable_api_keys, count, limit, offset }) => {
          console.log(publishable_api_keys)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { PublishableApiKey } from "@medusajs/medusa"
          import { useAdminPublishableApiKeys } from "medusa-react"
          const PublishableApiKeys = () => {
          const { publishable_api_keys, isLoading } =
          useAdminPublishableApiKeys()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {publishable_api_keys && !publishable_api_keys.length && (
          <span>No Publishable API Keys</span>
          )}
          {publishable_api_keys &&
          publishable_api_keys.length > 0 && (
          <ul>
          {publishable_api_keys.map(
          (publishableApiKey: PublishableApiKey) => (
          <li key={publishableApiKey.id}>
          {publishableApiKey.title}
          </li>
          )
          )}
          </ul>
          )}
          </div>
          )
          }
          export default PublishableApiKeys
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/publishable-api-keys' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Publishable Api Keys
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPublishableApiKeysListRes'
          description: OK
      parameters:
      - (query) q {string} term to search publishable API keys' titles.
      - (query) limit=20 {number} Limit the number of publishable API keys returned.
      - (query) offset=0 {number} The number of publishable API keys to skip when
        retrieving the publishable API keys.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned publishable API keys.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned publishable API keys.
    post:
      operationId: PostPublishableApiKeys
      summary: Create Publishable API Key
      description: Create a Publishable API Key.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.publishableApiKeys.create({
          title
          })
          .then(({ publishable_api_key }) => {
          console.log(publishable_api_key.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreatePublishableApiKey } from "medusa-react"
          const CreatePublishableApiKey = () => {
          const createKey = useAdminCreatePublishableApiKey()
          // ...
          const handleCreate = (title: string) => {
          createKey.mutate({
          title,
          }, {
          onSuccess: ({ publishable_api_key }) => {
          console.log(publishable_api_key.id)
          }
          })
          }
          // ...
          }
          export default CreatePublishableApiKey
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/publishable-api-keys' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "title": "Web API Key"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Publishable Api Keys
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPublishableApiKeysRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostPublishableApiKeysReq'
  /admin/publishable-api-keys/{id}:
    delete:
      operationId: DeletePublishableApiKeysPublishableApiKey
      summary: Delete Publishable API Key
      description: Delete a Publishable API Key. Associated resources, such as sales
        channels, are not deleted.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.publishableApiKeys.delete(publishableApiKeyId)
          .then(({ id, object, deleted }) => {
          console.log(id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeletePublishableApiKey } from "medusa-react"
          type Props = {
          publishableApiKeyId: string
          }
          const PublishableApiKey = ({
          publishableApiKeyId
          }: Props) => {
          const deleteKey = useAdminDeletePublishableApiKey(
          publishableApiKeyId
          )
          // ...
          const handleDelete = () => {
          deleteKey.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default PublishableApiKey
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/publishable-api-key/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Publishable Api Keys
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPublishableApiKeyDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Publishable API Key to delete.
    get:
      operationId: GetPublishableApiKeysPublishableApiKey
      summary: Get a Publishable API Key
      description: Retrieve a publishable API key's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.publishableApiKeys.retrieve(publishableApiKeyId)
          .then(({ publishable_api_key }) => {
          console.log(publishable_api_key.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeletePublishableApiKey } from "medusa-react"
          type Props = {
          publishableApiKeyId: string
          }
          const PublishableApiKey = ({
          publishableApiKeyId
          }: Props) => {
          const deleteKey = useAdminDeletePublishableApiKey(
          publishableApiKeyId
          )
          // ...
          const handleDelete = () => {
          deleteKey.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default PublishableApiKey
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/publishable-api-keys/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Publishable Api Keys
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPublishableApiKeysRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Publishable API Key.
    post:
      operationId: PostPublishableApiKysPublishableApiKey
      summary: Update Publishable API Key
      description: Update a Publishable API Key's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.publishableApiKeys.update(publishableApiKeyId, {
          title: "new title"
          })
          .then(({ publishable_api_key }) => {
          console.log(publishable_api_key.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdatePublishableApiKey } from "medusa-react"
          type Props = {
          publishableApiKeyId: string
          }
          const PublishableApiKey = ({
          publishableApiKeyId
          }: Props) => {
          const updateKey = useAdminUpdatePublishableApiKey(
          publishableApiKeyId
          )
          // ...
          const handleUpdate = (title: string) => {
          updateKey.mutate({
          title,
          }, {
          onSuccess: ({ publishable_api_key }) => {
          console.log(publishable_api_key.id)
          }
          })
          }
          // ...
          }
          export default PublishableApiKey
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/publishable-api-key/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "title": "new title"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Publishable Api Keys
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPublishableApiKeysRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Publishable API Key.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostPublishableApiKeysPublishableApiKeyReq'
  /admin/publishable-api-keys/{id}/revoke:
    post:
      operationId: PostPublishableApiKeysPublishableApiKeyRevoke
      summary: Revoke a Publishable API Key
      description: Revoke a Publishable API Key. Revoking the publishable API Key
        can't be undone, and the key can't be used in future requests.
      x-authenticated: true
      x-codegen:
        method: revoke
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.publishableApiKeys.revoke(publishableApiKeyId)
          .then(({ publishable_api_key }) => {
          console.log(publishable_api_key.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminRevokePublishableApiKey } from "medusa-react"
          type Props = {
          publishableApiKeyId: string
          }
          const PublishableApiKey = ({
          publishableApiKeyId
          }: Props) => {
          const revokeKey = useAdminRevokePublishableApiKey(
          publishableApiKeyId
          )
          // ...
          const handleRevoke = () => {
          revokeKey.mutate(void 0, {
          onSuccess: ({ publishable_api_key }) => {
          console.log(publishable_api_key.revoked_at)
          }
          })
          }
          // ...
          }
          export default PublishableApiKey
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/publishable-api-keys/{id}/revoke' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Publishable Api Keys
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPublishableApiKeysRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Publishable API Key.
  /admin/publishable-api-keys/{id}/sales-channels:
    get:
      operationId: GetPublishableApiKeySalesChannels
      summary: List Sales Channels
      description: List the sales channels associated with a publishable API key.
        The sales channels can be filtered by fields such as `q`.
      x-authenticated: true
      x-codegen:
        method: listSalesChannels
        queryParams: GetPublishableApiKeySalesChannelsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.publishableApiKeys.listSalesChannels()
          .then(({ sales_channels }) => {
          console.log(sales_channels.length)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminPublishableApiKeySalesChannels,
          } from "medusa-react"
          type Props = {
          publishableApiKeyId: string
          }
          const SalesChannels = ({
          publishableApiKeyId
          }: Props) => {
          const { sales_channels, isLoading } =
          useAdminPublishableApiKeySalesChannels(
          publishableApiKeyId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {sales_channels && !sales_channels.length && (
          <span>No Sales Channels</span>
          )}
          {sales_channels && sales_channels.length > 0 && (
          <ul>
          {sales_channels.map((salesChannel) => (
          <li key={salesChannel.id}>{salesChannel.name}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default SalesChannels
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/publishable-api-keys/{id}/sales-channels' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Publishable Api Keys
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPublishableApiKeysListSalesChannelsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the publishable API key.
      - (query) q {string} query to search sales channels' names and descriptions.
  /admin/publishable-api-keys/{id}/sales-channels/batch:
    delete:
      operationId: DeletePublishableApiKeySalesChannelsChannelsBatch
      summary: Remove Sales Channels
      description: Remove a list of sales channels from a publishable API key. This
        doesn't delete the sales channels and only removes the association between
        them and the publishable API key.
      x-authenticated: true
      x-codegen:
        method: deleteSalesChannelsBatch
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.publishableApiKeys.deleteSalesChannelsBatch(publishableApiKeyId, {
          sales_channel_ids: [
          {
          id: channelId
          }
          ]
          })
          .then(({ publishable_api_key }) => {
          console.log(publishable_api_key.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminRemovePublishableKeySalesChannelsBatch,
          } from "medusa-react"
          type Props = {
          publishableApiKeyId: string
          }
          const PublishableApiKey = ({
          publishableApiKeyId
          }: Props) => {
          const deleteSalesChannels =
          useAdminRemovePublishableKeySalesChannelsBatch(
          publishableApiKeyId
          )
          // ...
          const handleDelete = (salesChannelId: string) => {
          deleteSalesChannels.mutate({
          sales_channel_ids: [
          {
          id: salesChannelId,
          },
          ],
          }, {
          onSuccess: ({ publishable_api_key }) => {
          console.log(publishable_api_key.id)
          }
          })
          }
          // ...
          }
          export default PublishableApiKey
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/publishable-api-keys/{id}/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "sales_channel_ids": [
          {
          "id": "{sales_channel_id}"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Publishable Api Keys
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPublishableApiKeysRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Publishable API Key.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminDeletePublishableApiKeySalesChannelsBatchReq'
    post:
      operationId: PostPublishableApiKeySalesChannelsChannelsBatch
      summary: Add Sales Channels
      description: Add a list of sales channels to a publishable API key.
      x-authenticated: true
      x-codegen:
        method: addSalesChannelsBatch
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.publishableApiKeys.addSalesChannelsBatch(publishableApiKeyId, {
          sales_channel_ids: [
          {
          id: channelId
          }
          ]
          })
          .then(({ publishable_api_key }) => {
          console.log(publishable_api_key.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminAddPublishableKeySalesChannelsBatch,
          } from "medusa-react"
          type Props = {
          publishableApiKeyId: string
          }
          const PublishableApiKey = ({
          publishableApiKeyId
          }: Props) => {
          const addSalesChannels =
          useAdminAddPublishableKeySalesChannelsBatch(
          publishableApiKeyId
          )
          // ...
          const handleAdd = (salesChannelId: string) => {
          addSalesChannels.mutate({
          sales_channel_ids: [
          {
          id: salesChannelId,
          },
          ],
          }, {
          onSuccess: ({ publishable_api_key }) => {
          console.log(publishable_api_key.id)
          }
          })
          }
          // ...
          }
          export default PublishableApiKey
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/publishable-api-keys/{pak_id}/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "sales_channel_ids": [
          {
          "id": "{sales_channel_id}"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Publishable Api Keys
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPublishableApiKeysRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Publishable Api Key.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostPublishableApiKeySalesChannelsBatchReq'
  /admin/regions:
    get:
      operationId: GetRegions
      summary: List Regions
      description: Retrieve a list of Regions. The regions can be filtered by fields
        such as `created_at`. The regions can also be paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetRegionsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.regions.list()
          .then(({ regions, limit, offset, count }) => {
          console.log(regions.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminRegions } from "medusa-react"
          const Regions = () => {
          const { regions, isLoading } = useAdminRegions()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {regions && !regions.length && <span>No Regions</span>}
          {regions && regions.length > 0 && (
          <ul>
          {regions.map((region) => (
          <li key={region.id}>{region.name}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Regions
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/regions' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminRegionsListRes'
          description: OK
      parameters:
      - (query) q {string} Term used to search regions' name.
      - (query) order {string} A field to sort-order the retrieved regions by.
      - default: 50
        description: Limit the number of regions returned.
        in: query
        name: limit
        required: false
        schema: null
        type: integer
      - default: 0
        description: The number of regions to skip when retrieving the regions.
        in: query
        name: offset
        required: false
        schema: null
        type: integer
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        required: false
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        required: false
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: deleted_at
        properties: null
        required: false
        schema: null
        type: string
    post:
      operationId: PostRegions
      summary: Create a Region
      description: Create a Region.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.regions.create({
          name: "Europe",
          currency_code: "eur",
          tax_rate: 0,
          payment_providers: [
          "manual"
          ],
          fulfillment_providers: [
          "manual"
          ],
          countries: [
          "DK"
          ]
          })
          .then(({ region }) => {
          console.log(region.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateRegion } from "medusa-react"
          type CreateData = {
          name: string
          currency_code: string
          tax_rate: number
          payment_providers: string[]
          fulfillment_providers: string[]
          countries: string[]
          }
          const CreateRegion = () => {
          const createRegion = useAdminCreateRegion()
          // ...
          const handleCreate = (regionData: CreateData) => {
          createRegion.mutate(regionData, {
          onSuccess: ({ region }) => {
          console.log(region.id)
          }
          })
          }
          // ...
          }
          export default CreateRegion
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/regions' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "Europe",
          "currency_code": "eur",
          "tax_rate": 0,
          "payment_providers": [
          "manual"
          ],
          "fulfillment_providers": [
          "manual"
          ],
          "countries": [
          "DK"
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminRegionsRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostRegionsReq'
  /admin/regions/{id}:
    delete:
      operationId: DeleteRegionsRegion
      summary: Delete a Region
      description: Delete a Region. Associated resources, such as providers or currencies
        are not deleted. Associated tax rates are deleted.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.regions.delete(regionId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteRegion } from "medusa-react"
          type Props = {
          regionId: string
          }
          const Region = ({
          regionId
          }: Props) => {
          const deleteRegion = useAdminDeleteRegion(regionId)
          // ...
          const handleDelete = () => {
          deleteRegion.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default Region
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/regions/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminRegionsDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Region.
    get:
      operationId: GetRegionsRegion
      summary: Get a Region
      description: Retrieve a Region's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.regions.retrieve(regionId)
          .then(({ region }) => {
          console.log(region.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminRegion } from "medusa-react"
          type Props = {
          regionId: string
          }
          const Region = ({
          regionId
          }: Props) => {
          const { region, isLoading } = useAdminRegion(
          regionId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {region && <span>{region.name}</span>}
          </div>
          )
          }
          export default Region
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/regions/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminRegionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Region.
    post:
      operationId: PostRegionsRegion
      summary: Update a Region
      description: Update a Region's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.regions.update(regionId, {
          name: "Europe"
          })
          .then(({ region }) => {
          console.log(region.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateRegion } from "medusa-react"
          type Props = {
          regionId: string
          }
          const Region = ({
          regionId
          }: Props) => {
          const updateRegion = useAdminUpdateRegion(regionId)
          // ...
          const handleUpdate = (
          countries: string[]
          ) => {
          updateRegion.mutate({
          countries,
          }, {
          onSuccess: ({ region }) => {
          console.log(region.id)
          }
          })
          }
          // ...
          }
          export default Region
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/regions/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "Europe"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminRegionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Region.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostRegionsRegionReq'
  /admin/regions/{id}/countries:
    post:
      operationId: PostRegionsRegionCountries
      summary: Add Country
      description: Add a Country to the list of Countries in a Region.
      x-authenticated: true
      x-codegen:
        method: addCountry
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.regions.addCountry(regionId, {
          country_code: "dk"
          })
          .then(({ region }) => {
          console.log(region.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminRegionAddCountry } from "medusa-react"
          type Props = {
          regionId: string
          }
          const Region = ({
          regionId
          }: Props) => {
          const addCountry = useAdminRegionAddCountry(regionId)
          // ...
          const handleAddCountry = (
          countryCode: string
          ) => {
          addCountry.mutate({
          country_code: countryCode
          }, {
          onSuccess: ({ region }) => {
          console.log(region.countries)
          }
          })
          }
          // ...
          }
          export default Region
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/regions/{region_id}/countries' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "country_code": "dk"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminRegionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Region.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostRegionsRegionCountriesReq'
  /admin/regions/{id}/countries/{country_code}:
    delete:
      operationId: PostRegionsRegionCountriesCountry
      summary: Remove Country
      description: Remove a Country from the list of Countries in a Region. The country
        will still be available in the system, and it can be used in other regions.
      x-authenticated: true
      x-codegen:
        method: deleteCountry
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.regions.deleteCountry(regionId, "dk")
          .then(({ region }) => {
          console.log(region.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminRegionRemoveCountry } from "medusa-react"
          type Props = {
          regionId: string
          }
          const Region = ({
          regionId
          }: Props) => {
          const removeCountry = useAdminRegionRemoveCountry(regionId)
          // ...
          const handleRemoveCountry = (
          countryCode: string
          ) => {
          removeCountry.mutate(countryCode, {
          onSuccess: ({ region }) => {
          console.log(region.countries)
          }
          })
          }
          // ...
          }
          export default Region
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/regions/{id}/countries/{country_code}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminRegionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Region.
      - description: See a list of codes.
        externalDocs: null
        in: path
        name: country_code
        required: true
        schema: null
        type: string
        url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
  /admin/regions/{id}/fulfillment-options:
    get:
      operationId: GetRegionsRegionFulfillmentOptions
      summary: List Fulfillment Options
      description: Retrieve a list of fulfillment options available in a Region.
      x-authenticated: true
      x-codegen:
        method: retrieveFulfillmentOptions
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.regions.retrieveFulfillmentOptions(regionId)
          .then(({ fulfillment_options }) => {
          console.log(fulfillment_options.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminRegionFulfillmentOptions } from "medusa-react"
          type Props = {
          regionId: string
          }
          const Region = ({
          regionId
          }: Props) => {
          const {
          fulfillment_options,
          isLoading
          } = useAdminRegionFulfillmentOptions(
          regionId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {fulfillment_options && !fulfillment_options.length && (
          <span>No Regions</span>
          )}
          {fulfillment_options &&
          fulfillment_options.length > 0 && (
          <ul>
          {fulfillment_options.map((option) => (
          <li key={option.provider_id}>
          {option.provider_id}
          </li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Region
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/regions/{id}/fulfillment-options' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminGetRegionsRegionFulfillmentOptionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Region.
  /admin/regions/{id}/fulfillment-providers:
    post:
      operationId: PostRegionsRegionFulfillmentProviders
      summary: Add Fulfillment Provider
      description: Add a Fulfillment Provider to the list of fulfullment providers
        in a Region.
      x-authenticated: true
      x-codegen:
        method: addFulfillmentProvider
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.regions.addFulfillmentProvider(regionId, {
          provider_id: "manual"
          })
          .then(({ region }) => {
          console.log(region.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminRegionAddFulfillmentProvider
          } from "medusa-react"
          type Props = {
          regionId: string
          }
          const Region = ({
          regionId
          }: Props) => {
          const addFulfillmentProvider =
          useAdminRegionAddFulfillmentProvider(regionId)
          // ...
          const handleAddFulfillmentProvider = (
          providerId: string
          ) => {
          addFulfillmentProvider.mutate({
          provider_id: providerId
          }, {
          onSuccess: ({ region }) => {
          console.log(region.fulfillment_providers)
          }
          })
          }
          // ...
          }
          export default Region
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/regions/{id}/fulfillment-providers' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "provider_id": "manual"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminRegionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Region.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostRegionsRegionFulfillmentProvidersReq'
  /admin/regions/{id}/fulfillment-providers/{provider_id}:
    delete:
      operationId: PostRegionsRegionFulfillmentProvidersProvider
      summary: Remove Fulfillment Provider
      description: Remove a Fulfillment Provider from a Region. The fulfillment provider
        will still be available for usage in other regions.
      x-authenticated: true
      x-codegen:
        method: deleteFulfillmentProvider
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.regions.deleteFulfillmentProvider(regionId, "manual")
          .then(({ region }) => {
          console.log(region.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminRegionDeleteFulfillmentProvider
          } from "medusa-react"
          type Props = {
          regionId: string
          }
          const Region = ({
          regionId
          }: Props) => {
          const removeFulfillmentProvider =
          useAdminRegionDeleteFulfillmentProvider(regionId)
          // ...
          const handleRemoveFulfillmentProvider = (
          providerId: string
          ) => {
          removeFulfillmentProvider.mutate(providerId, {
          onSuccess: ({ region }) => {
          console.log(region.fulfillment_providers)
          }
          })
          }
          // ...
          }
          export default Region
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/regions/{id}/fulfillment-providers/{provider_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminRegionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Region.
      - (path) provider_id=* {string} The ID of the Fulfillment Provider.
  /admin/regions/{id}/payment-providers:
    post:
      operationId: PostRegionsRegionPaymentProviders
      summary: Add Payment Provider
      description: Add a Payment Provider to the list of payment providers in a Region.
      x-authenticated: true
      x-codegen:
        method: addPaymentProvider
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.regions.addPaymentProvider(regionId, {
          provider_id: "manual"
          })
          .then(({ region }) => {
          console.log(region.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminRegionAddPaymentProvider
          } from "medusa-react"
          type Props = {
          regionId: string
          }
          const Region = ({
          regionId
          }: Props) => {
          const addPaymentProvider =
          useAdminRegionAddPaymentProvider(regionId)
          // ...
          const handleAddPaymentProvider = (
          providerId: string
          ) => {
          addPaymentProvider.mutate({
          provider_id: providerId
          }, {
          onSuccess: ({ region }) => {
          console.log(region.payment_providers)
          }
          })
          }
          // ...
          }
          export default Region
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/regions/{id}/payment-providers' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "provider_id": "manual"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminRegionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Region.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostRegionsRegionPaymentProvidersReq'
  /admin/regions/{id}/payment-providers/{provider_id}:
    delete:
      operationId: PostRegionsRegionPaymentProvidersProvider
      summary: Remove Payment Provider
      description: Remove a Payment Provider from a Region. The payment provider will
        still be available for usage in other regions.
      x-authenticated: true
      x-codegen:
        method: deletePaymentProvider
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.regions.deletePaymentProvider(regionId, "manual")
          .then(({ region }) => {
          console.log(region.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminRegionDeletePaymentProvider
          } from "medusa-react"
          type Props = {
          regionId: string
          }
          const Region = ({
          regionId
          }: Props) => {
          const removePaymentProvider =
          useAdminRegionDeletePaymentProvider(regionId)
          // ...
          const handleRemovePaymentProvider = (
          providerId: string
          ) => {
          removePaymentProvider.mutate(providerId, {
          onSuccess: ({ region }) => {
          console.log(region.payment_providers)
          }
          })
          }
          // ...
          }
          export default Region
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/regions/{id}/payment-providers/{provider_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminRegionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Region.
      - (path) provider_id=* {string} The ID of the Payment Provider.
  /admin/return-reasons:
    get:
      operationId: GetReturnReasons
      summary: List Return Reasons
      description: Retrieve a list of Return Reasons.
      x-authenticated: true
      x-codegen:
        method: list
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.returnReasons.list()
          .then(({ return_reasons }) => {
          console.log(return_reasons.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminReturnReasons } from "medusa-react"
          const ReturnReasons = () => {
          const { return_reasons, isLoading } = useAdminReturnReasons()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {return_reasons && !return_reasons.length && (
          <span>No Return Reasons</span>
          )}
          {return_reasons && return_reasons.length > 0 && (
          <ul>
          {return_reasons.map((reason) => (
          <li key={reason.id}>
          {reason.label}: {reason.value}
          </li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default ReturnReasons
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/return-reasons' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Return Reasons
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminReturnReasonsListRes'
          description: OK
    post:
      operationId: PostReturnReasons
      summary: Create a Return Reason
      description: Create a Return Reason.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.returnReasons.create({
          label: "Damaged",
          value: "damaged"
          })
          .then(({ return_reason }) => {
          console.log(return_reason.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateReturnReason } from "medusa-react"
          const CreateReturnReason = () => {
          const createReturnReason = useAdminCreateReturnReason()
          // ...
          const handleCreate = (
          label: string,
          value: string
          ) => {
          createReturnReason.mutate({
          label,
          value,
          }, {
          onSuccess: ({ return_reason }) => {
          console.log(return_reason.id)
          }
          })
          }
          // ...
          }
          export default CreateReturnReason
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/return-reasons' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "label": "Damaged",
          "value": "damaged"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Return Reasons
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminReturnReasonsRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostReturnReasonsReq'
  /admin/return-reasons/{id}:
    delete:
      operationId: DeleteReturnReason
      summary: Delete a Return Reason
      description: Delete a return reason.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.returnReasons.delete(returnReasonId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteReturnReason } from "medusa-react"
          type Props = {
          returnReasonId: string
          }
          const ReturnReason = ({ returnReasonId }: Props) => {
          const deleteReturnReason = useAdminDeleteReturnReason(
          returnReasonId
          )
          // ...
          const handleDelete = () => {
          deleteReturnReason.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default ReturnReason
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/return-reasons/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Return Reasons
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminReturnReasonsDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the return reason
    get:
      operationId: GetReturnReasonsReason
      summary: Get a Return Reason
      description: Retrieve a Return Reason's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.returnReasons.retrieve(returnReasonId)
          .then(({ return_reason }) => {
          console.log(return_reason.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminReturnReason } from "medusa-react"
          type Props = {
          returnReasonId: string
          }
          const ReturnReason = ({ returnReasonId }: Props) => {
          const { return_reason, isLoading } = useAdminReturnReason(
          returnReasonId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {return_reason && <span>{return_reason.label}</span>}
          </div>
          )
          }
          export default ReturnReason
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/return-reasons/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Return Reasons
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminReturnReasonsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Return Reason.
    post:
      operationId: PostReturnReasonsReason
      summary: Update a Return Reason
      description: Update a Return Reason's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.returnReasons.update(returnReasonId, {
          label: "Damaged"
          })
          .then(({ return_reason }) => {
          console.log(return_reason.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateReturnReason } from "medusa-react"
          type Props = {
          returnReasonId: string
          }
          const ReturnReason = ({ returnReasonId }: Props) => {
          const updateReturnReason = useAdminUpdateReturnReason(
          returnReasonId
          )
          // ...
          const handleUpdate = (
          label: string
          ) => {
          updateReturnReason.mutate({
          label,
          }, {
          onSuccess: ({ return_reason }) => {
          console.log(return_reason.label)
          }
          })
          }
          // ...
          }
          export default ReturnReason
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/return-reasons/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "label": "Damaged"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Return Reasons
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminReturnReasonsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Return Reason.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostReturnReasonsReasonReq'
  /admin/returns:
    get:
      operationId: GetReturns
      summary: List Returns
      description: Retrieve a list of Returns. The returns can be paginated.
      x-codegen:
        method: list
        queryParams: AdminGetReturnsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.returns.list()
          .then(({ returns, limit, offset, count }) => {
          console.log(returns.length)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminReturns } from "medusa-react"
          const Returns = () => {
          const { returns, isLoading } = useAdminReturns()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {returns && !returns.length && (
          <span>No Returns</span>
          )}
          {returns && returns.length > 0 && (
          <ul>
          {returns.map((returnData) => (
          <li key={returnData.id}>
          {returnData.status}
          </li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Returns
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/returns' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Returns
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminReturnsListRes'
          description: OK
      parameters:
      - (query) limit=50 {number} Limit the number of Returns returned.
      - (query) offset=0 {number} The number of Returns to skip when retrieving the
        Returns.
  /admin/returns/{id}/cancel:
    post:
      operationId: PostReturnsReturnCancel
      summary: Cancel a Return
      description: Registers a Return as canceled. The return can be associated with
        an order, claim, or swap.
      x-codegen:
        method: cancel
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.returns.cancel(returnId)
          .then(({ order }) => {
          console.log(order.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCancelReturn } from "medusa-react"
          type Props = {
          returnId: string
          }
          const Return = ({ returnId }: Props) => {
          const cancelReturn = useAdminCancelReturn(
          returnId
          )
          // ...
          const handleCancel = () => {
          cancelReturn.mutate(void 0, {
          onSuccess: ({ order }) => {
          console.log(order.returns)
          }
          })
          }
          // ...
          }
          export default Return
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/returns/{id}/cancel' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Returns
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminReturnsCancelRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Return.
  /admin/returns/{id}/receive:
    post:
      operationId: PostReturnsReturnReceive
      summary: Receive a Return
      description: Mark a Return as received. This also updates the status of associated
        order, claim, or swap accordingly.
      x-codegen:
        method: receive
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.returns.receive(returnId, {
          items: [
          {
          item_id,
          quantity: 1
          }
          ]
          })
          .then((data) => {
          console.log(data.return.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminReceiveReturn } from "medusa-react"
          type ReceiveReturnData = {
          items: {
          item_id: string
          quantity: number
          }[]
          }
          type Props = {
          returnId: string
          }
          const Return = ({ returnId }: Props) => {
          const receiveReturn = useAdminReceiveReturn(
          returnId
          )
          // ...
          const handleReceive = (data: ReceiveReturnData) => {
          receiveReturn.mutate(data, {
          onSuccess: ({ return: dataReturn }) => {
          console.log(dataReturn.status)
          }
          })
          }
          // ...
          }
          export default Return
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/returns/{id}/receive' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "items": [
          {
          "item_id": "asafg",
          "quantity": 1
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Returns
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminReturnsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Return.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostReturnsReturnReceiveReq'
  /admin/sales-channels:
    get:
      operationId: GetSalesChannels
      summary: List Sales Channels
      description: Retrieve a list of sales channels. The sales channels can be filtered
        by fields such as `q` or `name`. The sales channels can also be sorted or
        paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetSalesChannelsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.salesChannels.list()
          .then(({ sales_channels, limit, offset, count }) => {
          console.log(sales_channels.length)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminSalesChannels } from "medusa-react"
          const SalesChannels = () => {
          const { sales_channels, isLoading } = useAdminSalesChannels()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {sales_channels && !sales_channels.length && (
          <span>No Sales Channels</span>
          )}
          {sales_channels && sales_channels.length > 0 && (
          <ul>
          {sales_channels.map((salesChannel) => (
          <li key={salesChannel.id}>{salesChannel.name}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default SalesChannels
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/sales-channels' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Sales Channels
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminSalesChannelsListRes'
          description: OK
      parameters:
      - (query) id {string} Filter by a sales channel ID.
      - (query) name {string} Filter by name.
      - (query) description {string} Filter by description.
      - (query) q {string} term used to search sales channels' names and descriptions.
      - (query) order {string} A sales-channel field to sort-order the retrieved sales
        channels by.
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: deleted_at
        properties: null
        schema: null
        type: string
      - (query) offset=0 {integer} The number of sales channels to skip when retrieving
        the sales channels.
      - (query) limit=20 {integer} Limit the number of sales channels returned.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned sales channels.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned sales channels.
    post:
      operationId: PostSalesChannels
      summary: Create a Sales Channel
      description: Create a Sales Channel.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.salesChannels.create({
          name: "App",
          description: "Mobile app"
          })
          .then(({ sales_channel }) => {
          console.log(sales_channel.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateSalesChannel } from "medusa-react"
          const CreateSalesChannel = () => {
          const createSalesChannel = useAdminCreateSalesChannel()
          // ...
          const handleCreate = (name: string, description: string) => {
          createSalesChannel.mutate({
          name,
          description,
          }, {
          onSuccess: ({ sales_channel }) => {
          console.log(sales_channel.id)
          }
          })
          }
          // ...
          }
          export default CreateSalesChannel
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/sales-channels' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "App"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Sales Channels
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminSalesChannelsRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostSalesChannelsReq'
  /admin/sales-channels/{id}:
    delete:
      operationId: DeleteSalesChannelsSalesChannel
      summary: Delete a Sales Channel
      description: Delete a sales channel. Associated products, stock locations, and
        other resources are not deleted.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.salesChannels.delete(salesChannelId)
          .then(({ id, object, deleted }) => {
          console.log(id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteSalesChannel } from "medusa-react"
          type Props = {
          salesChannelId: string
          }
          const SalesChannel = ({ salesChannelId }: Props) => {
          const deleteSalesChannel = useAdminDeleteSalesChannel(
          salesChannelId
          )
          // ...
          const handleDelete = () => {
          deleteSalesChannel.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default SalesChannel
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/sales-channels/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Sales Channels
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminSalesChannelsDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Sales channel.
    get:
      operationId: GetSalesChannelsSalesChannel
      summary: Get a Sales Channel
      description: Retrieve a sales channel's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.salesChannels.retrieve(salesChannelId)
          .then(({ sales_channel }) => {
          console.log(sales_channel.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminSalesChannel } from "medusa-react"
          type Props = {
          salesChannelId: string
          }
          const SalesChannel = ({ salesChannelId }: Props) => {
          const {
          sales_channel,
          isLoading,
          } = useAdminSalesChannel(salesChannelId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {sales_channel && <span>{sales_channel.name}</span>}
          </div>
          )
          }
          export default SalesChannel
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/sales-channels/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Sales Channels
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminSalesChannelsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Sales channel.
    post:
      operationId: PostSalesChannelsSalesChannel
      summary: Update a Sales Channel
      description: Update a Sales Channel's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.salesChannels.update(salesChannelId, {
          name: "App"
          })
          .then(({ sales_channel }) => {
          console.log(sales_channel.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateSalesChannel } from "medusa-react"
          type Props = {
          salesChannelId: string
          }
          const SalesChannel = ({ salesChannelId }: Props) => {
          const updateSalesChannel = useAdminUpdateSalesChannel(
          salesChannelId
          )
          // ...
          const handleUpdate = (
          is_disabled: boolean
          ) => {
          updateSalesChannel.mutate({
          is_disabled,
          }, {
          onSuccess: ({ sales_channel }) => {
          console.log(sales_channel.is_disabled)
          }
          })
          }
          // ...
          }
          export default SalesChannel
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/sales-channels/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "App"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Sales Channels
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminSalesChannelsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Sales Channel.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostSalesChannelsSalesChannelReq'
  /admin/sales-channels/{id}/products/batch:
    delete:
      operationId: DeleteSalesChannelsChannelProductsBatch
      summary: Remove Products from Sales Channel
      description: Remove a list of products from a sales channel. This does not delete
        the product. It only removes the association between the product and the sales
        channel.
      x-authenticated: true
      x-codegen:
        method: removeProducts
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.salesChannels.removeProducts(salesChannelId, {
          product_ids: [
          {
          id: productId
          }
          ]
          })
          .then(({ sales_channel }) => {
          console.log(sales_channel.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminDeleteProductsFromSalesChannel,
          } from "medusa-react"
          type Props = {
          salesChannelId: string
          }
          const SalesChannel = ({ salesChannelId }: Props) => {
          const deleteProducts = useAdminDeleteProductsFromSalesChannel(
          salesChannelId
          )
          // ...
          const handleDeleteProducts = (productId: string) => {
          deleteProducts.mutate({
          product_ids: [
          {
          id: productId,
          },
          ],
          }, {
          onSuccess: ({ sales_channel }) => {
          console.log(sales_channel.id)
          }
          })
          }
          // ...
          }
          export default SalesChannel
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/sales-channels/{id}/products/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "product_ids": [
          {
          "id": "{product_id}"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Sales Channels
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminSalesChannelsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Sales Channel
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminDeleteSalesChannelsChannelProductsBatchReq'
    post:
      operationId: PostSalesChannelsChannelProductsBatch
      summary: Add Products to Sales Channel
      description: Add a list of products to a sales channel.
      x-authenticated: true
      x-codegen:
        method: addProducts
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.salesChannels.addProducts(salesChannelId, {
          product_ids: [
          {
          id: productId
          }
          ]
          })
          .then(({ sales_channel }) => {
          console.log(sales_channel.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminAddProductsToSalesChannel } from "medusa-react"
          type Props = {
          salesChannelId: string
          }
          const SalesChannel = ({ salesChannelId }: Props) => {
          const addProducts = useAdminAddProductsToSalesChannel(
          salesChannelId
          )
          // ...
          const handleAddProducts = (productId: string) => {
          addProducts.mutate({
          product_ids: [
          {
          id: productId,
          },
          ],
          }, {
          onSuccess: ({ sales_channel }) => {
          console.log(sales_channel.id)
          }
          })
          }
          // ...
          }
          export default SalesChannel
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/sales-channels/{id}/products/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "product_ids": [
          {
          "id": "{product_id}"
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Sales Channels
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminSalesChannelsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Sales channel.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostSalesChannelsChannelProductsBatchReq'
  /admin/sales-channels/{id}/stock-locations:
    delete:
      operationId: DeleteSalesChannelsSalesChannelStockLocation
      summary: Remove Stock Location from Sales Channels.
      description: Remove a stock location from a Sales Channel. This only removes
        the association between the stock location and the sales channel. It does
        not delete the stock location.
      x-authenticated: true
      x-codegen:
        method: removeLocation
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.salesChannels.removeLocation(salesChannelId, {
          location_id: "loc_id"
          })
          .then(({ sales_channel }) => {
          console.log(sales_channel.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminRemoveLocationFromSalesChannel
          } from "medusa-react"
          type Props = {
          salesChannelId: string
          }
          const SalesChannel = ({ salesChannelId }: Props) => {
          const removeLocation = useAdminRemoveLocationFromSalesChannel()
          // ...
          const handleRemoveLocation = (locationId: string) => {
          removeLocation.mutate({
          sales_channel_id: salesChannelId,
          location_id: locationId
          }, {
          onSuccess: ({ sales_channel }) => {
          console.log(sales_channel.locations)
          }
          })
          }
          // ...
          }
          export default SalesChannel
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/sales-channels/{id}/stock-locations' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "locaton_id": "loc_id"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Sales Channels
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminSalesChannelsDeleteLocationRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Sales Channel.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminDeleteSalesChannelsChannelStockLocationsReq'
    post:
      operationId: PostSalesChannelsSalesChannelStockLocation
      summary: Associate a Stock Location
      description: Associate a stock location with a Sales Channel.
      x-authenticated: true
      x-codegen:
        method: addLocation
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.salesChannels.addLocation(salesChannelId, {
          location_id: "loc_123"
          })
          .then(({ sales_channel }) => {
          console.log(sales_channel.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminAddLocationToSalesChannel
          } from "medusa-react"
          type Props = {
          salesChannelId: string
          }
          const SalesChannel = ({ salesChannelId }: Props) => {
          const addLocation = useAdminAddLocationToSalesChannel()
          // ...
          const handleAddLocation = (locationId: string) => {
          addLocation.mutate({
          sales_channel_id: salesChannelId,
          location_id: locationId
          }, {
          onSuccess: ({ sales_channel }) => {
          console.log(sales_channel.locations)
          }
          })
          }
          // ...
          }
          export default SalesChannel
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/sales-channels/{id}/stock-locations' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "locaton_id": "loc_123"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Sales Channels
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminSalesChannelsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Sales Channel.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostSalesChannelsChannelStockLocationsReq'
  /admin/shipping-options:
    get:
      operationId: GetShippingOptions
      summary: List Shipping Options
      description: Retrieve a list of Shipping Options. The shipping options can be
        filtered by fields such as `region_id` or `is_return`. The shipping options
        can also be sorted or paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetShippingOptionsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.shippingOptions.list()
          .then(({ shipping_options, count }) => {
          console.log(shipping_options.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminShippingOptions } from "medusa-react"
          const ShippingOptions = () => {
          const {
          shipping_options,
          isLoading
          } = useAdminShippingOptions()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {shipping_options && !shipping_options.length && (
          <span>No Shipping Options</span>
          )}
          {shipping_options && shipping_options.length > 0 && (
          <ul>
          {shipping_options.map((option) => (
          <li key={option.id}>{option.name}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default ShippingOptions
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/shipping-options' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Shipping Options
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminShippingOptionsListRes'
          description: OK
      parameters:
      - (query) name {string} Filter by name.
      - (query) region_id {string} Filter by the ID of the region the shipping options
        belong to.
      - (query) is_return {boolean} Filter by whether the shipping options are return
        shipping options.
      - (query) admin_only {boolean} Filter by whether the shipping options are available
        for admin users only.
      - (query) q {string} Term used to search shipping options' name.
      - (query) order {string} A shipping option field to sort-order the retrieved
        shipping options by.
      - description: Filter by shipping option IDs.
        explode: false
        in: query
        name: id
        oneOf: null
        schema: null
        style: form
      - description: ID of the shipping option.
        type: string
      - description: ID of a shipping option.
        items: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: deleted_at
        properties: null
        schema: null
        type: string
      - (query) offset=0 {integer} The number of users to skip when retrieving the
        shipping options.
      - (query) limit=20 {integer} Limit the number of shipping options returned.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned shipping options.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned shipping options.
    post:
      operationId: PostShippingOptions
      summary: Create Shipping Option
      description: Create a Shipping Option.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.shippingOptions.create({
          name: "PostFake",
          region_id,
          provider_id,
          data: {
          },
          price_type: "flat_rate"
          })
          .then(({ shipping_option }) => {
          console.log(shipping_option.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateShippingOption } from "medusa-react"
          type CreateShippingOption = {
          name: string
          provider_id: string
          data: Record<string, unknown>
          price_type: string
          amount: number
          }
          type Props = {
          regionId: string
          }
          const Region = ({ regionId }: Props) => {
          const createShippingOption = useAdminCreateShippingOption()
          // ...
          const handleCreate = (
          data: CreateShippingOption
          ) => {
          createShippingOption.mutate({
          ...data,
          region_id: regionId
          }, {
          onSuccess: ({ shipping_option }) => {
          console.log(shipping_option.id)
          }
          })
          }
          // ...
          }
          export default Region
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/shipping-options' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "PostFake",
          "region_id": "afasf",
          "provider_id": "manual",
          "data": {},
          "price_type": "flat_rate"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Shipping Options
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminShippingOptionsRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostShippingOptionsReq'
  /admin/shipping-options/{id}:
    delete:
      operationId: DeleteShippingOptionsOption
      summary: Delete Shipping Option
      description: Delete a Shipping Option. Once deleted, it can't be used when creating
        orders or returns.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.shippingOptions.delete(optionId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteShippingOption } from "medusa-react"
          type Props = {
          shippingOptionId: string
          }
          const ShippingOption = ({ shippingOptionId }: Props) => {
          const deleteShippingOption = useAdminDeleteShippingOption(
          shippingOptionId
          )
          // ...
          const handleDelete = () => {
          deleteShippingOption.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default ShippingOption
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/shipping-options/{option_id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Shipping Options
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminShippingOptionsDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Shipping Option.
    get:
      operationId: GetShippingOptionsOption
      summary: Get a Shipping Option
      description: Retrieve a Shipping Option's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.shippingOptions.retrieve(optionId)
          .then(({ shipping_option }) => {
          console.log(shipping_option.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminShippingOption } from "medusa-react"
          type Props = {
          shippingOptionId: string
          }
          const ShippingOption = ({ shippingOptionId }: Props) => {
          const {
          shipping_option,
          isLoading
          } = useAdminShippingOption(
          shippingOptionId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {shipping_option && <span>{shipping_option.name}</span>}
          </div>
          )
          }
          export default ShippingOption
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/shipping-options/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Shipping Options
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminShippingOptionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Shipping Option.
    post:
      operationId: PostShippingOptionsOption
      summary: Update Shipping Option
      description: Update a Shipping Option's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.shippingOptions.update(optionId, {
          name: "PostFake",
          requirements: [
          {
          id,
          type: "max_subtotal",
          amount: 1000
          }
          ]
          })
          .then(({ shipping_option }) => {
          console.log(shipping_option.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateShippingOption } from "medusa-react"
          type Props = {
          shippingOptionId: string
          }
          const ShippingOption = ({ shippingOptionId }: Props) => {
          const updateShippingOption = useAdminUpdateShippingOption(
          shippingOptionId
          )
          // ...
          const handleUpdate = (
          name: string,
          requirements: {
          id: string,
          type: string,
          amount: number
          }[]
          ) => {
          updateShippingOption.mutate({
          name,
          requirements
          }, {
          onSuccess: ({ shipping_option }) => {
          console.log(shipping_option.requirements)
          }
          })
          }
          // ...
          }
          export default ShippingOption
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/shipping-options/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "requirements": [
          {
          "type": "max_subtotal",
          "amount": 1000
          }
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Shipping Options
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminShippingOptionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Shipping Option.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostShippingOptionsOptionReq'
  /admin/shipping-profiles:
    get:
      operationId: GetShippingProfiles
      summary: List Shipping Profiles
      description: Retrieve a list of Shipping Profiles.
      x-authenticated: true
      x-codegen:
        method: list
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.shippingProfiles.list()
          .then(({ shipping_profiles }) => {
          console.log(shipping_profiles.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminShippingProfiles } from "medusa-react"
          const ShippingProfiles = () => {
          const {
          shipping_profiles,
          isLoading
          } = useAdminShippingProfiles()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {shipping_profiles && !shipping_profiles.length && (
          <span>No Shipping Profiles</span>
          )}
          {shipping_profiles && shipping_profiles.length > 0 && (
          <ul>
          {shipping_profiles.map((profile) => (
          <li key={profile.id}>{profile.name}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default ShippingProfiles
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/shipping-profiles' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Shipping Profiles
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminShippingProfilesListRes'
          description: OK
    post:
      operationId: PostShippingProfiles
      summary: Create a Shipping Profile
      description: Create a Shipping Profile.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.shippingProfiles.create({
          name: "Large Products"
          })
          .then(({ shipping_profile }) => {
          console.log(shipping_profile.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { ShippingProfileType } from "@medusajs/medusa"
          import { useAdminCreateShippingProfile } from "medusa-react"
          const CreateShippingProfile = () => {
          const createShippingProfile = useAdminCreateShippingProfile()
          // ...
          const handleCreate = (
          name: string,
          type: ShippingProfileType
          ) => {
          createShippingProfile.mutate({
          name,
          type
          }, {
          onSuccess: ({ shipping_profile }) => {
          console.log(shipping_profile.id)
          }
          })
          }
          // ...
          }
          export default CreateShippingProfile
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/shipping-profiles' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "Large Products"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Shipping Profiles
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminShippingProfilesRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostShippingProfilesReq'
  /admin/shipping-profiles/{id}:
    delete:
      operationId: DeleteShippingProfilesProfile
      summary: Delete a Shipping Profile
      description: Delete a Shipping Profile. Associated shipping options are deleted
        as well.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.shippingProfiles.delete(profileId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteShippingProfile } from "medusa-react"
          type Props = {
          shippingProfileId: string
          }
          const ShippingProfile = ({ shippingProfileId }: Props) => {
          const deleteShippingProfile = useAdminDeleteShippingProfile(
          shippingProfileId
          )
          // ...
          const handleDelete = () => {
          deleteShippingProfile.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default ShippingProfile
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/shipping-profiles/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Shipping Profiles
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDeleteShippingProfileRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Shipping Profile.
    get:
      operationId: GetShippingProfilesProfile
      summary: Get a Shipping Profile
      description: Retrieve a Shipping Profile's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.shippingProfiles.retrieve(profileId)
          .then(({ shipping_profile }) => {
          console.log(shipping_profile.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminShippingProfile } from "medusa-react"
          type Props = {
          shippingProfileId: string
          }
          const ShippingProfile = ({ shippingProfileId }: Props) => {
          const {
          shipping_profile,
          isLoading
          } = useAdminShippingProfile(
          shippingProfileId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {shipping_profile && (
          <span>{shipping_profile.name}</span>
          )}
          </div>
          )
          }
          export default ShippingProfile
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/shipping-profiles/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Shipping Profiles
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminShippingProfilesRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Shipping Profile.
    post:
      operationId: PostShippingProfilesProfile
      summary: Update a Shipping Profile
      description: Update a Shipping Profile's details.
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.shippingProfiles.update(shippingProfileId, {
          name: 'Large Products'
          })
          .then(({ shipping_profile }) => {
          console.log(shipping_profile.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { ShippingProfileType } from "@medusajs/medusa"
          import { useAdminUpdateShippingProfile } from "medusa-react"
          type Props = {
          shippingProfileId: string
          }
          const ShippingProfile = ({ shippingProfileId }: Props) => {
          const updateShippingProfile = useAdminUpdateShippingProfile(
          shippingProfileId
          )
          // ...
          const handleUpdate = (
          name: string,
          type: ShippingProfileType
          ) => {
          updateShippingProfile.mutate({
          name,
          type
          }, {
          onSuccess: ({ shipping_profile }) => {
          console.log(shipping_profile.name)
          }
          })
          }
          // ...
          }
          export default ShippingProfile
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/shipping-profiles/{id} \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "Large Products"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Shipping Profiles
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminShippingProfilesRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Shipping Profile.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostShippingProfilesProfileReq'
  /admin/stock-locations:
    get:
      operationId: GetStockLocations
      summary: List Stock Locations
      description: Retrieve a list of stock locations. The stock locations can be
        filtered by fields such as `name` or `created_at`. The stock locations can
        also be sorted or paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetStockLocationsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.stockLocations.list()
          .then(({ stock_locations, limit, offset, count }) => {
          console.log(stock_locations.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminStockLocations } from "medusa-react"
          function StockLocations() {
          const {
          stock_locations,
          isLoading
          } = useAdminStockLocations()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {stock_locations && !stock_locations.length && (
          <span>No Locations</span>
          )}
          {stock_locations && stock_locations.length > 0 && (
          <ul>
          {stock_locations.map(
          (location) => (
          <li key={location.id}>{location.name}</li>
          )
          )}
          </ul>
          )}
          </div>
          )
          }
          export default StockLocations
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/stock-locations' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Stock Locations
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminStockLocationsListRes'
          description: OK
      parameters:
      - (query) id {string} Filter by ID.
      - (query) name {string} Filter by name.
      - (query) order {string} A stock-location field to sort-order the retrieved
        stock locations by.
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: deleted_at
        properties: null
        schema: null
        type: string
      - (query) offset=0 {integer} The number of stock locations to skip when retrieving
        the stock locations.
      - (query) limit=20 {integer} Limit the number of stock locations returned.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned stock locations.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned stock locations.
    post:
      operationId: PostStockLocations
      summary: Create a Stock Location
      description: Create a Stock Location.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.stockLocations.create({
          name: "Main Warehouse",
          })
          .then(({ stock_location }) => {
          console.log(stock_location.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateStockLocation } from "medusa-react"
          const CreateStockLocation = () => {
          const createStockLocation = useAdminCreateStockLocation()
          // ...
          const handleCreate = (name: string) => {
          createStockLocation.mutate({
          name,
          }, {
          onSuccess: ({ stock_location }) => {
          console.log(stock_location.id)
          }
          })
          }
          // ...
          }
          export default CreateStockLocation
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/stock-locations' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "App"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Stock Locations
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminStockLocationsRes'
          description: OK
      parameters:
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned stock location.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned stock location.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostStockLocationsReq'
  /admin/stock-locations/{id}:
    delete:
      operationId: DeleteStockLocationsStockLocation
      summary: Delete a Stock Location
      description: Delete a Stock Location.
      x-authenticated: true
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.stockLocations.delete(stockLocationId)
          .then(({ id, object, deleted }) => {
          console.log(id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteStockLocation } from "medusa-react"
          type Props = {
          stockLocationId: string
          }
          const StockLocation = ({ stockLocationId }: Props) => {
          const deleteLocation = useAdminDeleteStockLocation(
          stockLocationId
          )
          // ...
          const handleDelete = () => {
          deleteLocation.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          }
          export default StockLocation
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/stock-locations/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Stock Locations
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminStockLocationsDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Stock Location.
    get:
      operationId: GetStockLocationsStockLocation
      summary: Get a Stock Location
      description: Retrieve a Stock Location's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
        queryParams: AdminGetStockLocationsLocationParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.stockLocations.retrieve(stockLocationId)
          .then(({ stock_location }) => {
          console.log(stock_location.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminStockLocation } from "medusa-react"
          type Props = {
          stockLocationId: string
          }
          const StockLocation = ({ stockLocationId }: Props) => {
          const {
          stock_location,
          isLoading
          } = useAdminStockLocation(stockLocationId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {stock_location && (
          <span>{stock_location.name}</span>
          )}
          </div>
          )
          }
          export default StockLocation
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/stock-locations/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Stock Locations
      responses:
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminStockLocationsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Stock Location.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned stock location.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned stock location.
    post:
      operationId: PostStockLocationsStockLocation
      summary: Update a Stock Location
      description: Update a Stock Location's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.stockLocations.update(stockLocationId, {
          name: 'Main Warehouse'
          })
          .then(({ stock_location }) => {
          console.log(stock_location.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateStockLocation } from "medusa-react"
          type Props = {
          stockLocationId: string
          }
          const StockLocation = ({ stockLocationId }: Props) => {
          const updateLocation = useAdminUpdateStockLocation(
          stockLocationId
          )
          // ...
          const handleUpdate = (
          name: string
          ) => {
          updateLocation.mutate({
          name
          }, {
          onSuccess: ({ stock_location }) => {
          console.log(stock_location.name)
          }
          })
          }
          }
          export default StockLocation
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/stock-locations/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "Main Warehouse"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Stock Locations
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminStockLocationsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Stock Location.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned stock location.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned stock location.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostStockLocationsLocationReq'
  /admin/store:
    get:
      operationId: GetStore
      summary: Get Store details
      description: Retrieve the Store's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.store.retrieve()
          .then(({ store }) => {
          console.log(store.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminStore } from "medusa-react"
          const Store = () => {
          const {
          store,
          isLoading
          } = useAdminStore()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {store && <span>{store.name}</span>}
          </div>
          )
          }
          export default Store
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/store' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Store
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminExtendedStoresRes'
          description: OK
    post:
      operationId: PostStore
      summary: Update Store Details
      description: Update the Store's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.store.update({
          name: "Medusa Store"
          })
          .then(({ store }) => {
          console.log(store.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateStore } from "medusa-react"
          function Store() {
          const updateStore = useAdminUpdateStore()
          // ...
          const handleUpdate = (
          name: string
          ) => {
          updateStore.mutate({
          name
          }, {
          onSuccess: ({ store }) => {
          console.log(store.name)
          }
          })
          }
          }
          export default Store
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/store' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "Medusa Store"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Store
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminStoresRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostStoreReq'
  /admin/store/currencies/{code}:
    delete:
      operationId: DeleteStoreCurrenciesCode
      summary: Remove a Currency
      description: Remove a Currency Code from the available currencies in a store.
        This does not completely delete the currency and it can be added again later
        to the store.
      x-authenticated: true
      x-codegen:
        method: deleteCurrency
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.store.deleteCurrency("eur")
          .then(({ store }) => {
          console.log(store.currencies);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteStoreCurrency } from "medusa-react"
          const Store = () => {
          const deleteCurrency = useAdminDeleteStoreCurrency()
          // ...
          const handleAdd = (code: string) => {
          deleteCurrency.mutate(code, {
          onSuccess: ({ store }) => {
          console.log(store.currencies)
          }
          })
          }
          // ...
          }
          export default Store
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/store/currencies/{currency_code}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Store
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminStoresRes'
          description: OK
      parameters:
      - description: See a list of codes.
        externalDocs: null
        in: path
        name: code
        required: true
        schema: null
        type: string
        url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
    post:
      operationId: PostStoreCurrenciesCode
      summary: Add a Currency Code
      description: Add a Currency Code to the available currencies in a store. This
        does not create new currencies, as currencies are defined within the Medusa
        backend. To create a currency, you can create a migration that inserts the
        currency into the database.
      x-authenticated: true
      x-codegen:
        method: addCurrency
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.store.addCurrency("eur")
          .then(({ store }) => {
          console.log(store.currencies);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminAddStoreCurrency } from "medusa-react"
          const Store = () => {
          const addCurrency = useAdminAddStoreCurrency()
          // ...
          const handleAdd = (code: string) => {
          addCurrency.mutate(code, {
          onSuccess: ({ store }) => {
          console.log(store.currencies)
          }
          })
          }
          // ...
          }
          export default Store
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/store/currencies/{currency_code}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Store
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminStoresRes'
          description: OK
      parameters:
      - description: See a list of codes.
        externalDocs: null
        in: path
        name: code
        required: true
        schema: null
        type: string
        url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
  /admin/store/payment-providers:
    get:
      operationId: GetStorePaymentProviders
      summary: List Payment Providers
      description: Retrieve a list of available Payment Providers in a store.
      x-authenticated: true
      x-codegen:
        method: listPaymentProviders
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.store.listPaymentProviders()
          .then(({ payment_providers }) => {
          console.log(payment_providers.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminStorePaymentProviders } from "medusa-react"
          const PaymentProviders = () => {
          const {
          payment_providers,
          isLoading
          } = useAdminStorePaymentProviders()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {payment_providers && !payment_providers.length && (
          <span>No Payment Providers</span>
          )}
          {payment_providers &&
          payment_providers.length > 0 &&(
          <ul>
          {payment_providers.map((provider) => (
          <li key={provider.id}>{provider.id}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default PaymentProviders
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/store/payment-providers' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Store
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminPaymentProvidersList'
          description: OK
  /admin/store/tax-providers:
    get:
      operationId: GetStoreTaxProviders
      summary: List Tax Providers
      description: Retrieve a list of available Tax Providers in a store.
      x-authenticated: true
      x-codegen:
        method: listTaxProviders
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.store.listTaxProviders()
          .then(({ tax_providers }) => {
          console.log(tax_providers.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminStoreTaxProviders } from "medusa-react"
          const TaxProviders = () => {
          const {
          tax_providers,
          isLoading
          } = useAdminStoreTaxProviders()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {tax_providers && !tax_providers.length && (
          <span>No Tax Providers</span>
          )}
          {tax_providers &&
          tax_providers.length > 0 &&(
          <ul>
          {tax_providers.map((provider) => (
          <li key={provider.id}>{provider.id}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default TaxProviders
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/store/tax-providers' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Store
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminTaxProvidersList'
          description: OK
  /admin/swaps:
    get:
      operationId: GetSwaps
      summary: List Swaps
      description: Retrieve a list of Swaps. The swaps can be paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetSwapsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.swaps.list()
          .then(({ swaps }) => {
          console.log(swaps.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminSwaps } from "medusa-react"
          const Swaps = () => {
          const { swaps, isLoading } = useAdminSwaps()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {swaps && !swaps.length && <span>No Swaps</span>}
          {swaps && swaps.length > 0 && (
          <ul>
          {swaps.map((swap) => (
          <li key={swap.id}>{swap.payment_status}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Swaps
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/swaps' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Swaps
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminSwapsListRes'
          description: OK
      parameters:
      - (query) limit=50 {number} Limit the number of swaps returned.
      - (query) offset=0 {number} The number of swaps to skip when retrieving the
        swaps.
  /admin/swaps/{id}:
    get:
      operationId: GetSwapsSwap
      summary: Get a Swap
      description: Retrieve a Swap's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.swaps.retrieve(swapId)
          .then(({ swap }) => {
          console.log(swap.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminSwap } from "medusa-react"
          type Props = {
          swapId: string
          }
          const Swap = ({ swapId }: Props) => {
          const { swap, isLoading } = useAdminSwap(swapId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {swap && <span>{swap.id}</span>}
          </div>
          )
          }
          export default Swap
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/swaps/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Swaps
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminSwapsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Swap.
  /admin/tax-rates:
    get:
      operationId: GetTaxRates
      summary: List Tax Rates
      description: Retrieve a list of Tax Rates. The tax rates can be filtered by
        fields such as `name` or `rate`. The tax rates can also be paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetTaxRatesParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.taxRates.list()
          .then(({ tax_rates, limit, offset, count }) => {
          console.log(tax_rates.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminTaxRates } from "medusa-react"
          const TaxRates = () => {
          const {
          tax_rates,
          isLoading
          } = useAdminTaxRates()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {tax_rates && !tax_rates.length && (
          <span>No Tax Rates</span>
          )}
          {x_rates && tax_rates.length > 0 && (
          <ul>
          {tax_rates.map((tax_rate) => (
          <li key={tax_rate.id}>{tax_rate.code}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default TaxRates
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/tax-rates' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Tax Rates
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminTaxRatesListRes'
          description: OK
      parameters:
      - (query) name {string} Filter by name.
      - description: Filter by Region IDs
        explode: false
        in: query
        name: region_id
        oneOf: null
        schema: null
        style: form
      - type: string
      - items: null
        type: string
      - (query) code {string} Filter by code.
      - description: Filter by Rate
        explode: false
        in: query
        name: rate
        oneOf: null
        schema: null
        style: form
      - type: number
      - description: filter by rates greater than or equal to this number
        gt: null
        gte: null
        lt: null
        lte: null
        properties: null
        type: number
      - (query) offset=0 {integer} The number of tax rates to skip when retrieving
        the tax rates.
      - (query) limit=50 {integer} Limit the number of tax rates returned.
      - description: Comma-separated fields that should be included in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: fields
        schema: null
        style: form
        type: string
      - description: Comma-separated relations that should be expanded in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: expand
        schema: null
        style: form
        type: string
    post:
      operationId: PostTaxRates
      summary: Create a Tax Rate
      description: Create a Tax Rate.
      x-authenticated: true
      x-codegen:
        method: create
        queryParams: AdminPostTaxRatesParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.taxRates.create({
          code: "TEST",
          name: "New Tax Rate",
          region_id
          })
          .then(({ tax_rate }) => {
          console.log(tax_rate.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateTaxRate } from "medusa-react"
          type Props = {
          regionId: string
          }
          const CreateTaxRate = ({ regionId }: Props) => {
          const createTaxRate = useAdminCreateTaxRate()
          // ...
          const handleCreate = (
          code: string,
          name: string,
          rate: number
          ) => {
          createTaxRate.mutate({
          code,
          name,
          region_id: regionId,
          rate,
          }, {
          onSuccess: ({ tax_rate }) => {
          console.log(tax_rate.id)
          }
          })
          }
          // ...
          }
          export default CreateTaxRate
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/tax-rates' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "code": "TEST",
          "name": "New Tax Rate",
          "region_id": "{region_id}"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Tax Rates
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminTaxRatesRes'
          description: OK
      parameters:
      - description: Comma-separated fields that should be included in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: fields
        schema: null
        style: form
        type: string
      - description: Comma-separated relations that should be expanded in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: expand
        schema: null
        style: form
        type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostTaxRatesReq'
  /admin/tax-rates/{id}:
    delete:
      operationId: DeleteTaxRatesTaxRate
      summary: Delete a Tax Rate
      description: Delete a Tax Rate. Resources associated with the tax rate, such
        as products or product types, are not deleted.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.taxRates.delete(taxRateId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteTaxRate } from "medusa-react"
          type Props = {
          taxRateId: string
          }
          const TaxRate = ({ taxRateId }: Props) => {
          const deleteTaxRate = useAdminDeleteTaxRate(taxRateId)
          // ...
          const handleDelete = () => {
          deleteTaxRate.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default TaxRate
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/tax-rates/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Tax Rates
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminTaxRatesDeleteRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Shipping Option.
    get:
      operationId: GetTaxRatesTaxRate
      summary: Get a Tax Rate
      description: Retrieve a Tax Rate's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
        queryParams: AdminGetTaxRatesTaxRateParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.taxRates.retrieve(taxRateId)
          .then(({ tax_rate }) => {
          console.log(tax_rate.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminTaxRate } from "medusa-react"
          type Props = {
          taxRateId: string
          }
          const TaxRate = ({ taxRateId }: Props) => {
          const { tax_rate, isLoading } = useAdminTaxRate(taxRateId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {tax_rate && <span>{tax_rate.code}</span>}
          </div>
          )
          }
          export default TaxRate
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/tax-rates/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Tax Rates
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminTaxRatesRes'
          description: OK
      parameters:
      - (path) id=* {string} ID of the tax rate.
      - description: Comma-separated fields that should be included in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: fields
        schema: null
        style: form
        type: string
      - description: Comma-separated relations that should be expanded in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: expand
        schema: null
        style: form
        type: string
    post:
      operationId: PostTaxRatesTaxRate
      summary: Update a Tax Rate
      description: Update a Tax Rate's details.
      x-authenticated: true
      x-codegen:
        method: update
        queryParams: AdminPostTaxRatesTaxRateParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.taxRates.update(taxRateId, {
          name: "New Tax Rate"
          })
          .then(({ tax_rate }) => {
          console.log(tax_rate.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateTaxRate } from "medusa-react"
          type Props = {
          taxRateId: string
          }
          const TaxRate = ({ taxRateId }: Props) => {
          const updateTaxRate = useAdminUpdateTaxRate(taxRateId)
          // ...
          const handleUpdate = (
          name: string
          ) => {
          updateTaxRate.mutate({
          name
          }, {
          onSuccess: ({ tax_rate }) => {
          console.log(tax_rate.name)
          }
          })
          }
          // ...
          }
          export default TaxRate
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/tax-rates/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "name": "New Tax Rate"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Tax Rates
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminTaxRatesRes'
          description: OK
      parameters:
      - (path) id=* {string} ID of the tax rate.
      - description: Comma-separated fields that should be included in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: fields
        schema: null
        style: form
        type: string
      - description: Comma-separated relations that should be expanded in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: expand
        schema: null
        style: form
        type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostTaxRatesTaxRateReq'
  /admin/tax-rates/{id}/product-types/batch:
    delete:
      operationId: DeleteTaxRatesTaxRateProductTypes
      summary: Remove Product Types from Rate
      description: Remove product types from a tax rate. This only removes the association
        between the product types and the tax rate. It does not delete the product
        types.
      x-authenticated: true
      x-codegen:
        method: removeProductTypes
        queryParams: AdminDeleteTaxRatesTaxRateProductTypesParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.taxRates.removeProductTypes(taxRateId, {
          product_types: [
          productTypeId
          ]
          })
          .then(({ tax_rate }) => {
          console.log(tax_rate.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminDeleteProductTypeTaxRates,
          } from "medusa-react"
          type Props = {
          taxRateId: string
          }
          const TaxRate = ({ taxRateId }: Props) => {
          const removeProductTypes = useAdminDeleteProductTypeTaxRates(
          taxRateId
          )
          // ...
          const handleRemoveProductTypes = (
          productTypeIds: string[]
          ) => {
          removeProductTypes.mutate({
          product_types: productTypeIds,
          }, {
          onSuccess: ({ tax_rate }) => {
          console.log(tax_rate.product_types)
          }
          })
          }
          // ...
          }
          export default TaxRate
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/tax-rates/{id}/product-types/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "product_types": [
          {product_type_id}"
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Tax Rates
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminTaxRatesRes'
          description: OK
      parameters:
      - (path) id=* {string} ID of the tax rate.
      - description: Comma-separated fields that should be included in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: fields
        schema: null
        style: form
        type: string
      - description: Comma-separated relations that should be expanded in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: expand
        schema: null
        style: form
        type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminDeleteTaxRatesTaxRateProductTypesReq'
    post:
      operationId: PostTaxRatesTaxRateProductTypes
      summary: Add to Product Types
      description: Add Product Types to a Tax Rate.
      x-authenticated: true
      x-codegen:
        method: addProductTypes
        queryParams: AdminPostTaxRatesTaxRateProductTypesParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.taxRates.addProductTypes(taxRateId, {
          product_types: [
          productTypeId
          ]
          })
          .then(({ tax_rate }) => {
          console.log(tax_rate.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import {
          useAdminCreateProductTypeTaxRates,
          } from "medusa-react"
          type Props = {
          taxRateId: string
          }
          const TaxRate = ({ taxRateId }: Props) => {
          const addProductTypes = useAdminCreateProductTypeTaxRates(
          taxRateId
          )
          // ...
          const handleAddProductTypes = (productTypeIds: string[]) => {
          addProductTypes.mutate({
          product_types: productTypeIds,
          }, {
          onSuccess: ({ tax_rate }) => {
          console.log(tax_rate.product_types)
          }
          })
          }
          // ...
          }
          export default TaxRate
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/tax-rates/{id}/product-types/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "product_types": [
          {product_type_id}"
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Tax Rates
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminTaxRatesRes'
          description: OK
      parameters:
      - (path) id=* {string} ID of the tax rate.
      - description: Comma-separated fields that should be included in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: fields
        schema: null
        style: form
        type: string
      - description: Comma-separated relations that should be expanded in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: expand
        schema: null
        style: form
        type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostTaxRatesTaxRateProductTypesReq'
  /admin/tax-rates/{id}/products/batch:
    delete:
      operationId: DeleteTaxRatesTaxRateProducts
      summary: Remove Products from Rate
      description: Remove products from a tax rate. This only removes the association
        between the products and the tax rate. It does not delete the products.
      x-authenticated: true
      x-codegen:
        method: removeProducts
        queryParams: AdminDeleteTaxRatesTaxRateProductsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.taxRates.removeProducts(taxRateId, {
          products: [
          productId
          ]
          })
          .then(({ tax_rate }) => {
          console.log(tax_rate.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteProductTaxRates } from "medusa-react"
          type Props = {
          taxRateId: string
          }
          const TaxRate = ({ taxRateId }: Props) => {
          const removeProduct = useAdminDeleteProductTaxRates(taxRateId)
          // ...
          const handleRemoveProduct = (productIds: string[]) => {
          removeProduct.mutate({
          products: productIds,
          }, {
          onSuccess: ({ tax_rate }) => {
          console.log(tax_rate.products)
          }
          })
          }
          // ...
          }
          export default TaxRate
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/tax-rates/{id}/products/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "products": [
          {product_id}"
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Tax Rates
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminTaxRatesRes'
          description: OK
      parameters:
      - (path) id=* {string} ID of the tax rate.
      - description: Comma-separated fields that should be included in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: fields
        schema: null
        style: form
        type: string
      - description: Comma-separated relations that should be expanded in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: expand
        schema: null
        style: form
        type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminDeleteTaxRatesTaxRateProductsReq'
    post:
      operationId: PostTaxRatesTaxRateProducts
      summary: Add to Products
      description: Add products to a tax rate.
      x-authenticated: true
      x-codegen:
        method: addProducts
        queryParams: AdminPostTaxRatesTaxRateProductsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.taxRates.addProducts(taxRateId, {
          products: [
          productId
          ]
          })
          .then(({ tax_rate }) => {
          console.log(tax_rate.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateProductTaxRates } from "medusa-react"
          type Props = {
          taxRateId: string
          }
          const TaxRate = ({ taxRateId }: Props) => {
          const addProduct = useAdminCreateProductTaxRates(taxRateId)
          // ...
          const handleAddProduct = (productIds: string[]) => {
          addProduct.mutate({
          products: productIds,
          }, {
          onSuccess: ({ tax_rate }) => {
          console.log(tax_rate.products)
          }
          })
          }
          // ...
          }
          export default TaxRate
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/tax-rates/{id}/products/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "products": [
          {product_id}"
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Tax Rates
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminTaxRatesRes'
          description: OK
      parameters:
      - (path) id=* {string} ID of the tax rate.
      - description: Comma-separated fields that should be included in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: fields
        schema: null
        style: form
        type: string
      - description: Comma-separated relations that should be expanded in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: expand
        schema: null
        style: form
        type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostTaxRatesTaxRateProductsReq'
  /admin/tax-rates/{id}/shipping-options/batch:
    delete:
      operationId: DeleteTaxRatesTaxRateShippingOptions
      summary: Remove Shipping Options from Rate
      description: Remove shipping options from a tax rate. This only removes the
        association between the shipping options and the tax rate. It does not delete
        the shipping options.
      x-authenticated: true
      x-codegen:
        method: removeShippingOptions
        queryParams: AdminDeleteTaxRatesTaxRateShippingOptionsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.taxRates.removeShippingOptions(taxRateId, {
          shipping_options: [
          shippingOptionId
          ]
          })
          .then(({ tax_rate }) => {
          console.log(tax_rate.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteShippingTaxRates } from "medusa-react"
          type Props = {
          taxRateId: string
          }
          const TaxRate = ({ taxRateId }: Props) => {
          const removeShippingOptions = useAdminDeleteShippingTaxRates(
          taxRateId
          )
          // ...
          const handleRemoveShippingOptions = (
          shippingOptionIds: string[]
          ) => {
          removeShippingOptions.mutate({
          shipping_options: shippingOptionIds,
          }, {
          onSuccess: ({ tax_rate }) => {
          console.log(tax_rate.shipping_options)
          }
          })
          }
          // ...
          }
          export default TaxRate
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/tax-rates/{id}/shipping-options/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "shipping_options": [
          {shipping_option_id}"
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Tax Rates
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminTaxRatesRes'
          description: OK
      parameters:
      - (path) id=* {string} ID of the tax rate.
      - description: Comma-separated fields that should be included in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: fields
        schema: null
        style: form
        type: string
      - description: Comma-separated relations that should be expanded in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: expand
        schema: null
        style: form
        type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminDeleteTaxRatesTaxRateShippingOptionsReq'
    post:
      operationId: PostTaxRatesTaxRateShippingOptions
      summary: Add to Shipping Options
      description: Add Shipping Options to a Tax Rate.
      x-authenticated: true
      x-codegen:
        method: addShippingOptions
        queryParams: AdminPostTaxRatesTaxRateShippingOptionsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.taxRates.addShippingOptions(taxRateId, {
          shipping_options: [
          shippingOptionId
          ]
          })
          .then(({ tax_rate }) => {
          console.log(tax_rate.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateShippingTaxRates } from "medusa-react"
          type Props = {
          taxRateId: string
          }
          const TaxRate = ({ taxRateId }: Props) => {
          const addShippingOption = useAdminCreateShippingTaxRates(
          taxRateId
          )
          // ...
          const handleAddShippingOptions = (
          shippingOptionIds: string[]
          ) => {
          addShippingOption.mutate({
          shipping_options: shippingOptionIds,
          }, {
          onSuccess: ({ tax_rate }) => {
          console.log(tax_rate.shipping_options)
          }
          })
          }
          // ...
          }
          export default TaxRate
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/tax-rates/{id}/shipping-options/batch' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "shipping_options": [
          {shipping_option_id}"
          ]
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Tax Rates
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminTaxRatesRes'
          description: OK
      parameters:
      - (path) id=* {string} ID of the tax rate.
      - description: Comma-separated fields that should be included in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: fields
        schema: null
        style: form
        type: string
      - description: Comma-separated relations that should be expanded in the returned
          tax rate.
        explode: false
        in: query
        items: null
        name: expand
        schema: null
        style: form
        type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostTaxRatesTaxRateShippingOptionsReq'
  /admin/uploads:
    delete:
      operationId: DeleteUploads
      summary: Delete an Uploaded File
      description: Delete an uploaded file from storage. The file is deleted using
        the installed file service on the Medusa backend.
      x-authenticated: true
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.uploads.delete({
          file_key
          })
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteFile } from "medusa-react"
          const Image = () => {
          const deleteFile = useAdminDeleteFile()
          // ...
          const handleDeleteFile = (fileKey: string) => {
          deleteFile.mutate({
          file_key: fileKey
          }, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default Image
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/uploads' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "file_key": "{file_key}"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Uploads
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDeleteUploadsRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminDeleteUploadsReq'
    post:
      operationId: PostUploads
      summary: Upload Files
      description: Upload at least one file to a public bucket or storage. The file
        upload is handled by the file service installed on the Medusa backend.
      x-authenticated: true
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.uploads.create(file)
          .then(({ uploads }) => {
          console.log(uploads.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUploadFile } from "medusa-react"
          const UploadFile = () => {
          const uploadFile = useAdminUploadFile()
          // ...
          const handleFileUpload = (file: File) => {
          uploadFile.mutate(file, {
          onSuccess: ({ uploads }) => {
          console.log(uploads[0].key)
          }
          })
          }
          // ...
          }
          export default UploadFile
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/uploads' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: image/jpeg' \
          --form 'files=@"<FILE_PATH_1>"' \
          --form 'files=@"<FILE_PATH_1>"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Uploads
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminUploadsRes'
          description: OK
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                files:
                  type: string
                  format: binary
  /admin/uploads/download-url:
    post:
      operationId: PostUploadsDownloadUrl
      summary: Get a File's Download URL
      description: Create and retrieve a presigned or public download URL for a file.
        The URL creation is handled by the file service installed on the Medusa backend.
      x-authenticated: true
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.uploads.getPresignedDownloadUrl({
          file_key
          })
          .then(({ download_url }) => {
          console.log(download_url);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreatePresignedDownloadUrl } from "medusa-react"
          const Image = () => {
          const createPresignedUrl = useAdminCreatePresignedDownloadUrl()
          // ...
          const handlePresignedUrl = (fileKey: string) => {
          createPresignedUrl.mutate({
          file_key: fileKey
          }, {
          onSuccess: ({ download_url }) => {
          console.log(download_url)
          }
          })
          }
          // ...
          }
          export default Image
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/uploads/download-url' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "file_key": "{file_key}"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Uploads
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminUploadsDownloadUrlRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminPostUploadsDownloadUrlReq'
  /admin/uploads/protected:
    post:
      operationId: PostUploadsProtected
      summary: Protected File Upload
      description: Upload at least one file to an ACL or a non-public bucket. The
        file upload is handled by the file service installed on the Medusa backend.
      x-authenticated: true
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.uploads.createProtected(file)
          .then(({ uploads }) => {
          console.log(uploads.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUploadProtectedFile } from "medusa-react"
          const UploadFile = () => {
          const uploadFile = useAdminUploadProtectedFile()
          // ...
          const handleFileUpload = (file: File) => {
          uploadFile.mutate(file, {
          onSuccess: ({ uploads }) => {
          console.log(uploads[0].key)
          }
          })
          }
          // ...
          }
          export default UploadFile
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/uploads/protected' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: image/jpeg' \
          --form 'files=@"<FILE_PATH_1>"' \
          --form 'files=@"<FILE_PATH_1>"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Uploads
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminUploadsRes'
          description: OK
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                files:
                  type: string
                  format: binary
  /admin/users:
    get:
      operationId: GetUsers
      summary: List Users
      description: Retrieves a list of users. The users can be filtered by fields
        such as `q` or `email`. The users can also be sorted or paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetUsersParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.users.list()
          .then(({ users, limit, offset, count }) => {
          console.log(users.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUsers } from "medusa-react"
          const Users = () => {
          const { users, isLoading } = useAdminUsers()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {users && !users.length && <span>No Users</span>}
          {users && users.length > 0 && (
          <ul>
          {users.map((user) => (
          <li key={user.id}>{user.email}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Users
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/users' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Users
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminUsersListRes'
          description: OK
      parameters:
      - (query) email {string} Filter by email.
      - (query) first_name {string} Filter by first name.
      - (query) last_name {string} Filter by last name.
      - (query) q {string} Term used to search users' first name, last name, and email.
      - (query) order {string} A user field to sort-order the retrieved users by.
      - description: Filter by user IDs.
        explode: false
        in: query
        name: id
        oneOf: null
        schema: null
        style: form
      - description: ID of the user.
        type: string
      - description: ID of a user.
        items: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: deleted_at
        properties: null
        schema: null
        type: string
      - (query) offset=0 {integer} The number of users to skip when retrieving the
        users.
      - (query) limit=20 {integer} Limit the number of users returned.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned users.
    post:
      operationId: PostUsers
      summary: Create a User
      description: Create an admin User. The user has the same privileges as all admin
        users, and will be able to authenticate and perform admin functionalities
        right after creation.
      x-authenticated: true
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.users.create({
          email: "user@example.com",
          password: "supersecret"
          })
          .then(({ user }) => {
          console.log(user.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminCreateUser } from "medusa-react"
          const CreateUser = () => {
          const createUser = useAdminCreateUser()
          // ...
          const handleCreateUser = () => {
          createUser.mutate({
          email: "user@example.com",
          password: "supersecret",
          }, {
          onSuccess: ({ user }) => {
          console.log(user.id)
          }
          })
          }
          // ...
          }
          export default CreateUser
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/users' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com",
          "password": "supersecret"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Users
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminUserRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminCreateUserRequest'
  /admin/users/{id}:
    delete:
      operationId: DeleteUsersUser
      summary: Delete a User
      description: Delete a User. Once deleted, the user will not be able to authenticate
        or perform admin functionalities.
      x-authenticated: true
      x-codegen:
        method: delete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.users.delete(userId)
          .then(({ id, object, deleted }) => {
          console.log(id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminDeleteUser } from "medusa-react"
          type Props = {
          userId: string
          }
          const User = ({ userId }: Props) => {
          const deleteUser = useAdminDeleteUser(userId)
          // ...
          const handleDeleteUser = () => {
          deleteUser.mutate(void 0, {
          onSuccess: ({ id, object, deleted }) => {
          console.log(id)
          }
          })
          }
          // ...
          }
          export default User
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '"{backend_url}"/admin/users/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Users
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminDeleteUserRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the User.
    get:
      operationId: GetUsersUser
      summary: Get a User
      description: Retrieve an admin user's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.users.retrieve(userId)
          .then(({ user }) => {
          console.log(user.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUser } from "medusa-react"
          type Props = {
          userId: string
          }
          const User = ({ userId }: Props) => {
          const { user, isLoading } = useAdminUser(
          userId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {user && <span>{user.first_name} {user.last_name}</span>}
          </div>
          )
          }
          export default User
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/users/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Users
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminUserRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the User.
    post:
      operationId: PostUsersUser
      summary: Update a User
      description: Update an admin user's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.users.update(userId, {
          first_name: "Marcellus"
          })
          .then(({ user }) => {
          console.log(user.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminUpdateUser } from "medusa-react"
          type Props = {
          userId: string
          }
          const User = ({ userId }: Props) => {
          const updateUser = useAdminUpdateUser(userId)
          // ...
          const handleUpdateUser = (
          firstName: string
          ) => {
          updateUser.mutate({
          first_name: firstName,
          }, {
          onSuccess: ({ user }) => {
          console.log(user.first_name)
          }
          })
          }
          // ...
          }
          export default User
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/users/{id}' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "first_name": "Marcellus"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Users
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminUserRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the User.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminUpdateUserRequest'
  /admin/users/password-token:
    post:
      operationId: PostUsersUserPasswordToken
      summary: Request Password Reset
      description: Generate a password token for an admin user with a given email.
        This also triggers the `user.password_reset` event. So, if you have a Notification
        Service installed that can handle this event, a notification, such as an email,
        will be sent to the user. The token is triggered as part of the `user.password_reset`
        event's payload. That token must be used later to reset the password using
        the [Reset Password](https://docs.medusajs.com/api/admin#users_postusersuserpassword)
        API Route.
      x-codegen:
        method: sendResetPasswordToken
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.users.sendResetPasswordToken({
          email: "user@example.com"
          })
          .then(() => {
          // successful
          })
          .catch(() => {
          // error occurred
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminSendResetPasswordToken } from "medusa-react"
          const Login = () => {
          const requestPasswordReset = useAdminSendResetPasswordToken()
          // ...
          const handleResetPassword = (
          email: string
          ) => {
          requestPasswordReset.mutate({
          email
          }, {
          onSuccess: () => {
          // successful
          }
          })
          }
          // ...
          }
          export default Login
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/users/password-token' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Users
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        Ì:
          content: {}
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminResetPasswordTokenRequest'
      externalDocs:
        description: How to reset a user's password
        url: https://docs.medusajs.com/modules/users/admin/manage-profile#reset-password
  /admin/users/reset-password:
    post:
      operationId: PostUsersUserPassword
      summary: Reset Password
      description: Reset the password of an admin User using their reset password
        token. A user must request to reset their password first before attempting
        to reset their password with this request.
      x-codegen:
        method: resetPassword
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.users.resetPassword({
          token: "supersecrettoken",
          password: "supersecret"
          })
          .then(({ user }) => {
          console.log(user.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminResetPassword } from "medusa-react"
          const ResetPassword = () => {
          const resetPassword = useAdminResetPassword()
          // ...
          const handleResetPassword = (
          token: string,
          password: string
          ) => {
          resetPassword.mutate({
          token,
          password,
          }, {
          onSuccess: ({ user }) => {
          console.log(user.id)
          }
          })
          }
          // ...
          }
          export default ResetPassword
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '"{backend_url}"/admin/users/reset-password' \
          -H 'x-medusa-access-token: "{api_token}"' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "token": "supersecrettoken",
          "password": "supersecret"
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Users
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminUserRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AdminResetPasswordRequest'
      externalDocs:
        description: How to reset a user's password
        url: https://docs.medusajs.com/modules/users/admin/manage-profile#reset-password
  /admin/variants:
    get:
      operationId: GetVariants
      summary: List Product Variants
      description: Retrieve a list of Product Variants. The product variant can be
        filtered by fields such as `id` or `title`. The product variant can also be
        paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: AdminGetVariantsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.variants.list()
          .then(({ variants, limit, offset, count }) => {
          console.log(variants.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminVariants } from "medusa-react"
          const Variants = () => {
          const { variants, isLoading } = useAdminVariants()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {variants && !variants.length && (
          <span>No Variants</span>
          )}
          {variants && variants.length > 0 && (
          <ul>
          {variants.map((variant) => (
          <li key={variant.id}>{variant.title}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Variants
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/variants' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Variants
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminVariantsListRes'
          description: OK
      parameters:
      - description: Filter by product variant IDs.
        explode: false
        in: query
        name: id
        oneOf: null
        schema: null
        style: form
      - description: A product variant ID.
        type: string
      - description: An array of product variant IDs.
        items: null
        type: string
      - (query) expand {string} "Comma-separated relations that should be expanded
        in the returned product variants."
      - (query) fields {string} "Comma-separated fields that should be included in
        the returned product variants."
      - (query) offset=0 {number} The number of product variants to skip when retrieving
        the product variants.
      - (query) limit=100 {number} Limit the number of product variants returned.
      - description: The ID of the cart to use for the price selection context.
        explode: false
        in: query
        name: cart_id
        schema: null
        style: form
        type: string
      - description: Price selection context overview
        explode: false
        externalDocs: null
        in: query
        name: region_id
        schema: null
        style: form
        type: string
        url: https://docs.medusajs.com/modules/price-lists/price-selection-strategy#context-object
      - description: Price selection context overview
        explode: false
        externalDocs: null
        in: query
        name: currency_code
        schema: null
        style: form
        type: string
        url: https://docs.medusajs.com/modules/price-lists/price-selection-strategy#context-object
      - description: Price selection context overview
        explode: false
        externalDocs: null
        in: query
        name: customer_id
        schema: null
        style: form
        type: string
        url: https://docs.medusajs.com/modules/price-lists/price-selection-strategy#context-object
      - description: Filter by title.
        explode: false
        in: query
        name: title
        oneOf: null
        schema: null
        style: form
      - description: a single title to filter by
        type: string
      - description: multiple titles to filter by
        items: null
        type: string
      - description: Filter by available inventory quantity
        in: query
        name: inventory_quantity
        oneOf: null
        schema: null
      - description: a specific number to filter by.
        type: number
      - description: filter by inventory quantity greater than or equal to this number
        gt: null
        gte: null
        lt: null
        lte: null
        properties: null
        type: number
  /admin/variants/{id}:
    get:
      operationId: GetVariantsVariant
      summary: Get a Product variant
      description: Retrieve a product variant's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
        queryParams: AdminGetVariantParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.variants.retrieve(variantId)
          .then(({ variant }) => {
          console.log(variant.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminVariant } from "medusa-react"
          type Props = {
          variantId: string
          }
          const Variant = ({ variantId }: Props) => {
          const { variant, isLoading } = useAdminVariant(
          variantId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {variant && <span>{variant.title}</span>}
          </div>
          )
          }
          export default Variant
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/variants/{id}' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Variants
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminVariantsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the product variant.
      - (query) expand {string} "Comma-separated relations that should be expanded
        in the returned product variant."
      - (query) fields {string} "Comma-separated fields that should be included in
        the returned product variant."
  /admin/variants/{id}/inventory:
    get:
      operationId: GetVariantsVariantInventory
      summary: Get Variant's Inventory
      description: Retrieve the available inventory of a Product Variant.
      x-authenticated: true
      x-codegen:
        method: getInventory
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.admin.variants.getInventory(variantId)
          .then(({ variant }) => {
          console.log(variant.inventory, variant.sales_channel_availability)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAdminVariantsInventory } from "medusa-react"
          type Props = {
          variantId: string
          }
          const VariantInventory = ({ variantId }: Props) => {
          const { variant, isLoading } = useAdminVariantsInventory(
          variantId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {variant && variant.inventory.length === 0 && (
          <span>Variant doesn't have inventory details</span>
          )}
          {variant && variant.inventory.length > 0 && (
          <ul>
          {variant.inventory.map((inventory) => (
          <li key={inventory.id}>{inventory.title}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default VariantInventory
      - lang: Shell
        label: cURL
        source: |
          curl '"{backend_url}"/admin/variants/{id}/inventory' \
          -H 'x-medusa-access-token: "{api_token}"'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Variants
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/unauthorized'
          description: Unauthorized
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdminGetVariantsVariantInventoryRes'
          description: OK
      parameters:
      - (path) id {string} The Product Variant ID.
tags:
- name: Apps Oauth
  description: |
    Some plugins may require to authenticate with third-party services and store authentication details, such as the authentication token. To do that, they can create an Oauth provider within the plugin that handles the authentication.
    The Apps Oauth API Routes allows admins to manage and generate token for an app using its oauth provider.
- name: Auth
  description: |
    Authentication API Routes allow admin users to manage their session, such as login or log out.
    When an admin user is logged in, the cookie header is set indicating the admin's login session.
- name: Batch Jobs
  description: |
    A batch job is a task that is performed by the Medusa backend asynchronusly. For example, the Import Product feature is implemented using batch jobs.
    Batch Job API Routes allow admins to manage the batch jobs and their state.
- name: Currencies
  description: |
    A store can use unlimited currencies, and each region must be associated with at least one currency.
    Currencies are defined within the Medusa backend. Currency API Routes allow admins to list and update currencies.
- name: Customers
  description: |
    Customers can either be created when they register through the Store APIs, or created by the admin using the Admin APIs.
- name: Customer Groups
  description: |
    Customer Groups can be used to organize customers that share similar data or attributes into dedicated groups.
    This can be useful for different purposes such as setting a different price for a specific customer group.
- name: Discounts
  description: |
    Admins can create discounts with conditions and rules, providing them with advanced settings for variety of cases.
    The Discount API Routes can be used to manage discounts, their conditions, resources, and more.
- name: Draft Orders
  description: |
    A draft order is an order created manually by the admin. It allows admins to create orders without direct involvement from the customer.
- name: Gift Cards
  description: |
    Admins can create gift cards and send them directly to customers, specifying options like their balance, region, and more.
    These gift cards are different than the saleable gift cards in a store, which are created and managed through Product API Routes.
- name: Inventory Items
  description: |
    Inventory items, provided by the [Inventory Module](https://docs.medusajs.com/modules/multiwarehouse/inventory-module), can be used to manage the inventory of saleable items in your store.
- name: Invites
  description: |
    An admin can invite new users to manage their team. This would allow new users to authenticate as admins and perform admin functionalities.
- name: Notes
  description: |
    Notes are created by admins and can be associated with any resource. For example, an admin can add a note to an order for additional details or remarks.
- name: Notifications
  description: |
    Notifications are sent to customers to inform them of new updates. For example, a notification can be sent to the customer when their order is place or its state is updated.
    The notification's type, such as an email or SMS, is determined by the notification provider installed on the Medusa backend.
- name: Orders
  description: |
    Orders are purchases made by customers, typically through a storefront using the Store API. Draft orders created by the admin are also transformed to an Order once the payment is captured.
    Managing orders include managing fulfillment, payment, claims, reservations, and more.
- name: Order Edits
  description: |
    An admin can edit an order to remove, add, or update an item's quantity. When an admin edits an order, they're stored as an `OrderEdit`.
- name: Payments
  description: |
    A payment can be related to an order, swap, return, or more. It can be captured or refunded.
- name: Payment Collections
  description: |
    A payment collection is useful for managing additional payments, such as for Order Edits, or installment payments.
- name: Price Lists
  description: |
    A price list are special prices applied to products based on a set of conditions, such as customer group.
- name: Products
  description: |
    Products are saleable items in a store. This also includes [saleable gift cards](https://docs.medusajs.com/modules/gift-cards/admin/manage-gift-cards#manage-gift-card-product) in a store.
- name: Product Categories
  description: |
    Products can be categoriezed into categories. A product can be added into more than one category.
- name: Product Collections
  description: |
    A product collection is used to organize products for different purposes such as marketing or discount purposes. For example, you can create a Summer Collection.
- name: Product Tags
  description: |
    Product tags are string values created when you create or update a product with a new tag.
    Products can have more than one tag, and products can share tags. This allows admins to associate products to similar tags that can be used to filter products.
- name: Product Types
  description: |
    Product types are string values created when you create or update a product with a new type.
    Products can have one type, and products can share types. This allows admins to associate products with a type that can be used to filter products.
- name: Product Variants
  description: |
    Product variants are the actual salable item in your store. Each variant is a combination of the different option values available on the product.
    Product variants can be managed through the Products API Routes.
- name: Publishable API Keys
  description: |
    Publishable API Keys can be used to scope Store API calls with an API key, determining what resources are retrieved when querying the API.
    For example, a publishable API key can be associated with one or more sales channels. When it is passed in the header of a request to the List Product store API Route,
    the sales channels are inferred from the key and only products associated with those sales channels are retrieved.
    Admins can manage publishable API keys and their associated resources. Currently, only Sales Channels are supported as a resource.
- name: Reservations
  description: |
    Reservations, provided by the [Inventory Module](https://docs.medusajs.com/modules/multiwarehouse/inventory-module), are quantities of an item that are reserved, typically when an order is placed but not yet fulfilled.
    Reservations can be associated with any resources, but commonly with line items of an order.
- name: Regions
  description: |
    Regions are different countries or geographical regions that the commerce store serves customers in.
    Admins can manage these regions, their providers, and more.
- name: Return Reasons
  description: |
    Return reasons are key-value pairs that are used to specify why an order return is being created.
    Admins can manage available return reasons, and they can be used by both admins and customers when creating a return.
- name: Returns
  description: |
    A return can be created by a customer or an admin to return items in an order.
    Admins can manage these returns and change their state.
- name: Sales Channels
  description: |
    A sales channel indicates a channel where products can be sold in. For example, a webshop or a mobile app.
    Admins can manage sales channels and the products available in them.
- name: Shipping Options
  description: |
    A shipping option is used to define the available shipping methods during checkout or when creating a return.
    Admins can create an unlimited number of shipping options, each associated with a shipping profile and fulfillment provider, among other resources.
- name: Shipping Profiles
  description: |
    A shipping profile is used to group products that can be shipped in the same manner.
    They are created by the admin and they're not associated with a fulfillment provider.
- name: Stock Locations
  description: |
    A stock location, provided by the [Stock Location module](https://docs.medusajs.com/modules/multiwarehouse/stock-location-module), indicates a physical address that stock-kept items, such as physical products, can be stored in.
    An admin can create and manage available stock locations.
- name: Store
  description: |
    A store indicates the general configurations and details about the commerce store. By default, there's only one store in the Medusa backend.
    Admins can manage the store and its details or configurations.
- name: Swaps
  description: |
    A swap is created by a customer or an admin to exchange an item with a new one.
    Creating a swap implicitely includes creating a return for the item being exchanged.
- name: Tax Rates
  description: |
    Each region has at least a default tax rate. Admins can create and manage additional tax rates that can be applied for certain conditions, such as for specific product types.
- name: Uploads
  description: |
    The upload API Routes are used to upload any type of resources. For example, they can be used to upload CSV files that are used to import products into the store.
- name: Users
  description: |
    A store can have more than one user, each having the same privileges. Admins can manage users, their passwords, and more.
components:
  Address:
    description: An address is used across the Medusa backend within other schemas
      and object types. For example, a customer's billing and shipping addresses both
      use the Address entity.
    required:
    - address_1
    - address_2
    - city
    - company
    - country_code
    - created_at
    - customer_id
    - deleted_at
    - first_name
    - id
    - last_name
    - metadata
    - phone
    - postal_code
    - province
    - updated_at
    type: object
    properties:
      address_1:
        description: Address line 1
        nullable: true
        type: string
        example: 14433 Kemmer Court
      address_2:
        description: Address line 2
        nullable: true
        type: string
        example: Suite 369
      city:
        description: City
        nullable: true
        type: string
        example: South Geoffreyview
      company:
        description: Company name
        nullable: true
        type: string
        example: Acme
      country:
        description: A country object.
        nullable: true
        $ref: '#/components/schemas/Country'
      country_code:
        description: The 2 character ISO code of the country in lower case
        nullable: true
        type: string
        example: st
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      customer:
        description: Available if the relation `customer` is expanded.
        nullable: true
        $ref: '#/components/schemas/Customer'
      customer_id:
        description: ID of the customer this address belongs to
        nullable: true
        type: string
        example: cus_01G2SG30J8C85S4A5CHM2S1NS2
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      first_name:
        description: First name
        nullable: true
        type: string
        example: Arno
      id:
        description: ID of the address
        type: string
        example: addr_01G8ZC9VS1XVE149MGH2J7QSSH
      last_name:
        description: Last name
        nullable: true
        type: string
        example: Willms
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      phone:
        description: Phone Number
        nullable: true
        type: string
        example: 16128234334802
      postal_code:
        description: Postal Code
        nullable: true
        type: string
        example: 72093
      province:
        description: Province
        nullable: true
        type: string
        example: Kentucky
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  AdminCreateUserRequest:
    required:
    - email
    - password
    type: object
    properties:
      email:
        description: The User's email.
        type: string
        format: email
      first_name:
        description: The first name of the User.
        type: string
      last_name:
        description: The last name of the User.
        type: string
      password:
        description: The User's password.
        type: string
        format: password
      role:
        description: The role assigned to the user. These roles don't provide any
          different privileges.
        type: string
        enum:
        - admin
        - member
        - developer
  AdminDeleteDiscountsDiscountConditionsConditionBatchReq:
    description: The resources to remove.
    required:
    - resources
    type: object
    properties:
      resources:
        description: The resources to be removed from the discount condition
        type: array
        items:
          properties:
            id:
              description: The id of the item
              type: string
          required:
          - id
          type: object
  AdminDeletePriceListPricesPricesReq:
    description: The details of the prices to delete.
    type: object
    properties:
      price_ids:
        description: The IDs of the prices to delete.
        type: array
        items:
          type: string
  AdminDeletePriceListsPriceListProductsPricesBatchReq:
    description: The details of the products' prices to delete.
    type: object
    properties:
      product_ids:
        description: The IDs of the products to delete their associated prices.
        type: array
        items:
          type: string
  AdminDeleteUploadsReq:
    description: The details of the file to delete.
    required:
    - file_key
    type: object
    properties:
      file_key:
        description: key of the file to delete. This is obtained when you first uploaded
          the file, or by the file service if you used it directly.
        type: string
  AdminOrdersOrderLineItemReservationReq:
    required:
    - location_id
    type: object
    properties:
      location_id:
        description: The ID of the location of the reservation
        type: string
      quantity:
        description: The quantity to reserve
        type: number
  AdminPostBatchesReq:
    description: The details of the batch job to create.
    required:
    - type
    - context
    type: object
    properties:
      context:
        description: Additional infomration regarding the batch to be used for processing.
        type: object
        example:
          list_config:
            order:
              created_at: DESC
            relations:
            - variants
            - variant.prices
            - images
            skip: 0
            take: 50
          shape:
            dynamicImageColumnCount: 4
            dynamicOptionColumnCount: 2
            prices:
            - currency_code: eur
              region: null
      dry_run:
        description: Set a batch job in dry_run mode, which would delay executing
          the batch job until it's confirmed.
        type: boolean
      type:
        description: The type of batch job to start, which is defined by the `batchType`
          property of the associated batch job strategy.
        type: string
        example: product-export
  AdminPostCollectionsCollectionReq:
    description: The product collection's details to update.
    type: object
    properties:
      handle:
        description: An optional handle to be used in slugs. If none is provided,
          the kebab-case version of the title will be used.
        type: string
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      title:
        description: The title of the collection.
        type: string
  AdminPostCollectionsReq:
    description: The product collection's details.
    required:
    - title
    type: object
    properties:
      handle:
        description: An optional handle to be used in slugs. If none is provided,
          the kebab-case version of the title will be used.
        type: string
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      title:
        description: The title of the collection.
        type: string
  AdminPostCurrenciesCurrencyReq:
    description: The details to update in the currency
    type: object
    properties:
      includes_tax:
        description: Tax included in prices of currency.
        type: boolean
  AdminPostCustomerGroupsGroupCustomersBatchReq:
    description: The customers to add to the customer group.
    required:
    - customer_ids
    type: object
    properties:
      customer_ids:
        description: The ids of the customers to add
        type: array
        items:
          properties:
            id:
              description: ID of the customer
              type: string
          required:
          - id
          type: object
  AdminPostCustomerGroupsGroupReq:
    description: The details to update in the customer group.
    type: object
    properties:
      metadata:
        description: Metadata of the customer group.
        type: object
      name:
        description: Name of the customer group
        type: string
  AdminPostCustomerGroupsReq:
    description: The details of the customer group to create.
    required:
    - name
    type: object
    properties:
      metadata:
        description: Metadata of the customer group.
        type: object
      name:
        description: Name of the customer group
        type: string
  AdminPostDiscountsDiscountConditions:
    required:
    - operator
    type: object
    properties:
      customer_groups:
        description: list of customer group IDs if the condition's type is `customer_groups`.
        type: array
        items:
          type: string
      operator:
        description: Operator of the condition. `in` indicates that discountable resources
          are within the specified resources. `not_in` indicates that discountable
          resources are everything but the specified resources.
        type: string
        enum:
        - in
        - not_in
      product_collections:
        description: list of product collection IDs if the condition's type is `product_collections`.
        type: array
        items:
          type: string
      product_tags:
        description: list of product tag IDs if the condition's type is `product_tags`.
        type: array
        items:
          type: string
      product_types:
        description: list of product type IDs if the condition's type is `product_types`.
        type: array
        items:
          type: string
      products:
        description: list of product IDs if the condition's type is `products`.
        type: array
        items:
          type: string
  AdminPostDiscountsDiscountConditionsCondition:
    type: object
    properties:
      customer_groups:
        description: list of customer group IDs if the condition's type is `customer_groups`.
        type: array
        items:
          type: string
      product_collections:
        description: list of product collection IDs if the condition's type is `product_collections`.
        type: array
        items:
          type: string
      product_tags:
        description: list of product tag IDs if the condition's type is `product_tags`
        type: array
        items:
          type: string
      product_types:
        description: list of product type IDs if the condition's type is `product_types`.
        type: array
        items:
          type: string
      products:
        description: list of product IDs if the condition's type is `products`.
        type: array
        items:
          type: string
  AdminPostDiscountsDiscountDynamicCodesReq:
    description: The details of the dynamic discount to create.
    required:
    - code
    type: object
    properties:
      code:
        description: A unique code that will be used to redeem the Discount
        type: string
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      usage_limit:
        description: Maximum number of times the discount code can be used
        type: number
  AdminPostDiscountsDiscountReq:
    description: The details of the discount to update.
    type: object
    properties:
      code:
        description: A unique code that will be used to redeem the discount
        type: string
      ends_at:
        description: The date and time at which the discount should no longer be available.
        type: string
        format: date-time
      is_disabled:
        description: Whether the discount code is disabled on creation. If set to
          `true`, it will not be available for customers.
        type: boolean
      metadata:
        description: An object containing metadata of the discount
        type: object
      regions:
        description: A list of region IDs representing the Regions in which the Discount
          can be used.
        type: array
        items:
          type: string
      rule:
        description: The discount rule that defines how discounts are calculated
        required:
        - id
        type: object
        properties:
          allocation:
            description: The scope that the discount should apply to. `total` indicates
              that the discount should be applied on the cart total, and `item` indicates
              that the discount should be applied to each discountable item in the
              cart.
            type: string
            enum:
            - total
            - item
          conditions:
            description: A set of conditions that can be used to limit when the discount
              can be used. Only one of `products`, `product_types`, `product_collections`,
              `product_tags`, and `customer_groups` should be provided based on the
              discount condition's type.
            type: array
            items:
              properties:
                customer_groups:
                  description: list of customer group IDs if the condition's type
                    is `customer_groups`.
                  items:
                    type: string
                  type: array
                id:
                  description: The ID of the condition
                  type: string
                operator:
                  description: Operator of the condition. `in` indicates that discountable
                    resources are within the specified resources. `not_in` indicates
                    that discountable resources are everything but the specified resources.
                  enum:
                  - in
                  - not_in
                  type: string
                product_collections:
                  description: list of product collection IDs if the condition's type
                    is `product_collections`.
                  items:
                    type: string
                  type: array
                product_tags:
                  description: list of product tag IDs if the condition's type is
                    `product_tags`.
                  items:
                    type: string
                  type: array
                product_types:
                  description: list of product type IDs if the condition's type is
                    `product_types`.
                  items:
                    type: string
                  type: array
                products:
                  description: list of product IDs if the condition's type is `products`.
                  items:
                    type: string
                  type: array
              required:
              - operator
              type: object
          description:
            description: A short description of the discount
            type: string
          id:
            description: The ID of the Rule
            type: string
          value:
            description: The value that the discount represents. This will depend
              on the type of the discount.
            type: number
      starts_at:
        description: The date and time at which the discount should be available.
        type: string
        format: date-time
      usage_limit:
        description: Maximum number of times the discount can be used
        type: number
      valid_duration:
        description: The duration the discount runs between
        type: string
        example: P3Y6M4DT12H30M5S
  AdminPostDiscountsReq:
    description: The details of the discount to create.
    required:
    - code
    - rule
    - regions
    type: object
    properties:
      code:
        description: A unique code that will be used to redeem the discount
        type: string
      ends_at:
        description: The date and time at which the discount should no longer be available.
        type: string
        format: date-time
      is_disabled:
        description: Whether the discount code is disabled on creation. If set to
          `true`, it will not be available for customers.
        type: boolean
      is_dynamic:
        description: Whether the discount should have multiple instances of itself,
          each with a different code. This can be useful for automatically generated
          discount codes that all have to follow a common set of rules.
        type: boolean
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      regions:
        description: A list of region IDs representing the Regions in which the Discount
          can be used.
        type: array
        items:
          type: string
      rule:
        description: The discount rule that defines how discounts are calculated
        required:
        - type
        - value
        - allocation
        type: object
        properties:
          allocation:
            description: The scope that the discount should apply to. `total` indicates
              that the discount should be applied on the cart total, and `item` indicates
              that the discount should be applied to each discountable item in the
              cart.
            type: string
            enum:
            - total
            - item
          conditions:
            description: A set of conditions that can be used to limit when the discount
              can be used. Only one of `products`, `product_types`, `product_collections`,
              `product_tags`, and `customer_groups` should be provided based on the
              discount condition's type.
            type: array
            items:
              properties:
                customer_groups:
                  description: list of customer group IDs if the condition's type
                    is `customer_groups`.
                  items:
                    type: string
                  type: array
                operator:
                  description: Operator of the condition. `in` indicates that discountable
                    resources are within the specified resources. `not_in` indicates
                    that discountable resources are everything but the specified resources.
                  enum:
                  - in
                  - not_in
                  type: string
                product_collections:
                  description: list of product collection IDs if the condition's type
                    is `product_collections`.
                  items:
                    type: string
                  type: array
                product_tags:
                  description: list of product tag IDs if the condition's type is
                    `product_tags`.
                  items:
                    type: string
                  type: array
                product_types:
                  description: list of product type IDs if the condition's type is
                    `product_types`.
                  items:
                    type: string
                  type: array
                products:
                  description: list of product IDs if the condition's type is `products`.
                  items:
                    type: string
                  type: array
              required:
              - operator
              type: object
          description:
            description: A short description of the discount
            type: string
          type:
            description: The type of the discount, can be `fixed` for discounts that
              reduce the price by a fixed amount, `percentage` for percentage reductions
              or `free_shipping` for shipping vouchers.
            type: string
            enum:
            - fixed
            - percentage
            - free_shipping
          value:
            description: The value that the discount represents. This will depend
              on the type of the discount.
            type: number
      starts_at:
        description: The date and time at which the discount should be available.
        type: string
        format: date-time
      usage_limit:
        description: Maximum number of times the discount can be used
        type: number
      valid_duration:
        description: The duration the discount runs between
        type: string
        example: P3Y6M4DT12H30M5S
  AdminPostDraftOrdersDraftOrderLineItemsReq:
    description: The details of the line item to create.
    required:
    - quantity
    type: object
    properties:
      metadata:
        description: The optional key-value map with additional details about the
          Line Item.
        type: object
      quantity:
        description: The quantity of the line item.
        type: integer
      title:
        description: The title of the line item if `variant_id` is not provided.
        type: string
      unit_price:
        description: The custom price of the line item. If a `variant_id` is supplied,
          the price provided here will override the variant's price.
        type: integer
      variant_id:
        description: The ID of the Product Variant associated with the line item.
          If the line item is custom, the `variant_id` should be omitted.
        type: string
  AdminPostDraftOrdersDraftOrderReq:
    description: The details of the draft order to update.
    type: object
    properties:
      billing_address:
        description: The Address to be used for billing purposes.
      country_code:
        description: The 2 character ISO code for the Country.
        type: string
      customer_id:
        description: The ID of the customer this draft order is associated with.
        type: string
      discounts:
        description: An array of Discount codes to add to the Draft Order.
        type: array
        items:
          properties:
            code:
              description: The code that a Discount is identifed by.
              type: string
          required:
          - code
          type: object
      email:
        description: An email to be used in the Draft Order.
        type: string
        format: email
      no_notification_order:
        description: An optional flag passed to the resulting order that indicates
          whether the customer should receive notifications about order updates.
        type: boolean
      region_id:
        description: The ID of the Region to create the Draft Order in.
        type: string
      shipping_address:
        description: The Address to be used for shipping purposes.
  AdminPostDraftOrdersReq:
    description: The details of the draft order to create.
    required:
    - email
    - region_id
    - shipping_methods
    type: object
    properties:
      billing_address:
        description: The Address to be used for billing purposes.
      customer_id:
        description: The ID of the customer this draft order is associated with.
        type: string
      discounts:
        description: The discounts to add to the draft order
        type: array
        items:
          properties:
            code:
              description: The code of the discount to apply
              type: string
          required:
          - code
          type: object
      email:
        description: The email of the customer of the draft order
        type: string
        format: email
      items:
        description: The draft order's line items.
        type: array
        items:
          properties:
            metadata:
              description: The optional key-value map with additional details about
                the line item.
              externalDocs:
                description: Learn about the metadata attribute, and how to delete
                  and update it.
                url: https://docs.medusajs.com/development/entities/overview#metadata-attribute
              type: object
            quantity:
              description: The quantity of the line item.
              type: integer
            title:
              description: The title of the line item if `variant_id` is not provided.
              type: string
            unit_price:
              description: The custom price of the line item. If a `variant_id` is
                supplied, the price provided here will override the variant's price.
              type: integer
            variant_id:
              description: The ID of the Product Variant associated with the line
                item. If the line item is custom, the `variant_id` should be omitted.
              type: string
          required:
          - quantity
          type: object
      metadata:
        description: The optional key-value map with additional details about the
          Draft Order.
        type: object
      no_notification_order:
        description: An optional flag passed to the resulting order that indicates
          whether the customer should receive notifications about order updates.
        type: boolean
      region_id:
        description: The ID of the region for the draft order
        type: string
      shipping_address:
        description: The Address to be used for shipping purposes.
      shipping_methods:
        description: The shipping methods for the draft order
        type: array
        items:
          properties:
            data:
              description: The optional additional data needed for the shipping method
              type: object
            option_id:
              description: The ID of the shipping option in use
              type: string
            price:
              description: The price of the shipping method.
              type: integer
          required:
          - option_id
          type: object
      status:
        description: The status of the draft order. The draft order's default status
          is `open`. It's changed to `completed` when its payment is marked as paid.
        type: string
        enum:
        - open
        - completed
  AdminPostGiftCardsGiftCardReq:
    description: The details to update of the gift card.
    type: object
    properties:
      balance:
        description: The value (excluding VAT) that the Gift Card should represent.
        type: integer
      ends_at:
        description: The date and time at which the Gift Card should no longer be
          available.
        type: string
        format: date-time
      is_disabled:
        description: Whether the Gift Card is disabled on creation. If set to `true`,
          the gift card will not be available for customers.
        type: boolean
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      region_id:
        description: The ID of the Region in which the Gift Card can be used.
        type: string
  AdminPostGiftCardsReq:
    description: The details of the gift card to create.
    required:
    - region_id
    type: object
    properties:
      ends_at:
        description: The date and time at which the Gift Card should no longer be
          available.
        type: string
        format: date-time
      is_disabled:
        description: Whether the Gift Card is disabled on creation. If set to `true`,
          the gift card will not be available for customers.
        type: boolean
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      region_id:
        description: The ID of the Region in which the Gift Card can be used.
        type: string
      value:
        description: The value (excluding VAT) that the Gift Card should represent.
        type: integer
  AdminPostInvitesInviteAcceptReq:
    description: The details of the invite to be accepted.
    required:
    - token
    - user
    type: object
    properties:
      token:
        description: The token of the invite to accept. This is a unique token generated
          when the invite was created or resent.
        type: string
      user:
        description: The details of the user to create.
        required:
        - first_name
        - last_name
        - password
        type: object
        properties:
          first_name:
            description: the first name of the User
            type: string
          last_name:
            description: the last name of the User
            type: string
          password:
            description: The password for the User
            type: string
            format: password
  AdminPostInvitesReq:
    required:
    - user
    - role
    type: object
    properties:
      role:
        description: The role of the user to be created. This does not actually change
          the privileges of the user that is eventually created.
        type: string
        enum:
        - admin
        - member
        - developer
      user:
        description: The email associated with the invite. Once the invite is accepted,
          the email will be associated with the created user.
        type: string
        format: email
  AdminPostNotesNoteReq:
    description: The details to update of the note.
    required:
    - value
    type: object
    properties:
      value:
        description: The description of the Note.
        type: string
  AdminPostNotesReq:
    description: The details of the note to be created.
    required:
    - resource_id
    - resource_type
    - value
    type: object
    properties:
      resource_id:
        description: The ID of the resource which the Note relates to. For example,
          an order ID.
        type: string
      resource_type:
        description: The type of resource which the Note relates to. For example,
          `order`.
        type: string
      value:
        description: The content of the Note to create.
        type: string
  AdminPostNotificationsNotificationResendReq:
    description: The resend details.
    type: object
    properties:
      to:
        description: A new address or user identifier that the Notification should
          be sent to. If not provided, the previous `to` field of the notification
          will be used.
        type: string
  AdminPostOrderEditsEditLineItemsLineItemReq:
    description: The details to create or update of the line item change.
    required:
    - quantity
    type: object
    properties:
      quantity:
        description: The quantity to update
        type: number
  AdminPostOrderEditsEditLineItemsReq:
    description: The details of the line item change to create.
    required:
    - variant_id
    - quantity
    type: object
    properties:
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      quantity:
        description: The quantity of the item.
        type: number
      variant_id:
        description: The ID of the product variant associated with the item.
        type: string
  AdminPostOrderEditsOrderEditReq:
    description: The details to update of the order edit.
    type: object
    properties:
      internal_note:
        description: An optional note to create or update in the order edit.
        type: string
  AdminPostOrderEditsReq:
    description: The details of the order edit to create.
    required:
    - order_id
    type: object
    properties:
      internal_note:
        description: An optional note to associate with the order edit.
        type: string
      order_id:
        description: The ID of the order to create the edit for.
        type: string
  AdminPostOrdersOrderClaimsClaimFulfillmentsReq:
    type: object
    properties:
      location_id:
        description: The ID of the fulfillment's location.
        type: string
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      no_notification:
        description: If set to `true`, no notification will be sent to the customer
          related to this Claim.
        type: boolean
  AdminPostOrdersOrderClaimsClaimReq:
    type: object
    properties:
      claim_items:
        description: The Claim Items that the Claim will consist of.
        type: array
        items:
          properties:
            id:
              description: The ID of the Claim Item.
              type: string
            images:
              description: A list of image URL's that will be associated with the
                Claim
              items:
                properties:
                  id:
                    description: Image ID
                    type: string
                  url:
                    description: Image URL
                    type: string
                type: object
              type: array
            item_id:
              description: The ID of the Line Item that will be claimed.
              type: string
            metadata:
              description: An optional set of key-value pairs to hold additional information.
              externalDocs:
                description: Learn about the metadata attribute, and how to delete
                  and update it.
                url: https://docs.medusajs.com/development/entities/overview#metadata-attribute
              type: object
            note:
              description: Short text describing the Claim Item in further detail.
              type: string
            quantity:
              description: The number of items that will be returned
              type: integer
            reason:
              description: The reason for the Claim
              enum:
              - missing_item
              - wrong_item
              - production_failure
              - other
              type: string
            tags:
              description: A list o tags to add to the Claim Item
              items:
                properties:
                  id:
                    description: Tag ID
                    type: string
                  value:
                    description: Tag value
                    type: string
                type: object
              type: array
          required:
          - id
          - images
          - tags
          type: object
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      no_notification:
        description: If set to true no notification will be send related to this Swap.
        type: boolean
      shipping_methods:
        description: The Shipping Methods to send the additional Line Items with.
        type: array
        items:
          properties:
            data:
              description: An optional set of key-value pairs to hold additional information.
              type: object
            id:
              description: The ID of an existing Shipping Method
              type: string
            option_id:
              description: The ID of the Shipping Option to create a Shipping Method
                from
              type: string
            price:
              description: The price to charge for the Shipping Method
              type: integer
          type: object
  AdminPostOrdersOrderClaimsClaimShipmentsReq:
    required:
    - fulfillment_id
    type: object
    properties:
      fulfillment_id:
        description: The ID of the Fulfillment.
        type: string
      tracking_numbers:
        description: An array of tracking numbers for the shipment.
        type: array
        items:
          type: string
  AdminPostOrdersOrderClaimsReq:
    description: The details of the claim to be created.
    required:
    - type
    - claim_items
    type: object
    properties:
      additional_items:
        description: The new items to send to the Customer. This is only used if the
          claim's type is `replace`.
        type: array
        items:
          properties:
            quantity:
              description: The quantity of the Product Variant.
              type: integer
            variant_id:
              description: The ID of the Product Variant.
              type: string
          required:
          - variant_id
          - quantity
          type: object
      claim_items:
        description: The Claim Items that the Claim will consist of.
        type: array
        items:
          properties:
            images:
              description: A list of image URL's that will be associated with the
                Claim
              items:
                type: string
            item_id:
              description: The ID of the Line Item that will be claimed.
              type: string
            note:
              description: Short text describing the Claim Item in further detail.
              type: string
            quantity:
              description: The number of items that will be returned
              type: integer
            reason:
              description: The reason for the Claim
              enum:
              - missing_item
              - wrong_item
              - production_failure
              - other
              type: string
            tags:
              description: A list of tags to add to the Claim Item
              items:
                type: string
              type: array
          required:
          - item_id
          - quantity
          type: object
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      no_notification:
        description: If set to true no notification will be send related to this Claim.
        type: boolean
      refund_amount:
        description: The amount to refund the customer. This is used when the claim's
          type is `refund`.
        type: integer
      return_location_id:
        description: The ID of the location used for the associated return.
        type: string
      return_shipping:
        description: Optional details for the Return Shipping Method, if the items
          are to be sent back. Providing this field will result in a return being
          created and associated with the claim.
        type: object
        properties:
          option_id:
            description: The ID of the Shipping Option to create the Shipping Method
              from.
            type: string
          price:
            description: The price to charge for the Shipping Method.
            type: integer
      shipping_address:
        description: An optional shipping address to send the claimed items to. If
          not provided, the parent order's shipping address will be used.
        $ref: '#/components/schemas/AddressPayload'
      shipping_methods:
        description: The Shipping Methods to send the additional Line Items with.
          This is only used if the claim's type is `replace`.
        type: array
        items:
          properties:
            data:
              description: An optional set of key-value pairs to hold additional information.
              type: object
            id:
              description: The ID of an existing Shipping Method
              type: string
            option_id:
              description: The ID of the Shipping Option to create a Shipping Method
                from
              type: string
            price:
              description: The price to charge for the Shipping Method
              type: integer
          type: object
      type:
        description: 'The type of the Claim. This will determine how the Claim is
          treated: `replace` Claims will result in a Fulfillment with new items being
          created, while a `refund` Claim will refund the amount paid for the claimed
          items.'
        type: string
        enum:
        - replace
        - refund
  AdminPostOrdersOrderFulfillmentsReq:
    description: The details of the fulfillment to be created.
    required:
    - items
    type: object
    properties:
      items:
        description: The Line Items to include in the Fulfillment.
        type: array
        items:
          properties:
            item_id:
              description: The ID of the Line Item to fulfill.
              type: string
            quantity:
              description: The quantity of the Line Item to fulfill.
              type: integer
          required:
          - item_id
          - quantity
          type: object
      location_id:
        description: The ID of the location where the items will be fulfilled from.
        type: string
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      no_notification:
        description: If set to `true`, no notification will be sent to the customer
          related to this fulfillment.
        type: boolean
  AdminPostOrdersOrderRefundsReq:
    description: The details of the order refund.
    required:
    - amount
    - reason
    type: object
    properties:
      amount:
        description: The amount to refund. It should be less than or equal the `refundable_amount`
          of the order.
        type: integer
      no_notification:
        description: If set to `true`, no notification will be sent to the customer
          related to this Refund.
        type: boolean
      note:
        description: A note with additional details about the Refund.
        type: string
      reason:
        description: The reason for the Refund.
        type: string
  AdminPostOrdersOrderReq:
    description: The details to update of the order.
    type: object
    properties:
      billing_address:
        description: The order's billing address
        $ref: '#/components/schemas/AddressPayload'
      customer_id:
        description: The ID of the customer associated with the order.
        type: string
      discounts:
        description: The discounts applied to the order
        type: array
        items:
          $ref: '#/components/schemas/Discount'
      email:
        description: The email associated with the order
        type: string
      items:
        description: The line items of the order
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      no_notification:
        description: If set to `true`, no notification will be sent to the customer
          related to this order.
        type: boolean
      payment_method:
        description: The payment method chosen for the order.
        type: object
        properties:
          data:
            description: Any data relevant for the given payment method.
            type: object
          provider_id:
            description: The ID of the payment provider.
            type: string
      region:
        description: ID of the region that the order is associated with.
        type: string
      shipping_address:
        description: The order's shipping address
        $ref: '#/components/schemas/AddressPayload'
      shipping_method:
        description: The Shipping Method used for shipping the order.
        type: object
        properties:
          data:
            description: Any data relevant to the specific shipping method.
            type: object
          items:
            description: Items to ship
            type: array
            items:
              $ref: '#/components/schemas/LineItem'
          price:
            description: The price of the shipping.
            type: integer
          profile_id:
            description: The ID of the shipping profile.
            type: string
          provider_id:
            description: The ID of the shipping provider.
            type: string
  AdminPostOrdersOrderReturnsReq:
    description: The details of the requested return.
    required:
    - items
    type: object
    properties:
      items:
        description: The line items that will be returned.
        type: array
        items:
          properties:
            item_id:
              description: The ID of the Line Item.
              type: string
            note:
              description: An optional note with information about the Return.
              type: string
            quantity:
              description: The quantity of the Line Item.
              type: integer
            reason_id:
              description: The ID of the Return Reason to use.
              type: string
          required:
          - item_id
          - quantity
          type: object
      location_id:
        description: The ID of the location used for the return.
        type: string
      no_notification:
        description: If set to `true`, no notification will be sent to the customer
          related to this Return.
        type: boolean
      note:
        description: An optional note with information about the Return.
        type: string
      receive_now:
        description: A flag to indicate if the Return should be registerd as received
          immediately.
        type: boolean
      refund:
        description: The amount to refund.
        type: integer
      return_shipping:
        description: The Shipping Method to be used to handle the return shipment.
        type: object
        properties:
          option_id:
            description: The ID of the Shipping Option to create the Shipping Method
              from.
            type: string
          price:
            description: The price to charge for the Shipping Method.
            type: integer
  AdminPostOrdersOrderShipmentReq:
    description: The details of the shipment to create.
    required:
    - fulfillment_id
    type: object
    properties:
      fulfillment_id:
        description: The ID of the Fulfillment.
        type: string
      no_notification:
        description: If set to true no notification will be send related to this Shipment.
        type: boolean
      tracking_numbers:
        description: The tracking numbers for the shipment.
        type: array
        items:
          type: string
  AdminPostOrdersOrderShippingMethodsReq:
    description: The shipping method's details.
    required:
    - price
    - option_id
    type: object
    properties:
      data:
        description: The data required for the Shipping Option to create a Shipping
          Method. This depends on the Fulfillment Provider.
        type: object
      option_id:
        description: The ID of the Shipping Option to create the Shipping Method from.
        type: string
      price:
        description: The price (excluding VAT) that should be charged for the Shipping
          Method
        type: number
  AdminPostOrdersOrderSwapsReq:
    description: The details of the swap to create.
    required:
    - return_items
    type: object
    properties:
      additional_items:
        description: The new items to send to the Customer.
        type: array
        items:
          properties:
            quantity:
              description: The quantity of the Product Variant.
              type: integer
            variant_id:
              description: The ID of the Product Variant.
              type: string
          required:
          - variant_id
          - quantity
          type: object
      allow_backorder:
        description: If set to `true`, swaps can be completed with items out of stock
        type: boolean
      custom_shipping_options:
        description: An array of custom shipping options to potentially create a Shipping
          Method from to send the additional items.
        type: array
        items:
          properties:
            option_id:
              description: The ID of the Shipping Option.
              type: string
            price:
              description: The custom price of the Shipping Option.
              type: integer
          required:
          - option_id
          - price
          type: object
      no_notification:
        description: If set to `true`, no notification will be sent to the customer
          related to this Swap.
        type: boolean
      return_items:
        description: The Line Items to associate with the swap's return.
        type: array
        items:
          properties:
            item_id:
              description: The ID of the Line Item that will be returned.
              type: string
            note:
              description: An optional note with information about the Return.
              type: string
            quantity:
              description: The number of items that will be returned
              type: integer
            reason_id:
              description: The ID of the Return Reason to use.
              type: string
          required:
          - item_id
          - quantity
          type: object
      return_location_id:
        description: The ID of the location used for the associated return.
        type: string
      return_shipping:
        description: The shipping method associated with the swap's return.
        required:
        - option_id
        type: object
        properties:
          option_id:
            description: The ID of the Shipping Option to create the Shipping Method
              from.
            type: string
          price:
            description: The price to charge for the Shipping Method.
            type: integer
      sales_channel_id:
        description: The ID of the sales channel associated with the swap.
        type: string
  AdminPostPaymentRefundsReq:
    description: The details of the refund to create.
    required:
    - amount
    - reason
    type: object
    properties:
      amount:
        description: The amount to refund.
        type: integer
      note:
        description: A note with additional details about the Refund.
        type: string
      reason:
        description: The reason for the Refund.
        type: string
  AdminPostPriceListPricesPricesReq:
    description: The details of the prices to add.
    type: object
    properties:
      override:
        description: If set to `true`, the prices will replace all existing prices
          associated with the Price List.
        type: boolean
      prices:
        description: The prices to update or add.
        type: array
        items:
          properties:
            amount:
              description: The amount to charge for the Product Variant.
              type: integer
            currency_code:
              description: The 3 character ISO currency code for which the price will
                be used. This is only required if `region_id` is not provided.
              externalDocs:
                description: See a list of codes.
                url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
              type: string
            id:
              description: The ID of the price.
              type: string
            max_quantity:
              description: The maximum quantity for which the price will be used.
              type: integer
            min_quantity:
              description: The minimum quantity for which the price will be used.
              type: integer
            region_id:
              description: The ID of the Region for which the price is used. This
                is only required if `currecny_code` is not provided.
              type: string
            variant_id:
              description: The ID of the Variant for which the price is used.
              type: string
          required:
          - amount
          - variant_id
          type: object
  AdminPostPriceListsPriceListPriceListReq:
    description: The details to update of the payment collection.
    type: object
    properties:
      customer_groups:
        description: An array of customer groups that the Price List applies to.
        type: array
        items:
          properties:
            id:
              description: The ID of a customer group
              type: string
          required:
          - id
          type: object
      description:
        description: The description of the Price List.
        type: string
      ends_at:
        description: The date with timezone that the Price List ends being valid.
        type: string
        format: date
      includes_tax:
        description: Tax included in prices of price list
        type: boolean
      name:
        description: The name of the Price List
        type: string
      prices:
        description: The prices of the Price List.
        type: array
        items:
          properties:
            amount:
              description: The amount to charge for the Product Variant.
              type: integer
            currency_code:
              description: The 3 character ISO currency code for which the price will
                be used. This is only required if `region_id` is not provided.
              externalDocs:
                description: See a list of codes.
                url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
              type: string
            id:
              description: The ID of the price.
              type: string
            max_quantity:
              description: The maximum quantity for which the price will be used.
              type: integer
            min_quantity:
              description: The minimum quantity for which the price will be used.
              type: integer
            region_id:
              description: The ID of the Region for which the price is used. This
                is only required if `currecny_code` is not provided.
              type: string
            variant_id:
              description: The ID of the Variant for which the price is used.
              type: string
          required:
          - amount
          - variant_id
          type: object
      starts_at:
        description: The date with timezone that the Price List starts being valid.
        type: string
        format: date
      status:
        description: The status of the Price List. If the status is set to `draft`,
          the prices created in the price list will not be available of the customer.
        type: string
        enum:
        - active
        - draft
      type:
        description: The type of the Price List.
        type: string
        enum:
        - sale
        - override
  AdminPostPriceListsPriceListReq:
    description: The details of the price list to create.
    required:
    - name
    - description
    - type
    - prices
    type: object
    properties:
      customer_groups:
        description: An array of customer groups that the Price List applies to.
        type: array
        items:
          properties:
            id:
              description: The ID of a customer group
              type: string
          required:
          - id
          type: object
      description:
        description: The description of the Price List.
        type: string
      ends_at:
        description: The date with timezone that the Price List ends being valid.
        type: string
        format: date
      includes_tax:
        description: Tax included in prices of price list
        type: boolean
      name:
        description: The name of the Price List.
        type: string
      prices:
        description: The prices of the Price List.
        type: array
        items:
          properties:
            amount:
              description: The amount to charge for the Product Variant.
              type: integer
            currency_code:
              description: The 3 character ISO currency code for which the price will
                be used. This is only required if `region_id` is not provided.
              externalDocs:
                description: See a list of codes.
                url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
              type: string
            max_quantity:
              description: The maximum quantity for which the price will be used.
              type: integer
            min_quantity:
              description: The minimum quantity for which the price will be used.
              type: integer
            region_id:
              description: The ID of the Region for which the price is used. This
                is only required if `currecny_code` is not provided.
              type: string
            variant_id:
              description: The ID of the Variant for which the price is used.
              type: string
          required:
          - amount
          - variant_id
          type: object
      starts_at:
        description: The date with timezone that the Price List starts being valid.
        type: string
        format: date
      status:
        description: The status of the Price List. If the status is set to `draft`,
          the prices created in the price list will not be available of the customer.
        type: string
        enum:
        - active
        - draft
      type:
        description: The type of the Price List.
        type: string
        enum:
        - sale
        - override
  AdminPostProductCategoriesCategoryReq:
    description: The details to update of the product category.
    type: object
    properties:
      description:
        description: An optional text field to describe the Product Category by.
        type: string
      handle:
        description: A handle to be used in slugs.
        type: string
      is_active:
        description: A flag to make product category visible/hidden in the store front
        type: boolean
      is_internal:
        description: A flag to make product category an internal category for admins
        type: boolean
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      name:
        description: The name to identify the Product Category by.
        type: string
      parent_category_id:
        description: The ID of the parent product category
        type: string
      rank:
        description: The rank of the category in the tree node (starting from 0)
        type: number
  AdminPostProductCategoriesReq:
    description: The details of the product category to create.
    required:
    - name
    type: object
    properties:
      description:
        description: The description of the product category.
        type: string
      handle:
        description: The handle of the product category. If none is provided, the
          kebab-case version of the name will be used. This field can be used as a
          slug in URLs.
        type: string
      is_active:
        description: If set to `false`, the product category will not be available
          in the storefront.
        type: boolean
      is_internal:
        description: If set to `true`, the product category will only be available
          to admins.
        type: boolean
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      name:
        description: The name of the product category
        type: string
      parent_category_id:
        description: The ID of the parent product category
        type: string
  AdminPostProductsProductMetadataReq:
    required:
    - key
    - value
    type: object
    properties:
      key:
        description: The metadata key
        type: string
      value:
        description: The metadata value
        type: string
  AdminPostProductsProductOptionsReq:
    description: The details of the product option to create.
    required:
    - title
    type: object
    properties:
      title:
        description: The title the Product Option.
        type: string
        example: Size
  AdminPostProductsProductReq:
    description: The details to update of the product.
    type: object
    properties:
      categories:
        description: Product categories to add the Product to.
        type: array
        items:
          properties:
            id:
              description: The ID of a Product Category.
              type: string
          required:
          - id
      collection_id:
        description: The ID of the Product Collection the Product belongs to.
        type: string
      description:
        description: The description of the Product.
        type: string
      discountable:
        description: A flag to indicate if discounts can be applied to the Line Items
          generated from this Product
        type: boolean
      handle:
        description: A unique handle to identify the Product by. If not provided,
          the kebab-case version of the product title will be used. This can be used
          as a slug in URLs.
        type: string
      height:
        description: The height of the Product.
        type: number
      hs_code:
        description: The Harmonized System code of the product variant.
        type: string
      images:
        description: An array of images of the Product. Each value in the array is
          a URL to the image. You can use the upload API Routes to upload the image
          and obtain a URL.
        type: array
        items:
          type: string
      length:
        description: The length of the Product.
        type: number
      material:
        description: The material composition of the Product.
        type: string
      metadata:
        description: An optional set of key-value pairs with additional information.
        type: object
      mid_code:
        description: The Manufacturer Identification code of the Product.
        type: string
      origin_country:
        description: The country of origin of the Product.
        type: string
      sales_channels:
        description: Sales channels to associate the Product with.
        type: array
        items:
          properties:
            id:
              description: The ID of an existing Sales channel.
              type: string
          required:
          - id
          type: object
      status:
        description: The status of the product. The product is shown to the customer
          only if its status is `published`.
        type: string
        enum:
        - draft
        - proposed
        - published
        - rejected
      subtitle:
        description: The subtitle of the Product
        type: string
      tags:
        description: Product Tags to associate the Product with.
        type: array
        items:
          properties:
            id:
              description: The ID of an existing Product Tag. If not provided, a new
                product tag will be created.
              type: string
            value:
              description: The value of the Tag. If the `id` is provided, the value
                of the existing tag will be updated.
              type: string
          required:
          - value
          type: object
      thumbnail:
        description: The thumbnail to use for the Product. The value is a URL to the
          thumbnail. You can use the upload API Routes to upload the thumbnail and
          obtain a URL.
        type: string
      title:
        description: The title of the Product
        type: string
      type:
        description: The Product Type to associate the Product with.
        required:
        - value
        type: object
        properties:
          id:
            description: The ID of an existing Product Type. If not provided, a new
              product type will be created.
            type: string
          value:
            description: The value of the Product Type.
            type: string
      variants:
        description: An array of Product Variants to create with the Product. Each
          product variant must have a unique combination of Product Option values.
        type: array
        items:
          properties:
            allow_backorder:
              description: Whether the product variant can be purchased when out of
                stock.
              type: boolean
            barcode:
              description: A generic GTIN field of the product variant.
              type: string
            ean:
              description: The EAN number of the product variant.
              type: string
            height:
              description: The height of the product variant.
              type: number
            hs_code:
              description: The Harmonized System code of the product variant.
              type: string
            id:
              description: The id of an existing product variant. If provided, the
                details of the product variant will be updated. If not, a new product
                variant will be created.
              type: string
            inventory_quantity:
              description: The amount of stock kept of the product variant.
              type: integer
            length:
              description: The length of the product variant.
              type: number
            manage_inventory:
              description: Whether Medusa should keep track of the inventory of this
                product variant.
              type: boolean
            material:
              description: The material composition of the product variant.
              type: string
            metadata:
              description: An optional set of key-value pairs with additional information.
              externalDocs:
                description: Learn about the metadata attribute, and how to delete
                  and update it.
                url: https://docs.medusajs.com/development/entities/overview#metadata-attribute
              type: object
            mid_code:
              description: The Manufacturer Identification code of the product variant.
              type: string
            options:
              description: An array of Product Option values that the variant corresponds
                to.
              items:
                properties:
                  option_id:
                    description: The ID of the Option.
                    type: string
                  value:
                    description: The value of the Product Option.
                    type: string
                required:
                - option_id
                - value
                type: object
              type: array
            origin_country:
              description: The country of origin of the product variant.
              type: string
            prices:
              description: An array of product variant prices. A product variant can
                have different prices for each region or currency code.
              externalDocs:
                description: Product variant pricing.
                url: https://docs.medusajs.com/modules/products/admin/manage-products#product-variant-prices
              items:
                properties:
                  amount:
                    description: The price amount.
                    type: integer
                  currency_code:
                    description: The 3 character ISO currency code the price will
                      be used in. This is only required if `region_id` is not provided.
                    externalDocs:
                      description: See a list of codes.
                      url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
                    type: string
                  id:
                    description: The ID of the Price. If provided, the existing price
                      will be updated. Otherwise, a new price will be created.
                    type: string
                  max_quantity:
                    description: The maximum quantity required to be added to the
                      cart for the price to be used.
                    type: integer
                  min_quantity:
                    description: The minimum quantity required to be added to the
                      cart for the price to be used.
                    type: integer
                  region_id:
                    description: The ID of the Region the price will be used in. This
                      is only required if `currency_code` is not provided.
                    type: string
                required:
                - amount
                type: object
              type: array
            sku:
              description: The unique SKU of the product variant.
              type: string
            title:
              description: The title of the product variant.
              type: string
            upc:
              description: The UPC number of the product variant.
              type: string
            weight:
              description: The weight of the product variant.
              type: number
            width:
              description: The width of the product variant.
              type: number
          type: object
      weight:
        description: The weight of the Product.
        type: number
      width:
        description: The width of the Product.
        type: number
  AdminPostProductsProductVariantsReq:
    description: The details of the product variant to create.
    required:
    - title
    - prices
    - options
    type: object
    properties:
      allow_backorder:
        description: Whether the product variant can be purchased when out of stock.
        type: boolean
      barcode:
        description: A generic GTIN field of the product variant.
        type: string
      ean:
        description: The EAN number of the product variant.
        type: string
      height:
        description: The height of the product variant.
        type: number
      hs_code:
        description: The Harmonized System code of the product variant.
        type: string
      inventory_quantity:
        description: The amount of stock kept of the product variant.
        type: integer
      length:
        description: The length of the product variant.
        type: number
      manage_inventory:
        description: Whether Medusa should keep track of the inventory of this product
          variant.
        type: boolean
      material:
        description: The material composition of the product variant.
        type: string
      metadata:
        description: An optional set of key-value pairs with additional information.
        type: object
      mid_code:
        description: The Manufacturer Identification code of the product variant.
        type: string
      options:
        description: An array of Product Option values that the variant corresponds
          to.
        type: array
        items:
          properties:
            option_id:
              description: The ID of the Product Option.
              type: string
            value:
              description: A value to give to the Product Option.
              type: string
          required:
          - option_id
          - value
          type: object
      origin_country:
        description: The country of origin of the product variant.
        type: string
      prices:
        description: An array of product variant prices. A product variant can have
          different prices for each region or currency code.
        type: array
        items:
          properties:
            amount:
              description: The price amount.
              type: integer
            currency_code:
              description: The 3 character ISO currency code the price will be used
                in. This is only required if `region_id` is not provided.
              externalDocs:
                description: See a list of codes.
                url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
              type: string
            max_quantity:
              description: The maximum quantity required to be added to the cart for
                the price to be used.
              type: integer
            min_quantity:
              description: The minimum quantity required to be added to the cart for
                the price to be used.
              type: integer
            region_id:
              description: The ID of the Region the price will be used in. This is
                only required if `currency_code` is not provided.
              type: string
          required:
          - amount
          type: object
      sku:
        description: The unique SKU of the product variant.
        type: string
      title:
        description: The title of the product variant.
        type: string
      upc:
        description: The UPC number of the product variant.
        type: string
      weight:
        description: The wieght of the product variant.
        type: number
      width:
        description: The width of the product variant.
        type: number
  AdminPostProductsProductVariantsVariantReq:
    type: object
    properties:
      allow_backorder:
        description: Whether the product variant can be purchased when out of stock.
        type: boolean
      barcode:
        description: A generic GTIN field of the product variant.
        type: string
      ean:
        description: The EAN number of the item.
        type: string
      height:
        description: The height of the product variant.
        type: number
      hs_code:
        description: The Harmonized System code of the product variant.
        type: string
      inventory_quantity:
        description: The amount of stock kept of the product variant.
        type: integer
      length:
        description: The length of the product variant.
        type: number
      manage_inventory:
        description: Whether Medusa should keep track of the inventory of this product
          variant.
        type: boolean
      material:
        description: The material composition of the product variant.
        type: string
      metadata:
        description: An optional set of key-value pairs with additional information.
        type: object
      mid_code:
        description: The Manufacturer Identification code of the product variant.
        type: string
      options:
        description: An array of Product Option values that the variant corresponds
          to.
        type: array
        items:
          properties:
            option_id:
              description: The ID of the Product Option.
              type: string
            value:
              description: The value of the Product Option.
              type: string
          required:
          - option_id
          - value
          type: object
      origin_country:
        description: The country of origin of the product variant.
        type: string
      prices:
        description: An array of product variant prices. A product variant can have
          different prices for each region or currency code.
        type: array
        items:
          properties:
            amount:
              description: The price amount.
              type: integer
            currency_code:
              description: The 3 character ISO currency code the price will be used
                in. This is only required if `region_id` is not provided.
              externalDocs:
                description: See a list of codes.
                url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
              type: string
            id:
              description: The ID of the price. If provided, the existing price will
                be updated. Otherwise, a new price will be created.
              type: string
            max_quantity:
              description: The maximum quantity required to be added to the cart for
                the price to be used.
              type: integer
            min_quantity:
              description: The minimum quantity required to be added to the cart for
                the price to be used.
              type: integer
            region_id:
              description: The ID of the Region the price will be used in. This is
                only required if `currency_code` is not provided.
              type: string
          required:
          - amount
          type: object
      sku:
        description: The unique SKU of the product variant.
        type: string
      title:
        description: The title of the product variant.
        type: string
      upc:
        description: The UPC number of the item.
        type: string
      weight:
        description: The weight of the product variant.
        type: number
      width:
        description: The width of the product variant.
        type: number
  AdminPostProductsReq:
    description: The details of the product to create.
    required:
    - title
    type: object
    properties:
      categories:
        description: Product categories to add the Product to.
        type: array
        items:
          properties:
            id:
              description: The ID of a Product Category.
              type: string
          required:
          - id
          type: object
      collection_id:
        description: The ID of the Product Collection the Product belongs to.
        type: string
      description:
        description: The description of the Product.
        type: string
      discountable:
        description: A flag to indicate if discounts can be applied to the Line Items
          generated from this Product
        type: boolean
      handle:
        description: A unique handle to identify the Product by. If not provided,
          the kebab-case version of the product title will be used. This can be used
          as a slug in URLs.
        type: string
      height:
        description: The height of the Product.
        type: number
      hs_code:
        description: The Harmonized System code of the Product.
        type: string
      images:
        description: An array of images of the Product. Each value in the array is
          a URL to the image. You can use the upload API Routes to upload the image
          and obtain a URL.
        type: array
        items:
          type: string
      is_giftcard:
        description: A flag to indicate if the Product represents a Gift Card. Purchasing
          Products with this flag set to `true` will result in a Gift Card being created.
        type: boolean
      length:
        description: The length of the Product.
        type: number
      material:
        description: The material composition of the Product.
        type: string
      metadata:
        description: An optional set of key-value pairs with additional information.
        type: object
      mid_code:
        description: The Manufacturer Identification code of the Product.
        type: string
      options:
        description: The Options that the Product should have. A new product option
          will be created for every item in the array.
        type: array
        items:
          properties:
            title:
              description: The title of the Product Option.
              type: string
          required:
          - title
          type: object
      origin_country:
        description: The country of origin of the Product.
        type: string
      sales_channels:
        description: Sales channels to associate the Product with.
        type: array
        items:
          properties:
            id:
              description: The ID of an existing Sales channel.
              type: string
          required:
          - id
          type: object
      status:
        description: The status of the product. The product is shown to the customer
          only if its status is `published`.
        type: string
        enum:
        - draft
        - proposed
        - published
        - rejected
      subtitle:
        description: The subtitle of the Product
        type: string
      tags:
        description: Product Tags to associate the Product with.
        type: array
        items:
          properties:
            id:
              description: The ID of an existing Product Tag. If not provided, a new
                product tag will be created.
              type: string
            value:
              description: The value of the Tag. If the `id` is provided, the value
                of the existing tag will be updated.
              type: string
          required:
          - value
          type: object
      thumbnail:
        description: The thumbnail to use for the Product. The value is a URL to the
          thumbnail. You can use the upload API Routes to upload the thumbnail and
          obtain a URL.
        type: string
      title:
        description: The title of the Product
        type: string
      type:
        description: The Product Type to associate the Product with.
        required:
        - value
        type: object
        properties:
          id:
            description: The ID of an existing Product Type. If not provided, a new
              product type will be created.
            type: string
          value:
            description: The value of the Product Type.
            type: string
      variants:
        description: An array of Product Variants to create with the Product. Each
          product variant must have a unique combination of Product Option values.
        type: array
        items:
          properties:
            allow_backorder:
              description: Whether the Product Variant can be purchased when out of
                stock.
              type: boolean
            barcode:
              description: A generic GTIN field of the Product Variant.
              type: string
            ean:
              description: The EAN number of the item.
              type: string
            height:
              description: The height of the Product Variant.
              type: number
            hs_code:
              description: The Harmonized System code of the Product Variant.
              type: string
            inventory_quantity:
              default: 0
              description: The amount of stock kept of the Product Variant.
              type: integer
            length:
              description: The length of the Product Variant.
              type: number
            manage_inventory:
              description: Whether Medusa should keep track of the inventory of this
                Product Variant.
              type: boolean
            material:
              description: The material composition of the Product Variant.
              type: string
            metadata:
              description: An optional set of key-value pairs with additional information.
              externalDocs:
                description: Learn about the metadata attribute, and how to delete
                  and update it.
                url: https://docs.medusajs.com/development/entities/overview#metadata-attribute
              type: object
            mid_code:
              description: The Manufacturer Identification code of the Product Variant.
              type: string
            options:
              description: An array of Product Option values that the variant corresponds
                to. The option values should be added into the array in the same index
                as in the `options` field of the product.
              externalDocs:
                description: Example of how to create a product with options and variants
                url: https://docs.medusajs.com/modules/products/admin/manage-products#create-a-product
              items:
                properties:
                  value:
                    description: The value to give for the Product Option at the same
                      index in the Product's `options` field.
                    type: string
                required:
                - value
                type: object
              type: array
            origin_country:
              description: The country of origin of the Product Variant.
              type: string
            prices:
              description: An array of product variant prices. A product variant can
                have different prices for each region or currency code.
              externalDocs:
                description: Product variant pricing.
                url: https://docs.medusajs.com/modules/products/admin/manage-products#product-variant-prices
              items:
                properties:
                  amount:
                    description: The price amount.
                    type: integer
                  currency_code:
                    description: The 3 character ISO currency code the price will
                      be used in. This is only required if `region_id` is not provided.
                    externalDocs:
                      description: See a list of codes.
                      url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
                    type: string
                  max_quantity:
                    description: The maximum quantity required to be added to the
                      cart for the price to be used.
                    type: integer
                  min_quantity:
                    description: The minimum quantity required to be added to the
                      cart for the price to be used.
                    type: integer
                  region_id:
                    description: The ID of the Region the price will be used in. This
                      is only required if `currency_code` is not provided.
                    type: string
                required:
                - amount
                type: object
              type: array
            sku:
              description: The unique SKU of the Product Variant.
              type: string
            title:
              description: The title of the Product Variant.
              type: string
            upc:
              description: The UPC number of the item.
              type: string
            weight:
              description: The wieght of the Product Variant.
              type: number
            width:
              description: The width of the Product Variant.
              type: number
          required:
          - title
          type: object
      weight:
        description: The weight of the Product.
        type: number
      width:
        description: The width of the Product.
        type: number
  AdminPostProductsToCollectionReq:
    description: The details of the products to add to the collection.
    required:
    - product_ids
    type: object
    properties:
      product_ids:
        description: An array of Product IDs to add to the Product Collection.
        type: array
        items:
          description: The ID of a Product to add to the Product Collection.
          type: string
  AdminPostPublishableApiKeySalesChannelsBatchReq:
    description: The details of the sales channels to add to the publishable API key.
    required:
    - sales_channel_ids
    type: object
    properties:
      sales_channel_ids:
        description: The IDs of the sales channels to add to the publishable API key
        type: array
        items:
          properties:
            id:
              description: The ID of the sales channel
              type: string
          required:
          - id
          type: object
  AdminPostPublishableApiKeysPublishableApiKeyReq:
    description: The details to update of the publishable API key.
    type: object
    properties:
      title:
        description: The title of the Publishable API Key.
        type: string
  AdminPostPublishableApiKeysReq:
    description: The details of the publishable API key to create.
    required:
    - title
    type: object
    properties:
      title:
        description: The title of the publishable API key
        type: string
  AdminPostRegionsRegionCountriesReq:
    description: The details of the country to add to the region.
    required:
    - country_code
    type: object
    properties:
      country_code:
        description: The 2 character ISO code for the Country.
        type: string
  AdminPostRegionsRegionFulfillmentProvidersReq:
    description: The details of the fulfillment provider to add to the region.
    required:
    - provider_id
    type: object
    properties:
      provider_id:
        description: The ID of the Fulfillment Provider.
        type: string
  AdminPostRegionsRegionPaymentProvidersReq:
    description: The details of the payment provider to add to the region.
    required:
    - provider_id
    type: object
    properties:
      provider_id:
        description: The ID of the Payment Provider.
        type: string
  AdminPostRegionsRegionReq:
    description: The details to update of the regions.
    type: object
    properties:
      automatic_taxes:
        description: If set to `true`, the Medusa backend will automatically calculate
          taxes for carts in this region. If set to `false`, the taxes must be calculated
          manually.
        type: boolean
      countries:
        description: A list of countries' 2 ISO characters that should be included
          in the Region.
        type: array
        items:
          type: string
      currency_code:
        description: The 3 character ISO currency code to use in the Region.
        type: string
      fulfillment_providers:
        description: A list of Fulfillment Provider IDs that can be used in the Region
        type: array
        items:
          type: string
      gift_cards_taxable:
        description: If set to `true`, taxes will be applied on gift cards.
        type: boolean
      includes_tax:
        description: Whether taxes are included in the prices of the region.
        type: boolean
      name:
        description: The name of the Region
        type: string
      payment_providers:
        description: A list of Payment Provider IDs that can be used in the Region
        type: array
        items:
          type: string
      tax_code:
        description: The tax code of the Region.
        type: string
      tax_provider_id:
        description: The ID of the tax provider to use. If none provided, the system
          tax provider is used.
        type: string
      tax_rate:
        description: The tax rate to use in the Region.
        type: number
  AdminPostRegionsReq:
    description: The details of the region to create.
    required:
    - name
    - currency_code
    - tax_rate
    - payment_providers
    - fulfillment_providers
    - countries
    type: object
    properties:
      countries:
        description: A list of countries' 2 ISO characters that should be included
          in the Region.
        type: array
        items:
          type: string
        example:
        - US
      currency_code:
        description: The 3 character ISO currency code to use in the Region.
        type: string
      fulfillment_providers:
        description: A list of Fulfillment Provider IDs that can be used in the Region
        type: array
        items:
          type: string
      includes_tax:
        description: Whether taxes are included in the prices of the region.
        type: boolean
      name:
        description: The name of the Region
        type: string
      payment_providers:
        description: A list of Payment Provider IDs that can be used in the Region
        type: array
        items:
          type: string
      tax_code:
        description: The tax code of the Region.
        type: string
      tax_rate:
        description: The tax rate to use in the Region.
        type: number
  AdminPostReturnReasonsReasonReq:
    description: The details to update of the return reason.
    type: object
    properties:
      description:
        description: The description of the Reason.
        type: string
      label:
        description: The label to display to the Customer.
        type: string
      metadata:
        description: An optional set of key-value pairs with additional information.
        type: object
      value:
        description: A unique value of the return reason.
        type: string
  AdminPostReturnReasonsReq:
    description: The details of the return reason to create.
    required:
    - label
    - value
    type: object
    properties:
      description:
        description: The description of the Reason.
        type: string
      label:
        description: The label to display to the Customer.
        type: string
      metadata:
        description: An optional set of key-value pairs with additional information.
        type: object
      parent_return_reason_id:
        description: The ID of the parent return reason.
        type: string
      value:
        description: A unique value of the return reason.
        type: string
  AdminPostReturnsReturnReceiveReq:
    description: The details of the received return.
    required:
    - items
    type: object
    properties:
      items:
        description: The Line Items that have been received.
        type: array
        items:
          properties:
            item_id:
              description: The ID of the Line Item.
              type: string
            quantity:
              description: The quantity of the Line Item.
              type: integer
          required:
          - item_id
          - quantity
          type: object
      location_id:
        description: The ID of the location to return items from.
        type: string
      refund:
        description: The amount to refund.
        type: number
  AdminPostSalesChannelsChannelStockLocationsReq:
    required:
    - location_id
    type: object
    properties:
      location_id:
        description: The ID of the stock location
        type: string
  AdminPostSalesChannelsReq:
    description: The details of the sales channel to create.
    required:
    - name
    type: object
    properties:
      description:
        description: The description of the Sales Channel
        type: string
      is_disabled:
        description: Whether the Sales Channel is disabled.
        type: boolean
      name:
        description: The name of the Sales Channel
        type: string
  AdminPostSalesChannelsSalesChannelReq:
    description: The details to update of the sales channel.
    type: object
    properties:
      description:
        description: The description of the sales channel.
        type: string
      is_disabled:
        description: Whether the Sales Channel is disabled.
        type: boolean
      name:
        description: The name of the sales channel
        type: string
  AdminPostShippingOptionsOptionReq:
    description: The details to update of the shipping option.
    required:
    - requirements
    type: object
    properties:
      admin_only:
        description: If set to `true`, the shipping option can only be used when creating
          draft orders.
        type: boolean
      amount:
        description: The amount to charge for the Shipping Option. If the `price_type`
          of the shipping option is `calculated`, this amount will not actually be
          used.
        type: integer
      includes_tax:
        description: Tax included in prices of shipping option
        type: boolean
      metadata:
        description: An optional set of key-value pairs with additional information.
        type: object
      name:
        description: The name of the Shipping Option
        type: string
      requirements:
        description: The requirements that must be satisfied for the Shipping Option
          to be available.
        type: array
        items:
          properties:
            amount:
              description: The amount to compare with.
              type: integer
            id:
              description: The ID of an existing requirement. If an ID is passed,
                the existing requirement's details are updated. Otherwise, a new requirement
                is created.
              type: string
            type:
              description: The type of the requirement
              enum:
              - max_subtotal
              - min_subtotal
              type: string
          required:
          - type
          - amount
          type: object
  AdminPostShippingOptionsReq:
    description: The details of the shipping option to create.
    required:
    - name
    - region_id
    - provider_id
    - data
    - price_type
    type: object
    properties:
      admin_only:
        description: If set to `true`, the shipping option can only be used when creating
          draft orders.
        type: boolean
      amount:
        description: The amount to charge for the Shipping Option. If the `price_type`
          is set to `calculated`, this amount will not actually be used.
        type: integer
      data:
        description: The data needed for the Fulfillment Provider to handle shipping
          with this Shipping Option.
        type: object
      includes_tax:
        description: Tax included in prices of shipping option
        type: boolean
      is_return:
        description: Whether the Shipping Option can be used for returns or during
          checkout.
        type: boolean
      metadata:
        description: An optional set of key-value pairs with additional information.
        type: object
      name:
        description: The name of the Shipping Option
        type: string
      price_type:
        description: The type of the Shipping Option price. `flat_rate` indicates
          fixed pricing, whereas `calculated` indicates that the price will be calculated
          each time by the fulfillment provider.
        type: string
        enum:
        - flat_rate
        - calculated
      profile_id:
        description: The ID of the Shipping Profile to add the Shipping Option to.
        type: number
      provider_id:
        description: The ID of the Fulfillment Provider that handles the Shipping
          Option.
        type: string
      region_id:
        description: The ID of the Region in which the Shipping Option will be available.
        type: string
      requirements:
        description: The requirements that must be satisfied for the Shipping Option
          to be available.
        type: array
        items:
          properties:
            amount:
              description: The amount to compare with.
              type: integer
            type:
              description: The type of the requirement
              enum:
              - max_subtotal
              - min_subtotal
              type: string
          required:
          - type
          - amount
          type: object
  AdminPostShippingProfilesProfileReq:
    description: The detail to update of the shipping profile.
    type: object
    properties:
      metadata:
        description: An optional set of key-value pairs with additional information.
        type: object
      name:
        description: The name of the Shipping Profile
        type: string
      products:
        description: product IDs to associate with the Shipping Profile
        type: array
      shipping_options:
        description: Shipping option IDs to associate with the Shipping Profile
        type: array
      type:
        description: The type of the Shipping Profile
        type: string
        enum:
        - default
        - gift_card
        - custom
  AdminPostShippingProfilesReq:
    description: The details of the shipping profile to create.
    required:
    - name
    - type
    type: object
    properties:
      metadata:
        description: An optional set of key-value pairs with additional information.
        type: object
      name:
        description: The name of the Shipping Profile
        type: string
      type:
        description: The type of the Shipping Profile
        type: string
        enum:
        - default
        - gift_card
        - custom
  AdminPostStoreReq:
    description: The details to update of the store.
    type: object
    properties:
      currencies:
        description: Array of available currencies in the store. Each currency is
          in 3 character ISO code format.
        type: array
        items:
          externalDocs:
            description: See a list of codes.
            url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
          type: string
      default_currency_code:
        description: The default currency code of the Store.
        type: string
      invite_link_template:
        description: A template for invite links - use `{{invite_token}}` to insert
          the invite token
        type: string
        example: http://example.com/invite?token={{invite_token}}
      metadata:
        description: An optional set of key-value pairs with additional information.
        type: object
      name:
        description: The name of the Store
        type: string
      payment_link_template:
        description: A template for payment links - use `{{cart_id}}` to insert the
          Cart ID
        type: string
        example: http://example.com/payments/{{cart_id}}
      swap_link_template:
        description: A template for Swap links - use `{{cart_id}}` to insert the Swap
          Cart ID
        type: string
        example: http://example.com/swaps/{{cart_id}}
  AdminPostTaxRatesReq:
    description: The details of the tax rate to create.
    required:
    - code
    - name
    - region_id
    type: object
    properties:
      code:
        description: The code of the tax rate.
        type: string
      name:
        description: The name of the tax rate.
        type: string
      product_types:
        description: The IDs of the types of products associated with this tax rate
        type: array
        items:
          type: string
      products:
        description: The IDs of the products associated with this tax rate.
        type: array
        items:
          type: string
      rate:
        description: The numeric rate to charge.
        type: number
      region_id:
        description: The ID of the Region that the tax rate belongs to.
        type: string
      shipping_options:
        description: The IDs of the shipping options associated with this tax rate
        type: array
        items:
          type: string
  AdminPostTaxRatesTaxRateProductTypesReq:
    description: The product types to add to the tax rate.
    required:
    - product_types
    type: object
    properties:
      product_types:
        description: The IDs of the types of products to associate with this tax rate
        type: array
        items:
          type: string
  AdminPostTaxRatesTaxRateProductsReq:
    description: The details of the products to associat with the tax rate.
    required:
    - products
    type: object
    properties:
      products:
        description: The IDs of the products to associate with this tax rate
        type: array
        items:
          type: string
  AdminPostTaxRatesTaxRateReq:
    description: The details to update of the tax rate.
    type: object
    properties:
      code:
        description: The code of the tax rate.
        type: string
      name:
        description: The name of the tax rate.
        type: string
      product_types:
        description: The IDs of the types of product types associated with this tax
          rate
        type: array
        items:
          type: string
      products:
        description: The IDs of the products associated with this tax rate
        type: array
        items:
          type: string
      rate:
        description: The numeric rate to charge.
        type: number
      region_id:
        description: The ID of the Region that the tax rate belongs to.
        type: string
      shipping_options:
        description: The IDs of the shipping options associated with this tax rate
        type: array
        items:
          type: string
  AdminPostTaxRatesTaxRateShippingOptionsReq:
    description: The details of the shipping options to associate with the tax rate.
    required:
    - shipping_options
    type: object
    properties:
      shipping_options:
        description: The IDs of the shipping options to associate with this tax rate
        type: array
        items:
          type: string
  AdminPostUploadsDownloadUrlReq:
    description: The details of the file to retrieve its download URL.
    required:
    - file_key
    type: object
    properties:
      file_key:
        description: key of the file to obtain the download link for. This is obtained
          when you first uploaded the file, or by the file service if you used it
          directly.
        type: string
  AdminUpdatePaymentCollectionsReq:
    description: The details to update of the payment collection.
    type: object
    properties:
      description:
        description: A description to create or update the payment collection.
        type: string
      metadata:
        description: A set of key-value pairs to hold additional information.
        type: object
  AdminUpdateUserRequest:
    type: object
    properties:
      api_token:
        description: The API token of the User.
        type: string
      first_name:
        description: The first name of the User.
        type: string
      last_name:
        description: The last name of the User.
        type: string
      metadata:
        description: An optional set of key-value pairs with additional information.
        type: object
      role:
        description: The role assigned to the user. These roles don't provide any
          different privileges.
        type: string
        enum:
        - admin
        - member
        - developer
  AnyValue:
    description: 'Can be anything: string, number, array, object, etc., including
      `null`'
  Cart:
    description: A cart represents a virtual shopping bag. It can be used to complete
      an order, a swap, or a claim.
    required:
    - billing_address_id
    - completed_at
    - context
    - created_at
    - customer_id
    - deleted_at
    - email
    - id
    - idempotency_key
    - metadata
    - payment_authorized_at
    - payment_id
    - payment_session
    - region_id
    - shipping_address_id
    - type
    - updated_at
    type: object
    properties:
      billing_address:
        description: The details of the billing address associated with the cart.
        nullable: true
        $ref: '#/components/schemas/Address'
      billing_address_id:
        description: The billing address's ID
        nullable: true
        type: string
        example: addr_01G8ZH853YPY9B94857DY91YGW
      completed_at:
        description: The date with timezone at which the cart was completed.
        nullable: true
        type: string
        format: date-time
      context:
        description: The context of the cart which can include info like IP or user
          agent.
        nullable: true
        type: object
        example:
          ip: ::1
          user_agent: PostmanRuntime/7.29.2
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      customer:
        description: The details of the customer the cart belongs to.
        nullable: true
        $ref: '#/components/schemas/Customer'
      customer_id:
        description: The customer's ID
        nullable: true
        type: string
        example: cus_01G2SG30J8C85S4A5CHM2S1NS2
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      discount_total:
        description: The total of discount rounded
        type: integer
        example: 800
      discounts:
        description: An array of details of all discounts applied to the cart.
        type: array
        items:
          $ref: '#/components/schemas/Discount'
      email:
        description: The email associated with the cart
        nullable: true
        type: string
        format: email
      gift_card_tax_total:
        description: The total of gift cards with taxes
        type: integer
        example: 0
      gift_card_total:
        description: The total of gift cards
        type: integer
        example: 0
      gift_cards:
        description: An array of details of all gift cards applied to the cart.
        type: array
        items:
          $ref: '#/components/schemas/GiftCard'
      id:
        description: The cart's ID
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      idempotency_key:
        description: Randomly generated key used to continue the completion of a cart
          in case of failure.
        nullable: true
        type: string
      item_tax_total:
        description: The total of items with taxes
        type: integer
        example: 8000
      items:
        description: The line items added to the cart.
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      payment:
        description: The details of the payment associated with the cart.
        nullable: true
        $ref: '#/components/schemas/Payment'
      payment_authorized_at:
        description: The date with timezone at which the payment was authorized.
        nullable: true
        type: string
        format: date-time
      payment_id:
        description: The payment's ID if available
        nullable: true
        type: string
        example: pay_01G8ZCC5W42ZNY842124G7P5R9
      payment_session:
        description: The details of the selected payment session in the cart.
        nullable: true
        $ref: '#/components/schemas/PaymentSession'
      payment_sessions:
        description: The details of all payment sessions created on the cart.
        type: array
        items:
          $ref: '#/components/schemas/PaymentSession'
      raw_discount_total:
        description: The total of discount
        type: integer
        example: 800
      refundable_amount:
        description: The amount that can be refunded
        type: integer
        example: 8200
      refunded_total:
        description: The total amount refunded if the order associated with this cart
          is returned.
        type: integer
        example: 0
      region:
        description: The details of the region associated with the cart.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The region's ID
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      sales_channel:
        description: The details of the sales channel associated with the cart.
        nullable: true
        $ref: '#/components/schemas/SalesChannel'
      sales_channel_id:
        description: The sales channel ID the cart is associated with.
        nullable: true
        type: string
      sales_channels:
        description: The associated sales channels.
        nullable: true
        type: array
        items:
          $ref: '#/components/schemas/SalesChannel'
      shipping_address:
        description: The details of the shipping address associated with the cart.
        nullable: true
        $ref: '#/components/schemas/Address'
      shipping_address_id:
        description: The shipping address's ID
        nullable: true
        type: string
        example: addr_01G8ZH853YPY9B94857DY91YGW
      shipping_methods:
        description: The details of the shipping methods added to the cart.
        type: array
        items:
          $ref: '#/components/schemas/ShippingMethod'
      shipping_tax_total:
        description: The total of shipping with taxes
        type: integer
        example: 1000
      shipping_total:
        description: The total of shipping
        type: integer
        example: 1000
      subtotal:
        description: The subtotal of the cart
        type: integer
        example: 8000
      tax_total:
        description: The total of tax
        type: integer
        example: 0
      total:
        description: The total amount of the cart
        type: integer
        example: 8200
      type:
        description: The cart's type.
        type: string
        enum:
        - default
        - swap
        - draft_order
        - payment_link
        - claim
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ClaimItem:
    description: A claim item is an item created as part of a claim. It references
      an item in the order that should be exchanged or refunded.
    required:
    - claim_order_id
    - created_at
    - deleted_at
    - id
    - item_id
    - metadata
    - note
    - quantity
    - reason
    - updated_at
    - variant_id
    type: object
    properties:
      claim_order:
        description: The details of the claim this item belongs to.
        nullable: true
        $ref: '#/components/schemas/ClaimOrder'
      claim_order_id:
        description: The ID of the claim this item is associated with.
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The claim item's ID
        type: string
        example: citm_01G8ZH853Y6TFXWPG5EYE81X63
      images:
        description: The claim images that are attached to the claim item.
        type: array
        items:
          $ref: '#/components/schemas/ClaimImage'
      item:
        description: The details of the line item in the original order that this
          claim item refers to.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      item_id:
        description: The ID of the line item that the claim item refers to.
        type: string
        example: item_01G8ZM25TN49YV9EQBE2NC27KC
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      note:
        description: An optional note about the claim, for additional information
        nullable: true
        type: string
        example: I don't like it.
      quantity:
        description: The quantity of the item that is being claimed; must be less
          than or equal to the amount purchased in the original order.
        type: integer
        example: 1
      reason:
        description: The reason for the claim
        type: string
        enum:
        - missing_item
        - wrong_item
        - production_failure
        - other
      tags:
        description: User defined tags for easy filtering and grouping.
        type: array
        items:
          $ref: '#/components/schemas/ClaimTag'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      variant:
        description: The details of the product variant to potentially replace the
          item in the original order.
        nullable: true
        $ref: '#/components/schemas/ProductVariant'
      variant_id:
        description: The ID of the product variant that is claimed.
        type: string
        example: variant_01G1G5V2MRX2V3PVSR2WXYPFB6
  ClaimOrder:
    description: A Claim represents a group of faulty or missing items. It consists
      of claim items that refer to items in the original order that should be replaced
      or refunded. It also includes details related to shipping and fulfillment.
    required:
    - canceled_at
    - created_at
    - deleted_at
    - fulfillment_status
    - id
    - idempotency_key
    - metadata
    - no_notification
    - order_id
    - payment_status
    - refund_amount
    - shipping_address_id
    - type
    - updated_at
    type: object
    properties:
      additional_items:
        description: The details of the new items to be shipped when the claim's type
          is `replace`
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      canceled_at:
        description: The date with timezone at which the claim was canceled.
        nullable: true
        type: string
        format: date-time
      claim_items:
        description: The details of the items that should be replaced or refunded.
        type: array
        items:
          $ref: '#/components/schemas/ClaimItem'
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      fulfillment_status:
        description: The claim's fulfillment status
        type: string
        enum:
        - not_fulfilled
        - partially_fulfilled
        - fulfilled
        - partially_shipped
        - shipped
        - partially_returned
        - returned
        - canceled
        - requires_action
      fulfillments:
        description: The fulfillments of the new items to be shipped
        type: array
        items:
          $ref: '#/components/schemas/Fulfillment'
      id:
        description: The claim's ID
        type: string
        example: claim_01G8ZH853Y6TFXWPG5EYE81X63
      idempotency_key:
        description: Randomly generated key used to continue the completion of the
          cart associated with the claim in case of failure.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      no_notification:
        description: Flag for describing whether or not notifications related to this
          should be send.
        nullable: true
        type: boolean
        example: false
      order:
        description: The details of the order that this claim was created for.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the claim comes from.
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      payment_status:
        description: The status of the claim's payment
        type: string
        enum:
        - na
        - not_refunded
        - refunded
      refund_amount:
        description: The amount that will be refunded in conjunction with the claim
        nullable: true
        type: integer
        example: 1000
      return_order:
        description: The details of the return associated with the claim if the claim's
          type is `replace`.
        nullable: true
        $ref: '#/components/schemas/Return'
      shipping_address:
        description: The details of the address that new items should be shipped to.
        nullable: true
        $ref: '#/components/schemas/Address'
      shipping_address_id:
        description: The ID of the address that the new items should be shipped to
        nullable: true
        type: string
        example: addr_01G8ZH853YPY9B94857DY91YGW
      shipping_methods:
        description: The details of the shipping methods that the claim order will
          be shipped with.
        type: array
        items:
          $ref: '#/components/schemas/ShippingMethod'
      type:
        description: The claim's type
        type: string
        enum:
        - refund
        - replace
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ClaimTag:
    description: Claim Tags are user defined tags that can be assigned to claim items
      for easy filtering and grouping.
    required:
    - created_at
    - deleted_at
    - id
    - metadata
    - updated_at
    - value
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The claim tag's ID
        type: string
        example: ctag_01G8ZCC5Y63B95V6B5SHBZ91S4
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value that the claim tag holds
        type: string
        example: Damaged
  CustomShippingOption:
    description: Custom Shipping Options are overridden Shipping Options. Admins can
      attach a Custom Shipping Option to a cart in order to set a custom price for
      a particular Shipping Option.
    required:
    - cart_id
    - created_at
    - deleted_at
    - id
    - metadata
    - price
    - shipping_option_id
    - updated_at
    type: object
    properties:
      cart:
        description: The details of the cart this shipping option belongs to.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the Cart that the custom shipping option is attached
          to
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The custom shipping option's ID
        type: string
        example: cso_01G8X99XNB77DMFBJFWX6DN9V9
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      price:
        description: The custom price set that will override the shipping option's
          original price
        type: integer
        example: 1000
      shipping_option:
        description: The details of the overridden shipping options.
        nullable: true
        $ref: '#/components/schemas/ShippingOption'
      shipping_option_id:
        description: The ID of the Shipping Option that the custom shipping option
          overrides
        type: string
        example: so_01G1G5V27GYX4QXNARRQCW1N8T
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  Discount:
    description: A discount can be applied to a cart for promotional purposes.
    required:
    - code
    - created_at
    - deleted_at
    - ends_at
    - id
    - is_disabled
    - is_dynamic
    - metadata
    - parent_discount_id
    - rule_id
    - starts_at
    - updated_at
    - usage_count
    - usage_limit
    - valid_duration
    type: object
    properties:
      code:
        description: A unique code for the discount - this will be used by the customer
          to apply the discount
        type: string
        example: 10DISC
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      ends_at:
        description: The time at which the discount can no longer be used.
        nullable: true
        type: string
        format: date-time
      id:
        description: The discount's ID
        type: string
        example: disc_01F0YESMW10MGHWJKZSDDMN0VN
      is_disabled:
        description: Whether the Discount has been disabled. Disabled discounts cannot
          be applied to carts
        type: boolean
        example: false
      is_dynamic:
        description: A flag to indicate if multiple instances of the discount can
          be generated. I.e. for newsletter discounts
        type: boolean
        example: false
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      parent_discount:
        description: The details of the parent discount that this discount was created
          from.
        nullable: true
        $ref: '#/components/schemas/Discount'
      parent_discount_id:
        description: The Discount that the discount was created from. This will always
          be a dynamic discount
        nullable: true
        type: string
        example: disc_01G8ZH853YPY9B94857DY91YGW
      regions:
        description: The details of the regions in which the Discount can be used.
        type: array
        items:
          $ref: '#/components/schemas/Region'
      rule:
        description: The details of the discount rule that defines how the discount
          will be applied to a cart..
        nullable: true
        $ref: '#/components/schemas/DiscountRule'
      rule_id:
        description: The ID of the discount rule that defines how the discount will
          be applied to a cart.
        nullable: true
        type: string
        example: dru_01F0YESMVK96HVX7N419E3CJ7C
      starts_at:
        description: The time at which the discount can be used.
        type: string
        format: date-time
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      usage_count:
        description: The number of times a discount has been used.
        type: integer
        example: 50
      usage_limit:
        description: The maximum number of times that a discount can be used.
        nullable: true
        type: integer
        example: 100
      valid_duration:
        description: Duration the discount runs between
        nullable: true
        type: string
        example: P3Y6M4DT12H30M5S
  DiscountCondition:
    description: Holds rule conditions for when a discount is applicable
    required:
    - created_at
    - deleted_at
    - discount_rule_id
    - id
    - metadata
    - operator
    - type
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      customer_groups:
        description: Customer groups associated with this condition if `type` is `customer_groups`.
        type: array
        items:
          $ref: '#/components/schemas/CustomerGroup'
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      discount_rule:
        description: The details of the discount rule associated with the condition.
        nullable: true
        $ref: '#/components/schemas/DiscountRule'
      discount_rule_id:
        description: The ID of the discount rule associated with the condition
        type: string
        example: dru_01F0YESMVK96HVX7N419E3CJ7C
      id:
        description: The discount condition's ID
        type: string
        example: discon_01G8X9A7ESKAJXG2H0E6F1MW7A
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      operator:
        description: The operator of the condition. `in` indicates that discountable
          resources are within the specified resources. `not_in` indicates that discountable
          resources are everything but the specified resources.
        type: string
        enum:
        - in
        - not_in
      product_collections:
        description: Product collections associated with this condition if `type`
          is `product_collections`.
        type: array
        items:
          $ref: '#/components/schemas/ProductCollection'
      product_tags:
        description: Product tags associated with this condition if `type` is `product_tags`.
        type: array
        items:
          $ref: '#/components/schemas/ProductTag'
      product_types:
        description: Product types associated with this condition if `type` is `product_types`.
        type: array
        items:
          $ref: '#/components/schemas/ProductType'
      products:
        description: products associated with this condition if `type` is `products`.
        type: array
        items:
          $ref: '#/components/schemas/Product'
      type:
        description: The type of the condition. The type affects the available resources
          associated with the condition. For example, if the type is `products`, that
          means the `products` relation will hold the products associated with this
          condition and other relations will be empty.
        type: string
        enum:
        - products
        - product_types
        - product_collections
        - product_tags
        - customer_groups
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  DiscountConditionCustomerGroup:
    description: Associates a discount condition with a customer group
    required:
    - condition_id
    - created_at
    - customer_group_id
    - metadata
    - updated_at
    type: object
    properties:
      condition_id:
        description: The ID of the Discount Condition
        type: string
        example: discon_01G8X9A7ESKAJXG2H0E6F1MW7A
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      customer_group:
        description: Available if the relation `customer_group` is expanded.
        nullable: true
        $ref: '#/components/schemas/CustomerGroup'
      customer_group_id:
        description: The ID of the Product Tag
        type: string
        example: cgrp_01G8ZH853Y6TFXWPG5EYE81X63
      discount_condition:
        description: Available if the relation `discount_condition` is expanded.
        nullable: true
        $ref: '#/components/schemas/DiscountCondition'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  DiscountConditionProduct:
    description: This represents the association between a discount condition and
      a product
    required:
    - condition_id
    - created_at
    - metadata
    - product_id
    - updated_at
    type: object
    properties:
      condition_id:
        description: The ID of the Discount Condition
        type: string
        example: discon_01G8X9A7ESKAJXG2H0E6F1MW7A
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      discount_condition:
        description: The details of the discount condition.
        nullable: true
        $ref: '#/components/schemas/DiscountCondition'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product:
        description: The details of the product.
        nullable: true
        $ref: '#/components/schemas/Product'
      product_id:
        description: The ID of the Product Tag
        type: string
        example: prod_01G1G5V2MBA328390B5AXJ610F
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  DiscountConditionProductCollection:
    description: This represents the association between a discount condition and
      a product collection
    required:
    - condition_id
    - created_at
    - metadata
    - product_collection_id
    - updated_at
    type: object
    properties:
      condition_id:
        description: The ID of the Discount Condition
        type: string
        example: discon_01G8X9A7ESKAJXG2H0E6F1MW7A
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      discount_condition:
        description: The details of the discount condition.
        nullable: true
        $ref: '#/components/schemas/DiscountCondition'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product_collection:
        description: The details of the product collection.
        nullable: true
        $ref: '#/components/schemas/ProductCollection'
      product_collection_id:
        description: The ID of the Product Collection
        type: string
        example: pcol_01F0YESBFAZ0DV6V831JXWH0BG
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  DiscountConditionProductTag:
    description: This represents the association between a discount condition and
      a product tag
    required:
    - condition_id
    - created_at
    - metadata
    - product_tag_id
    - updated_at
    type: object
    properties:
      condition_id:
        description: The ID of the Discount Condition
        type: string
        example: discon_01G8X9A7ESKAJXG2H0E6F1MW7A
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      discount_condition:
        description: The details of the discount condition.
        nullable: true
        $ref: '#/components/schemas/DiscountCondition'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product_tag:
        description: The details of the product tag.
        nullable: true
        $ref: '#/components/schemas/ProductTag'
      product_tag_id:
        description: The ID of the Product Tag
        type: string
        example: ptag_01F0YESHPZYY3H4SJ3A5918SBN
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  DiscountConditionProductType:
    description: This represents the association between a discount condition and
      a product type
    required:
    - condition_id
    - created_at
    - metadata
    - product_type_id
    - updated_at
    type: object
    properties:
      condition_id:
        description: The ID of the Discount Condition
        type: string
        example: discon_01G8X9A7ESKAJXG2H0E6F1MW7A
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      discount_condition:
        description: The details of the discount condition.
        nullable: true
        $ref: '#/components/schemas/DiscountCondition'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product_type:
        description: The details of the product type.
        nullable: true
        $ref: '#/components/schemas/ProductType'
      product_type_id:
        description: The ID of the Product Tag
        type: string
        example: ptyp_01G8X9A7ESKAJXG2H0E6F1MW7A
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  DiscountRule:
    description: A discount rule defines how a Discount is calculated when applied
      to a Cart.
    required:
    - allocation
    - created_at
    - deleted_at
    - description
    - id
    - metadata
    - type
    - updated_at
    - value
    type: object
    properties:
      allocation:
        description: The scope that the discount should apply to.
        nullable: true
        type: string
        enum:
        - total
        - item
        example: total
      conditions:
        description: The details of the discount conditions associated with the rule.
          They can be used to limit when the discount can be used.
        type: array
        items:
          $ref: '#/components/schemas/DiscountCondition'
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      description:
        description: A short description of the discount
        nullable: true
        type: string
        example: 10 Percent
      id:
        description: The discount rule's ID
        type: string
        example: dru_01F0YESMVK96HVX7N419E3CJ7C
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      type:
        description: The type of the Discount, can be `fixed` for discounts that reduce
          the price by a fixed amount, `percentage` for percentage reductions or `free_shipping`
          for shipping vouchers.
        type: string
        enum:
        - fixed
        - percentage
        - free_shipping
        example: percentage
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value that the discount represents; this will depend on the
          type of the discount
        type: integer
        example: 10
  DraftOrder:
    description: A draft order is created by an admin without direct involvement of
      the customer. Once its payment is marked as captured, it is transformed into
      an order.
    required:
    - canceled_at
    - cart_id
    - completed_at
    - created_at
    - display_id
    - id
    - idempotency_key
    - metadata
    - no_notification_order
    - order_id
    - status
    - updated_at
    type: object
    properties:
      canceled_at:
        description: The date the draft order was canceled at.
        nullable: true
        type: string
        format: date-time
      cart:
        description: The details of the cart associated with the draft order.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart associated with the draft order.
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      completed_at:
        description: The date the draft order was completed at.
        nullable: true
        type: string
        format: date-time
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      display_id:
        description: The draft order's display ID
        type: string
        example: 2
      id:
        description: The draft order's ID
        type: string
        example: dorder_01G8TJFKBG38YYFQ035MSVG03C
      idempotency_key:
        description: Randomly generated key used to continue the completion of the
          cart associated with the draft order in case of failure.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      no_notification_order:
        description: Whether to send the customer notifications regarding order updates.
        nullable: true
        type: boolean
        example: false
      order:
        description: The details of the order created from the draft order when its
          payment is captured.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order created from the draft order when its payment
          is captured.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      status:
        description: The status of the draft order. It's changed to `completed` when
          it's transformed to an order.
        type: string
        enum:
        - open
        - completed
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  Error:
    type: object
    properties:
      code:
        description: A slug code to indicate the type of the error.
        type: string
        enum:
        - invalid_state_error
        - invalid_request_error
        - api_error
        - unknown_error
      message:
        description: Description of the error that occurred.
        type: string
        example: first_name must be a string
      type:
        description: A slug indicating the type of the error.
        type: string
        enum:
        - QueryRunnerAlreadyReleasedError
        - TransactionAlreadyStartedError
        - TransactionNotStartedError
        - conflict
        - unauthorized
        - payment_authorization_error
        - duplicate_error
        - not_allowed
        - invalid_data
        - not_found
        - database_error
        - unexpected_state
        - invalid_argument
        - unknown_error
  Fulfillment:
    description: A Fulfillment is created once an admin can prepare the purchased
      goods. Fulfillments will eventually be shipped and hold information about how
      to track shipments. Fulfillments are created through a fulfillment provider,
      which typically integrates a third-party shipping service. Fulfillments can
      be associated with orders, claims, swaps, and returns.
    required:
    - canceled_at
    - claim_order_id
    - created_at
    - data
    - id
    - idempotency_key
    - location_id
    - metadata
    - no_notification
    - order_id
    - provider_id
    - shipped_at
    - swap_id
    - tracking_numbers
    - updated_at
    type: object
    properties:
      canceled_at:
        description: The date with timezone at which the Fulfillment was canceled.
        nullable: true
        type: string
        format: date-time
      claim_order:
        description: The details of the claim that the fulfillment may belong to.
        nullable: true
        $ref: '#/components/schemas/ClaimOrder'
      claim_order_id:
        description: The ID of the Claim that the Fulfillment belongs to.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      data:
        description: This contains all the data necessary for the Fulfillment provider
          to handle the fulfillment.
        type: object
        example: {}
      id:
        description: The fulfillment's ID
        type: string
        example: ful_01G8ZRTMQCA76TXNAT81KPJZRF
      idempotency_key:
        description: Randomly generated key used to continue the completion of the
          fulfillment in case of failure.
        nullable: true
        type: string
      items:
        description: The Fulfillment Items in the Fulfillment. These hold information
          about how many of each Line Item has been fulfilled.
        type: array
        items:
          $ref: '#/components/schemas/FulfillmentItem'
      location_id:
        description: The ID of the stock location the fulfillment will be shipped
          from
        nullable: true
        type: string
        example: sloc_01G8TJSYT9M6AVS5N4EMNFS1EK
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      no_notification:
        description: Flag for describing whether or not notifications related to this
          should be sent.
        nullable: true
        type: boolean
        example: false
      order:
        description: The details of the order that the fulfillment may belong to.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the Order that the Fulfillment belongs to.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      provider:
        description: The details of the fulfillment provider responsible for handling
          the fulfillment.
        nullable: true
        $ref: '#/components/schemas/FulfillmentProvider'
      provider_id:
        description: The ID of the Fulfillment Provider responsible for handling the
          fulfillment.
        type: string
        example: manual
      shipped_at:
        description: The date with timezone at which the Fulfillment was shipped.
        nullable: true
        type: string
        format: date-time
      swap:
        description: The details of the swap that the fulfillment may belong to.
        nullable: true
        $ref: '#/components/schemas/Swap'
      swap_id:
        description: The ID of the Swap that the Fulfillment belongs to.
        nullable: true
        type: string
      tracking_links:
        description: The Tracking Links that can be used to track the status of the
          Fulfillment. These will usually be provided by the Fulfillment Provider.
        type: array
        items:
          $ref: '#/components/schemas/TrackingLink'
      tracking_numbers:
        description: The tracking numbers that can be used to track the status of
          the fulfillment.
        type: array
        items:
          type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  FulfillmentItem:
    description: This represents the association between a Line Item and a Fulfillment.
    required:
    - fulfillment_id
    - item_id
    - quantity
    type: object
    properties:
      fulfillment:
        description: The details of the fulfillment.
        nullable: true
        $ref: '#/components/schemas/Fulfillment'
      fulfillment_id:
        description: The ID of the Fulfillment that the Fulfillment Item belongs to.
        type: string
        example: ful_01G8ZRTMQCA76TXNAT81KPJZRF
      item:
        description: The details of the line item.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      item_id:
        description: The ID of the Line Item that the Fulfillment Item references.
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      quantity:
        description: The quantity of the Line Item that is included in the Fulfillment.
        type: integer
        example: 1
  FulfillmentProvider:
    description: A fulfillment provider represents a fulfillment service installed
      in the Medusa backend, either through a plugin or backend customizations. It
      holds the fulfillment service's installation status.
    required:
    - id
    - is_installed
    type: object
    properties:
      id:
        description: The ID of the fulfillment provider as given by the fulfillment
          service.
        type: string
        example: manual
      is_installed:
        description: Whether the fulfillment service is installed in the current version.
          If a fulfillment service is no longer installed, the `is_installed` attribute
          is set to `false`.
        type: boolean
  GiftCard:
    description: Gift Cards are redeemable and represent a value that can be used
      towards the payment of an Order.
    required:
    - balance
    - code
    - created_at
    - deleted_at
    - ends_at
    - id
    - is_disabled
    - metadata
    - order_id
    - region_id
    - tax_rate
    - updated_at
    - value
    type: object
    properties:
      balance:
        description: The remaining value on the Gift Card.
        type: integer
        example: 10
      code:
        description: The unique code that identifies the Gift Card. This is used by
          the Customer to redeem the value of the Gift Card.
        type: string
        example: 3RFT-MH2C-Y4YZ-XMN4
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      ends_at:
        description: The time at which the Gift Card can no longer be used.
        nullable: true
        type: string
        format: date-time
      id:
        description: The gift card's ID
        type: string
        example: gift_01G8XKBPBQY2R7RBET4J7E0XQZ
      is_disabled:
        description: Whether the Gift Card has been disabled. Disabled Gift Cards
          cannot be applied to carts.
        type: boolean
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      order:
        description: The details of the order that the gift card was purchased in.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the gift card was purchased in.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      region:
        description: The details of the region this gift card is available in.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The ID of the region this gift card is available in.
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      tax_rate:
        description: The gift card's tax rate that will be applied on calculating
          totals
        nullable: true
        type: number
        example: 0
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value that the Gift Card represents.
        type: integer
        example: 10
  GiftCardTransaction:
    description: Gift Card Transactions are created once a Customer uses a Gift Card
      to pay for their Order.
    required:
    - amount
    - created_at
    - gift_card_id
    - id
    - is_taxable
    - order_id
    - tax_rate
    type: object
    properties:
      amount:
        description: The amount that was used from the Gift Card.
        type: integer
        example: 10
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      gift_card:
        description: The details of the gift card associated used in this transaction.
        nullable: true
        $ref: '#/components/schemas/GiftCard'
      gift_card_id:
        description: The ID of the Gift Card that was used in the transaction.
        type: string
        example: gift_01G8XKBPBQY2R7RBET4J7E0XQZ
      id:
        description: The gift card transaction's ID
        type: string
        example: gct_01G8X9A7ESKAJXG2H0E6F1MW7A
      is_taxable:
        description: Whether the transaction is taxable or not.
        nullable: true
        type: boolean
        example: false
      order:
        description: The details of the order that the gift card was used for payment.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the gift card was used for payment.
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      tax_rate:
        description: The tax rate of the transaction
        nullable: true
        type: number
        example: 0
  IdempotencyKey:
    description: Idempotency Key is used to continue a process in case of any failure
      that might occur.
    required:
    - created_at
    - id
    - idempotency_key
    - locked_at
    - recovery_point
    - response_code
    - response_body
    - request_method
    - request_params
    - request_path
    type: object
    properties:
      created_at:
        description: Date which the idempotency key was locked.
        type: string
        format: date-time
      id:
        description: The idempotency key's ID
        type: string
        example: ikey_01G8X9A7ESKAJXG2H0E6F1MW7A
      idempotency_key:
        description: The unique randomly generated key used to determine the state
          of a process.
        type: string
      locked_at:
        description: Date which the idempotency key was locked.
        nullable: true
        type: string
        format: date-time
      recovery_point:
        description: Where to continue from.
        type: string
      request_method:
        description: The method of the request
        nullable: true
        type: string
        example: POST
      request_params:
        description: The parameters passed to the request
        nullable: true
        type: object
        example:
          id: cart_01G8ZH853Y6TFXWPG5EYE81X63
      request_path:
        description: The request's path
        nullable: true
        type: string
        example: /store/carts/cart_01G8ZH853Y6TFXWPG5EYE81X63/complete
      response_body:
        description: The response's body
        nullable: true
        type: object
        example:
          id: cart_01G8ZH853Y6TFXWPG5EYE81X63
      response_code:
        description: The response's code.
        nullable: true
        type: string
        example: 200
  Invite:
    description: An invite is created when an admin user invites a new user to join
      the store's team. Once the invite is accepted, it's deleted.
    required:
    - accepted
    - created_at
    - deleted_at
    - expires_at
    - id
    - metadata
    - role
    - token
    - updated_at
    - user_email
    type: object
    properties:
      accepted:
        description: Whether the invite was accepted or not.
        type: boolean
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      expires_at:
        description: The date the invite expires at.
        type: string
        format: date-time
      id:
        description: The invite's ID
        type: string
        example: invite_01G8TKE4XYCTHSCK2GDEP47RE1
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      role:
        description: The user's role. These roles don't change the privileges of the
          user.
        nullable: true
        type: string
        enum:
        - admin
        - member
        - developer
      token:
        description: The token used to accept the invite.
        type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      user_email:
        description: The email of the user being invited.
        type: string
        format: email
  LineItem:
    description: Line Items are created when a product is added to a Cart. When Line
      Items are purchased they will get copied to the resulting order, swap, or claim,
      and can eventually be referenced in Fulfillments and Returns. Line items may
      also be used for order edits.
    required:
    - allow_discounts
    - cart_id
    - claim_order_id
    - created_at
    - description
    - fulfilled_quantity
    - has_shipping
    - id
    - is_giftcard
    - is_return
    - metadata
    - order_edit_id
    - order_id
    - original_item_id
    - quantity
    - returned_quantity
    - shipped_quantity
    - should_merge
    - swap_id
    - thumbnail
    - title
    - unit_price
    - updated_at
    - variant_id
    type: object
    properties:
      adjustments:
        description: The details of the item's adjustments, which are available when
          a discount is applied on the item.
        type: array
        items:
          $ref: '#/components/schemas/LineItemAdjustment'
      allow_discounts:
        description: Flag to indicate if the Line Item should be included when doing
          discount calculations.
        type: boolean
      cart:
        description: The details of the cart that the line item may belongs to.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart that the line item may belongs to.
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      claim_order:
        description: The details of the claim that the line item may belong to.
        nullable: true
        $ref: '#/components/schemas/ClaimOrder'
      claim_order_id:
        description: The ID of the claim that the line item may belong to.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      description:
        description: A more detailed description of the contents of the Line Item.
        nullable: true
        type: string
        example: One Size
      discount_total:
        description: The total of discount of the line item rounded
        type: integer
        example: 0
      fulfilled_quantity:
        description: The quantity of the Line Item that has been fulfilled.
        nullable: true
        type: integer
        example: 0
      gift_card_total:
        description: The total of the gift card of the line item
        type: integer
        example: 0
      has_shipping:
        description: Flag to indicate if the Line Item has fulfillment associated
          with it.
        nullable: true
        type: boolean
        example: false
      id:
        description: The line item's ID
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      includes_tax:
        description: Indicates if the line item unit_price include tax
        type: boolean
      is_giftcard:
        description: Flag to indicate if the Line Item is a Gift Card.
        type: boolean
      is_return:
        description: Is the item being returned
        type: boolean
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      order:
        description: The details of the order that the line item may belongs to.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_edit:
        description: The details of the order edit.
        nullable: true
        $ref: '#/components/schemas/OrderEdit'
      order_edit_id:
        description: The ID of the order edit that the item may belong to.
        nullable: true
        type: string
      order_id:
        description: The ID of the order that the line item may belongs to.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      original_item_id:
        description: The ID of the original line item. This is useful if the line
          item belongs to a resource that references an order, such as a return or
          an order edit.
        nullable: true
        type: string
      original_tax_total:
        description: The original tax total amount of the line item
        type: integer
        example: 0
      original_total:
        description: The original total amount of the line item
        type: integer
        example: 8000
      quantity:
        description: The quantity of the content in the Line Item.
        type: integer
        example: 1
      raw_discount_total:
        description: The total of discount of the line item
        type: integer
        example: 0
      refundable:
        description: The amount that can be refunded from the given Line Item. Takes
          taxes and discounts into consideration.
        type: integer
        example: 0
      returned_quantity:
        description: The quantity of the Line Item that has been returned.
        nullable: true
        type: integer
        example: 0
      shipped_quantity:
        description: The quantity of the Line Item that has been shipped.
        nullable: true
        type: integer
        example: 0
      should_merge:
        description: Flag to indicate if new Line Items with the same variant should
          be merged or added as an additional Line Item.
        type: boolean
      subtotal:
        description: The subtotal of the line item
        type: integer
        example: 8000
      swap:
        description: The details of the swap that the line item may belong to.
        nullable: true
        $ref: '#/components/schemas/Swap'
      swap_id:
        description: The ID of the swap that the line item may belong to.
        nullable: true
        type: string
      tax_lines:
        description: The details of the item's tax lines.
        type: array
        items:
          $ref: '#/components/schemas/LineItemTaxLine'
      tax_total:
        description: The total of tax of the line item
        type: integer
        example: 0
      thumbnail:
        description: A URL string to a small image of the contents of the Line Item.
        nullable: true
        type: string
        format: uri
        example: https://medusa-public-images.s3.eu-west-1.amazonaws.com/coffee-mug.png
      title:
        description: The title of the Line Item.
        type: string
        example: Medusa Coffee Mug
      total:
        description: The total amount of the line item
        type: integer
        example: 8000
      unit_price:
        description: The price of one unit of the content in the Line Item. This should
          be in the currency defined by the Cart/Order/Swap/Claim that the Line Item
          belongs to.
        type: integer
        example: 8000
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      variant:
        description: The details of the product variant that this item was created
          from.
        nullable: true
        $ref: '#/components/schemas/ProductVariant'
      variant_id:
        description: The id of the Product Variant contained in the Line Item.
        nullable: true
        type: string
        example: variant_01G1G5V2MRX2V3PVSR2WXYPFB6
  LineItemAdjustment:
    description: A Line Item Adjustment includes details on discounts applied on a
      line item.
    required:
    - amount
    - description
    - discount_id
    - id
    - item_id
    - metadata
    type: object
    properties:
      amount:
        description: The adjustment amount
        type: number
        example: 1000
      description:
        description: The line item's adjustment description
        type: string
        example: Adjusted item's price.
      discount:
        description: The details of the discount associated with the adjustment.
        nullable: true
        $ref: '#/components/schemas/Discount'
      discount_id:
        description: The ID of the discount associated with the adjustment
        nullable: true
        type: string
        example: disc_01F0YESMW10MGHWJKZSDDMN0VN
      id:
        description: The Line Item Adjustment's ID
        type: string
        example: lia_01G8TKE4XYCTHSCK2GDEP47RE1
      item:
        description: The details of the line item.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      item_id:
        description: The ID of the line item
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
  LineItemTaxLine:
    description: A Line Item Tax Line represents the taxes applied on a line item.
    required:
    - code
    - created_at
    - id
    - item_id
    - metadata
    - name
    - rate
    - updated_at
    type: object
    properties:
      code:
        description: A code to identify the tax type by
        nullable: true
        type: string
        example: tax01
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      id:
        description: The line item tax line's ID
        type: string
        example: litl_01G1G5V2DRX1SK6NQQ8VVX4HQ8
      item:
        description: The details of the line item.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      item_id:
        description: The ID of the line item
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: A human friendly name for the tax
        type: string
        example: Tax Example
      rate:
        description: The numeric rate to charge tax by
        type: number
        example: 10
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  MoneyAmount:
    description: A Money Amount represent a price amount, for example, a product variant's
      price or a price in a price list. Each Money Amount either has a Currency or
      Region associated with it to indicate the pricing in a given Currency or, for
      fully region-based pricing, the given price in a specific Region. If region-based
      pricing is used, the amount will be in the currency defined for the Region.
    required:
    - amount
    - created_at
    - currency_code
    - deleted_at
    - id
    - max_quantity
    - min_quantity
    - price_list_id
    - region_id
    - updated_at
    - variant_id
    type: object
    properties:
      amount:
        description: The amount in the smallest currecny unit (e.g. cents 100 cents
          to charge $1) that the Product Variant will cost.
        type: integer
        example: 100
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      currency:
        description: The details of the currency that the money amount may belong
          to.
        nullable: true
        $ref: '#/components/schemas/Currency'
      currency_code:
        description: The 3 character currency code that the money amount may belong
          to.
        type: string
        example: usd
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The money amount's ID
        type: string
        example: ma_01F0YESHRFQNH5S8Q0PK84YYZN
      max_quantity:
        description: The maximum quantity that the Money Amount applies to. If this
          value is not set, the Money Amount applies to all quantities.
        nullable: true
        type: integer
        example: 1
      min_quantity:
        description: The minimum quantity that the Money Amount applies to. If this
          value is not set, the Money Amount applies to all quantities.
        nullable: true
        type: integer
        example: 1
      price_list:
        description: The details of the price list that the money amount may belong
          to.
        nullable: true
        $ref: '#/components/schemas/PriceList'
      price_list_id:
        description: The ID of the price list that the money amount may belong to.
        nullable: true
        type: string
        example: pl_01G8X3CKJXCG5VXVZ87H9KC09W
      region:
        description: The details of the region that the money amount may belong to.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The region's ID
        nullable: true
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      variant:
        description: The details of the product variant that the money amount may
          belong to.
        nullable: true
        $ref: '#/components/schemas/ProductVariant'
      variant_id:
        description: The ID of the Product Variant contained in the Line Item.
        nullable: true
        type: string
        example: variant_01G1G5V2MRX2V3PVSR2WXYPFB6
  Note:
    description: A Note is an element that can be used in association with different
      resources to allow admin users to describe additional information. For example,
      they can be used to add additional information about orders.
    required:
    - author_id
    - created_at
    - deleted_at
    - id
    - metadata
    - resource_id
    - resource_type
    - updated_at
    - value
    type: object
    properties:
      author:
        description: The details of the user that created the note.
        nullable: true
        $ref: '#/components/schemas/User'
      author_id:
        description: The ID of the user that created the note.
        nullable: true
        type: string
        example: usr_01G1G5V26F5TB3GPAPNJ8X1S3V
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The note's ID
        type: string
        example: note_01G8TM8ENBMC7R90XRR1G6H26Q
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      resource_id:
        description: The ID of the resource that the Note refers to.
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      resource_type:
        description: The type of resource that the Note refers to.
        type: string
        example: order
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The contents of the note.
        type: string
        example: This order must be fulfilled on Monday
  Notification:
    description: A notification is an alert sent, typically to customers, using the
      installed Notification Provider as a reaction to internal events such as `order.placed`.
      Notifications can be resent.
    required:
    - created_at
    - customer_id
    - data
    - event_name
    - id
    - parent_id
    - provider_id
    - resource_type
    - resource_id
    - to
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      customer:
        description: The details of the customer that this notification was sent to.
        nullable: true
        $ref: '#/components/schemas/Customer'
      customer_id:
        description: The ID of the customer that this notification was sent to.
        nullable: true
        type: string
        example: cus_01G2SG30J8C85S4A5CHM2S1NS2
      data:
        description: The data that the Notification was sent with. This contains all
          the data necessary for the Notification Provider to initiate a resend.
        type: object
        example: {}
      event_name:
        description: The name of the event that the notification was sent for.
        nullable: true
        type: string
        example: order.placed
      id:
        description: The notification's ID
        type: string
        example: noti_01G53V9Y6CKMCGBM1P0X7C28RX
      parent_id:
        description: The notification's parent ID
        nullable: true
        type: string
        example: noti_01G53V9Y6CKMCGBM1P0X7C28RX
      parent_notification:
        description: The details of the parent notification.
        nullable: true
        $ref: '#/components/schemas/Notification'
      provider:
        description: The notification provider used to send the notification.
        nullable: true
        $ref: '#/components/schemas/NotificationProvider'
      provider_id:
        description: The ID of the notification provider used to send the notification.
        nullable: true
        type: string
        example: sengrid
      resends:
        description: The details of all resends of the notification.
        type: array
        items:
          $ref: '#/components/schemas/Notification'
      resource_id:
        description: The ID of the resource that the Notification refers to.
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      resource_type:
        description: The type of resource that the Notification refers to.
        type: string
        example: order
      to:
        description: The address that the Notification was sent to. This will usually
          be an email address, but can represent other addresses such as a chat bot
          user ID.
        type: string
        example: user@example.com
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  NotificationProvider:
    description: A notification provider represents a notification service installed
      in the Medusa backend, either through a plugin or backend customizations. It
      holds the notification service's installation status.
    required:
    - id
    - is_installed
    type: object
    properties:
      id:
        description: The ID of the notification provider as given by the notification
          service.
        type: string
        example: sendgrid
      is_installed:
        description: Whether the notification service is installed in the current
          version. If a notification service is no longer installed, the `is_installed`
          attribute is set to `false`.
        type: boolean
  Order:
    description: An order is a purchase made by a customer. It holds details about
      payment and fulfillment of the order. An order may also be created from a draft
      order, which is created by an admin user.
    required:
    - billing_address_id
    - canceled_at
    - cart_id
    - created_at
    - currency_code
    - customer_id
    - draft_order_id
    - display_id
    - email
    - external_id
    - fulfillment_status
    - id
    - idempotency_key
    - metadata
    - no_notification
    - object
    - payment_status
    - region_id
    - shipping_address_id
    - status
    - tax_rate
    - updated_at
    type: object
    properties:
      billing_address:
        description: The details of the billing address associated with the order.
        nullable: true
        $ref: '#/components/schemas/Address'
      billing_address_id:
        description: The ID of the billing address associated with the order
        nullable: true
        type: string
        example: addr_01G8ZH853YPY9B94857DY91YGW
      canceled_at:
        description: The date the order was canceled on.
        nullable: true
        type: string
        format: date-time
      cart:
        description: The details of the cart associated with the order.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart associated with the order
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      claims:
        description: The details of the claims created for the order.
        type: array
        items:
          $ref: '#/components/schemas/ClaimOrder'
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      currency:
        description: The details of the currency used in the order.
        nullable: true
        $ref: '#/components/schemas/Currency'
      currency_code:
        description: The 3 character currency code that is used in the order
        type: string
        example: usd
      customer:
        description: The details of the customer associated with the order.
        nullable: true
        $ref: '#/components/schemas/Customer'
      customer_id:
        description: The ID of the customer associated with the order
        type: string
        example: cus_01G2SG30J8C85S4A5CHM2S1NS2
      discount_total:
        description: The total of discount rounded
        type: integer
        example: 800
      discounts:
        description: The details of the discounts applied on the order.
        type: array
        items:
          $ref: '#/components/schemas/Discount'
      display_id:
        description: The order's display ID
        type: integer
        example: 2
      draft_order:
        description: The details of the draft order this order was created from.
        nullable: true
        $ref: '#/components/schemas/DraftOrder'
      draft_order_id:
        description: The ID of the draft order this order was created from.
        nullable: true
        type: string
      edits:
        description: The details of the order edits done on the order.
        type: array
        items:
          $ref: '#/components/schemas/OrderEdit'
      email:
        description: The email associated with the order
        type: string
        format: email
      external_id:
        description: The ID of an external order.
        nullable: true
        type: string
      fulfillment_status:
        description: The order's fulfillment status
        type: string
        enum:
        - not_fulfilled
        - partially_fulfilled
        - fulfilled
        - partially_shipped
        - shipped
        - partially_returned
        - returned
        - canceled
        - requires_action
      fulfillments:
        description: The details of the fulfillments created for the order.
        type: array
        items:
          $ref: '#/components/schemas/Fulfillment'
      gift_card_tax_total:
        description: The total of gift cards with taxes
        type: integer
        example: 0
      gift_card_total:
        description: The total of gift cards
        type: integer
        example: 0
      gift_card_transactions:
        description: The gift card transactions made in the order.
        type: array
        items:
          $ref: '#/components/schemas/GiftCardTransaction'
      gift_cards:
        description: The details of the gift card used in the order.
        type: array
        items:
          $ref: '#/components/schemas/GiftCard'
      id:
        description: The order's ID
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      idempotency_key:
        description: Randomly generated key used to continue the processing of the
          order in case of failure.
        nullable: true
        type: string
      item_tax_total:
        description: The tax total applied on items
        nullable: true
        type: integer
        example: 0
      items:
        description: The details of the line items that belong to the order.
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      no_notification:
        description: Flag for describing whether or not notifications related to this
          should be send.
        nullable: true
        type: boolean
        example: false
      paid_total:
        description: The total amount paid
        type: integer
        example: 8000
      payment_status:
        description: The order's payment status
        type: string
        enum:
        - not_paid
        - awaiting
        - captured
        - partially_refunded
        - refunded
        - canceled
        - requires_action
      payments:
        description: The details of the payments used in the order.
        type: array
        items:
          $ref: '#/components/schemas/Payment'
      raw_discount_total:
        description: The total of discount
        type: integer
        example: 800
      refundable_amount:
        description: The amount that can be refunded
        type: integer
        example: 8200
      refunded_total:
        description: The total amount refunded if the order is returned.
        type: integer
        example: 0
      refunds:
        description: The details of the refunds created for the order.
        type: array
        items:
          $ref: '#/components/schemas/Refund'
      region:
        description: The details of the region this order was created in.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The ID of the region this order was created in.
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      returnable_items:
        description: The details of the line items that are returnable as part of
          the order, swaps, or claims
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      returns:
        description: The details of the returns created for the order.
        type: array
        items:
          $ref: '#/components/schemas/Return'
      sales_channel:
        description: The details of the sales channel this order belongs to.
        nullable: true
        $ref: '#/components/schemas/SalesChannel'
      sales_channel_id:
        description: The ID of the sales channel this order belongs to.
        nullable: true
        type: string
      sales_channels:
        description: The associated sales channels.
        nullable: true
        type: array
        items:
          $ref: '#/components/schemas/SalesChannel'
      shipping_address:
        description: The details of the shipping address associated with the order.
        nullable: true
        $ref: '#/components/schemas/Address'
      shipping_address_id:
        description: The ID of the shipping address associated with the order
        nullable: true
        type: string
        example: addr_01G8ZH853YPY9B94857DY91YGW
      shipping_methods:
        description: The details of the shipping methods used in the order.
        type: array
        items:
          $ref: '#/components/schemas/ShippingMethod'
      shipping_tax_total:
        description: The tax total applied on shipping
        type: integer
        example: 1000
      shipping_total:
        description: The total of shipping
        nullable: true
        type: integer
        example: 1000
      status:
        description: The order's status
        type: string
        enum:
        - pending
        - completed
        - archived
        - canceled
        - requires_action
      subtotal:
        description: The subtotal of the order
        type: integer
        example: 8000
      swaps:
        description: The details of the swaps created for the order.
        type: array
        items:
          $ref: '#/components/schemas/Swap'
      tax_rate:
        description: The order's tax rate
        nullable: true
        type: number
        example: 0
      tax_total:
        description: The total of tax
        type: integer
        example: 0
      total:
        description: The total amount of the order
        type: integer
        example: 8200
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  OrderEdit:
    description: Order edit allows modifying items in an order, such as adding, updating,
      or deleting items from the original order. Once the order edit is confirmed,
      the changes are reflected on the original order.
    required:
    - canceled_at
    - canceled_by
    - confirmed_by
    - confirmed_at
    - created_at
    - created_by
    - declined_at
    - declined_by
    - declined_reason
    - id
    - internal_note
    - order_id
    - payment_collection_id
    - requested_at
    - requested_by
    - status
    - updated_at
    type: object
    properties:
      canceled_at:
        description: The date with timezone at which the edit was cancelled.
        nullable: true
        type: string
        format: date-time
      canceled_by:
        description: The unique identifier of the user or customer who cancelled the
          order edit.
        nullable: true
        type: string
      changes:
        description: The details of all the changes on the original order's line items.
        type: array
        items:
          $ref: '#/components/schemas/OrderItemChange'
      confirmed_at:
        description: The date with timezone at which the edit was confirmed.
        nullable: true
        type: string
        format: date-time
      confirmed_by:
        description: The unique identifier of the user or customer who confirmed the
          order edit.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      created_by:
        description: The unique identifier of the user or customer who created the
          order edit.
        type: string
      declined_at:
        description: The date with timezone at which the edit was declined.
        nullable: true
        type: string
        format: date-time
      declined_by:
        description: The unique identifier of the user or customer who declined the
          order edit.
        nullable: true
        type: string
      declined_reason:
        description: An optional note why  the order edit is declined.
        nullable: true
        type: string
      difference_due:
        description: The difference between the total amount of the order and total
          amount of edited order.
        type: integer
        example: 8200
      discount_total:
        description: The total of discount
        type: integer
        example: 800
      gift_card_tax_total:
        description: The total of the gift card tax amount
        type: integer
        example: 800
      gift_card_total:
        description: The total of the gift card amount
        type: integer
        example: 800
      id:
        description: The order edit's ID
        type: string
        example: oe_01G8TJSYT9M6AVS5N4EMNFS1EK
      internal_note:
        description: An optional note with additional details about the order edit.
        nullable: true
        type: string
        example: Included two more items B to the order.
      items:
        description: The details of the cloned items from the original order with
          the new changes. Once the order edit is confirmed, these line items are
          associated with the original order.
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      order:
        description: The details of the order that this order edit was created for.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that is edited
        type: string
        example: order_01G2SG30J8C85S4A5CHM2S1NS2
      payment_collection:
        description: The details of the payment collection used to authorize additional
          payment if necessary.
        nullable: true
        $ref: '#/components/schemas/PaymentCollection'
      payment_collection_id:
        description: The ID of the payment collection
        nullable: true
        type: string
        example: paycol_01G8TJSYT9M6AVS5N4EMNFS1EK
      requested_at:
        description: The date with timezone at which the edit was requested.
        nullable: true
        type: string
        format: date-time
      requested_by:
        description: The unique identifier of the user or customer who requested the
          order edit.
        nullable: true
        type: string
      shipping_total:
        description: The total of the shipping amount
        type: integer
        example: 800
      status:
        description: The status of the order edit.
        type: string
        enum:
        - confirmed
        - declined
        - requested
        - created
        - canceled
      subtotal:
        description: The total of subtotal
        type: integer
        example: 8000
      tax_total:
        description: The total of tax
        type: integer
        example: 0
      total:
        description: The total amount of the edited order.
        type: integer
        example: 8200
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  OrderItemChange:
    description: An order item change is a change made within an order edit to an
      order's items. These changes are not reflected on the original order until the
      order edit is confirmed.
    required:
    - created_at
    - deleted_at
    - id
    - line_item_id
    - order_edit_id
    - original_line_item_id
    - type
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The order item change's ID
        type: string
        example: oic_01G8TJSYT9M6AVS5N4EMNFS1EK
      line_item:
        description: The details of the resulting line item after the item change.
          This line item is then used in the original order once the order edit is
          confirmed.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      line_item_id:
        description: The ID of the cloned line item.
        nullable: true
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      order_edit:
        description: The details of the order edit the item change is associated with.
        nullable: true
        $ref: '#/components/schemas/OrderEdit'
      order_edit_id:
        description: The ID of the order edit
        type: string
        example: oe_01G2SG30J8C85S4A5CHM2S1NS2
      original_line_item:
        description: The details of the original line item this item change references.
          This is used if the item change updates or deletes the original item.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      original_line_item_id:
        description: The ID of the original line item in the order
        nullable: true
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      type:
        description: The order item change's status
        type: string
        enum:
        - item_add
        - item_remove
        - item_update
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  Payment:
    description: A payment is originally created from a payment session. Once a payment
      session is authorized, the payment is created to represent the authorized amount
      with a given payment method. Payments can be captured, canceled or refunded.
      Payments can be made towards orders, swaps, order edits, or other resources.
    required:
    - amount
    - amount_refunded
    - canceled_at
    - captured_at
    - cart_id
    - created_at
    - currency_code
    - data
    - id
    - idempotency_key
    - metadata
    - order_id
    - provider_id
    - swap_id
    - updated_at
    type: object
    properties:
      amount:
        description: The amount that the Payment has been authorized for.
        type: integer
        example: 100
      amount_refunded:
        description: The amount of the original Payment amount that has been refunded
          back to the Customer.
        type: integer
        example: 0
      canceled_at:
        description: The date with timezone at which the Payment was canceled.
        nullable: true
        type: string
        format: date-time
      captured_at:
        description: The date with timezone at which the Payment was captured.
        nullable: true
        type: string
        format: date-time
      cart:
        description: The details of the cart that the payment session was potentially
          created for.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart that the payment session was potentially created
          for.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      currency:
        description: The details of the currency of the payment.
        nullable: true
        $ref: '#/components/schemas/Currency'
      currency_code:
        description: The 3 character ISO currency code of the payment.
        type: string
        example: usd
      data:
        description: The data required for the Payment Provider to identify, modify
          and process the Payment. Typically this will be an object that holds an
          id to the external payment session, but can be an empty object if the Payment
          Provider doesn't hold any state.
        type: object
        example: {}
      id:
        description: The payment's ID
        type: string
        example: pay_01G2SJNT6DEEWDFNAJ4XWDTHKE
      idempotency_key:
        description: Randomly generated key used to continue the completion of a payment
          in case of failure.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      order:
        description: The details of the order that the payment session was potentially
          created for.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the payment session was potentially
          created for.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      provider_id:
        description: The id of the Payment Provider that is responsible for the Payment
        type: string
        example: manual
      swap:
        description: The details of the swap that this payment was potentially created
          for.
        nullable: true
        $ref: '#/components/schemas/Swap'
      swap_id:
        description: The ID of the swap that this payment was potentially created
          for.
        nullable: true
        type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  PaymentCollection:
    description: A payment collection allows grouping and managing a list of payments
      at one. This can be helpful when making additional payment for order edits or
      integrating installment payments.
    required:
    - amount
    - authorized_amount
    - created_at
    - created_by
    - currency_code
    - deleted_at
    - description
    - id
    - metadata
    - region_id
    - status
    - type
    - updated_at
    type: object
    properties:
      amount:
        description: Amount of the payment collection.
        type: integer
      authorized_amount:
        description: Authorized amount of the payment collection.
        nullable: true
        type: integer
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      created_by:
        description: The ID of the user that created the payment collection.
        type: string
      currency:
        description: The details of the currency this payment collection is associated
          with.
        nullable: true
        $ref: '#/components/schemas/Currency'
      currency_code:
        description: The three character ISO code for the currency this payment collection
          is associated with.
        type: string
        example: usd
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      description:
        description: Description of the payment collection
        nullable: true
        type: string
      id:
        description: The payment collection's ID
        type: string
        example: paycol_01G8TJSYT9M6AVS5N4EMNFS1EK
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      payment_sessions:
        description: The details of the payment sessions created as part of the payment
          collection.
        type: array
        items:
          $ref: '#/components/schemas/PaymentSession'
      payments:
        description: The details of the payments created as part of the payment collection.
        type: array
        items:
          $ref: '#/components/schemas/Payment'
      region:
        description: The details of the region this payment collection is associated
          with.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The ID of the region this payment collection is associated with.
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      status:
        description: The type of the payment collection
        type: string
        enum:
        - not_paid
        - awaiting
        - authorized
        - partially_authorized
        - canceled
      type:
        description: The type of the payment collection
        type: string
        enum:
        - order_edit
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  PaymentProvider:
    description: A payment provider represents a payment service installed in the
      Medusa backend, either through a plugin or backend customizations. It holds
      the payment service's installation status.
    required:
    - id
    - is_installed
    type: object
    properties:
      id:
        description: The ID of the payment provider as given by the payment service.
        type: string
        example: manual
      is_installed:
        description: Whether the payment service is installed in the current version.
          If a payment service is no longer installed, the `is_installed` attribute
          is set to `false`.
        type: boolean
  PaymentSession:
    description: A Payment Session is created when a Customer initilizes the checkout
      flow, and can be used to hold the state of a payment flow. Each Payment Session
      is controlled by a Payment Provider, which is responsible for the communication
      with external payment services. Authorized Payment Sessions will eventually
      get promoted to Payments to indicate that they are authorized for payment processing
      such as capture or refund. Payment sessions can also be used as part of payment
      collections.
    required:
    - amount
    - cart_id
    - created_at
    - data
    - id
    - is_initiated
    - is_selected
    - idempotency_key
    - payment_authorized_at
    - provider_id
    - status
    - updated_at
    type: object
    properties:
      amount:
        description: The amount that the Payment Session has been authorized for.
        nullable: true
        type: integer
        example: 100
      cart:
        description: The details of the cart that the payment session was created
          for.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart that the payment session was created for.
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      data:
        description: The data required for the Payment Provider to identify, modify
          and process the Payment Session. Typically this will be an object that holds
          an id to the external payment session, but can be an empty object if the
          Payment Provider doesn't hold any state.
        type: object
        example: {}
      id:
        description: The payment session's ID
        type: string
        example: ps_01G901XNSRM2YS3ASN9H5KG3FZ
      idempotency_key:
        description: Randomly generated key used to continue the completion of a cart
          in case of failure.
        nullable: true
        type: string
      is_initiated:
        description: A flag to indicate if a communication with the third party provider
          has been initiated.
        type: boolean
        example: true
      is_selected:
        description: A flag to indicate if the Payment Session has been selected as
          the method that will be used to complete the purchase.
        nullable: true
        type: boolean
        example: true
      payment_authorized_at:
        description: The date with timezone at which the Payment Session was authorized.
        nullable: true
        type: string
        format: date-time
      provider_id:
        description: The ID of the Payment Provider that is responsible for the Payment
          Session
        type: string
        example: manual
      status:
        description: Indicates the status of the Payment Session. Will default to
          `pending`, and will eventually become `authorized`. Payment Sessions may
          have the status of `requires_more` to indicate that further actions are
          to be completed by the Customer.
        type: string
        enum:
        - authorized
        - pending
        - requires_more
        - error
        - canceled
        example: pending
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  PostAuthReq:
    description: The admin's credentials used to log in.
    required:
    - email
    - password
    type: object
    properties:
      email:
        description: The user's email.
        type: string
        format: email
      password:
        description: The user's password.
        type: string
        format: password
  PostCustomersCustomerReq:
    description: The details of the customer to update.
    type: object
    properties:
      email:
        description: The Customer's email. You can't update the email of a registered
          customer.
        type: string
        format: email
      first_name:
        description: The Customer's first name.
        type: string
      groups:
        description: A list of customer groups to which the customer belongs.
        type: array
        items:
          properties:
            id:
              description: The ID of a customer group
              type: string
          required:
          - id
          type: object
      last_name:
        description: The Customer's last name.
        type: string
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      password:
        description: The Customer's password.
        type: string
        format: password
      phone:
        description: The Customer's phone number.
        type: string
  PostCustomersReq:
    description: The details of the customer to create.
    required:
    - email
    - first_name
    - last_name
    - password
    type: object
    properties:
      email:
        description: The customer's email.
        type: string
        format: email
      first_name:
        description: The customer's first name.
        type: string
      last_name:
        description: The customer's last name.
        type: string
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      password:
        description: The customer's password.
        type: string
        format: password
      phone:
        description: The customer's phone number.
        type: string
  PriceList:
    description: A Price List represents a set of prices that override the default
      price for one or more product variants.
    required:
    - created_at
    - deleted_at
    - description
    - ends_at
    - id
    - name
    - starts_at
    - status
    - type
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      customer_groups:
        description: The details of the customer groups that the Price List can apply
          to.
        type: array
        items:
          $ref: '#/components/schemas/CustomerGroup'
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      description:
        description: The price list's description
        type: string
        example: Prices for VIP customers
      ends_at:
        description: The date with timezone that the Price List stops being valid.
        nullable: true
        type: string
        format: date-time
      id:
        description: The price list's ID
        type: string
        example: pl_01G8X3CKJXCG5VXVZ87H9KC09W
      includes_tax:
        description: Whether the price list prices include tax
        type: boolean
      name:
        description: The price list's name
        type: string
        example: VIP Prices
      prices:
        description: The prices that belong to the price list, represented as a Money
          Amount.
        type: array
        items:
          $ref: '#/components/schemas/MoneyAmount'
      starts_at:
        description: The date with timezone that the Price List starts being valid.
        nullable: true
        type: string
        format: date-time
      status:
        description: The status of the Price List
        type: string
        enum:
        - active
        - draft
      type:
        description: The type of Price List. This can be one of either `sale` or `override`.
        type: string
        enum:
        - sale
        - override
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ProductCategory:
    description: A product category can be used to categorize products into a hierarchy
      of categories.
    required:
    - category_children
    - created_at
    - handle
    - id
    - is_active
    - is_internal
    - metadata
    - mpath
    - name
    - parent_category_id
    - updated_at
    type: object
    properties:
      category_children:
        description: The details of the category's children.
        type: array
        items:
          $ref: '#/components/schemas/ProductCategory'
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      description:
        description: The product category's description.
        type: string
      handle:
        description: A unique string that identifies the Product Category - can for
          example be used in slug structures.
        type: string
        example: regular-fit
      id:
        description: The product category's ID
        type: string
        example: pcat_01G2SG30J8C85S4A5CHM2S1NS2
      is_active:
        description: A flag to make product category visible/hidden in the store front
        type: boolean
      is_internal:
        description: A flag to make product category an internal category for admins
        type: boolean
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      mpath:
        description: A string for Materialized Paths - used for finding ancestors
          and descendents
        nullable: true
        type: string
        example: pcat_id1.pcat_id2.pcat_id3
      name:
        description: The product category's name
        type: string
        example: Regular Fit
      parent_category:
        description: The details of the parent of this category.
        nullable: true
        $ref: '#/components/schemas/ProductCategory'
      parent_category_id:
        description: The ID of the parent category.
        nullable: true
        type: string
      products:
        description: The details of the products that belong to this category.
        type: array
        items:
          $ref: '#/components/schemas/Product'
      rank:
        description: An integer that depicts the rank of category in a tree node
        type: integer
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ProductCollection:
    description: A Product Collection allows grouping together products for promotional
      purposes. For example, an admin can create a Summer collection, add products
      to it, and showcase it on the storefront.
    required:
    - created_at
    - deleted_at
    - handle
    - id
    - metadata
    - title
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      handle:
        description: A unique string that identifies the Product Collection - can
          for example be used in slug structures.
        nullable: true
        type: string
        example: summer-collection
      id:
        description: The product collection's ID
        type: string
        example: pcol_01F0YESBFAZ0DV6V831JXWH0BG
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      products:
        description: The details of the products that belong to this product collection.
        type: array
        items:
          $ref: '#/components/schemas/Product'
      title:
        description: The title that the Product Collection is identified by.
        type: string
        example: Summer Collection
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ProductOption:
    description: A Product Option defines properties that may vary between different
      variants of a Product. Common Product Options are "Size" and "Color". Admins
      are free to create any product options.
    required:
    - created_at
    - deleted_at
    - id
    - metadata
    - product_id
    - title
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The product option's ID
        type: string
        example: opt_01F0YESHQBZVKCEXJ24BS6PCX3
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product:
        description: The details of the product that this product option belongs to.
        nullable: true
        $ref: '#/components/schemas/Product'
      product_id:
        description: The ID of the product that this product option belongs to.
        type: string
        example: prod_01G1G5V2MBA328390B5AXJ610F
      title:
        description: The title that the Product Option is defined by (e.g. `Size`).
        type: string
        example: Size
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      values:
        description: The details of the values of the product option.
        type: array
        items:
          $ref: '#/components/schemas/ProductOptionValue'
  ProductOptionValue:
    description: An option value is one of the possible values of a Product Option.
      Product Variants specify a unique combination of product option values.
    required:
    - created_at
    - deleted_at
    - id
    - metadata
    - option_id
    - updated_at
    - value
    - variant_id
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The product option value's ID
        type: string
        example: optval_01F0YESHR7S6ECD03RF6W12DSJ
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      option:
        description: The details of the product option that the Product Option Value
          belongs to.
        nullable: true
        $ref: '#/components/schemas/ProductOption'
      option_id:
        description: The ID of the Product Option that the Product Option Value belongs
          to.
        type: string
        example: opt_01F0YESHQBZVKCEXJ24BS6PCX3
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value that the Product Variant has defined for the specific
          Product Option (e.g. if the Product Option is "Size" this value could be
          `Small`, `Medium` or `Large`).
        type: string
        example: large
      variant:
        description: The details of the product variant that uses this product option
          value.
        nullable: true
        $ref: '#/components/schemas/ProductVariant'
      variant_id:
        description: The ID of the product variant that uses this product option value.
        type: string
        example: variant_01G1G5V2MRX2V3PVSR2WXYPFB6
  ProductTag:
    description: A Product Tag can be added to Products for easy filtering and grouping.
    required:
    - created_at
    - deleted_at
    - id
    - metadata
    - updated_at
    - value
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The product tag's ID
        type: string
        example: ptag_01G8K2MTMG9168F2B70S1TAVK3
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value that the Product Tag represents
        type: string
        example: Pants
  ProductTaxRate:
    description: This represents the association between a tax rate and a product
      to indicate that the product is taxed in a way different than the default.
    required:
    - created_at
    - metadata
    - product_id
    - rate_id
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product:
        description: The details of the product.
        nullable: true
        $ref: '#/components/schemas/Product'
      product_id:
        description: The ID of the Product
        type: string
        example: prod_01G1G5V2MBA328390B5AXJ610F
      rate_id:
        description: The ID of the Tax Rate
        type: string
        example: txr_01G8XDBAWKBHHJRKH0AV02KXBR
      tax_rate:
        description: The details of the tax rate.
        nullable: true
        $ref: '#/components/schemas/TaxRate'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ProductType:
    description: A Product Type can be added to Products for filtering and reporting
      purposes.
    required:
    - created_at
    - deleted_at
    - id
    - metadata
    - updated_at
    - value
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The product type's ID
        type: string
        example: ptyp_01G8X9A7ESKAJXG2H0E6F1MW7A
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value that the Product Type represents.
        type: string
        example: Clothing
  ProductTypeTaxRate:
    description: This represents the association between a tax rate and a product
      type to indicate that the product type is taxed in a different way than the
      default.
    required:
    - created_at
    - metadata
    - product_type_id
    - rate_id
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product_type:
        description: The details of the product type.
        nullable: true
        $ref: '#/components/schemas/ProductType'
      product_type_id:
        description: The ID of the Product type
        type: string
        example: ptyp_01G8X9A7ESKAJXG2H0E6F1MW7A
      rate_id:
        description: The id of the Tax Rate
        type: string
        example: txr_01G8XDBAWKBHHJRKH0AV02KXBR
      tax_rate:
        description: The details of the tax rate.
        nullable: true
        $ref: '#/components/schemas/TaxRate'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ProductVariant:
    description: A Product Variant represents a Product with a specific set of Product
      Option configurations. The maximum number of Product Variants that a Product
      can have is given by the number of available Product Option combinations. A
      product must at least have one product variant.
    required:
    - allow_backorder
    - barcode
    - created_at
    - deleted_at
    - ean
    - height
    - hs_code
    - id
    - inventory_quantity
    - length
    - manage_inventory
    - material
    - metadata
    - mid_code
    - origin_country
    - product_id
    - sku
    - title
    - upc
    - updated_at
    - weight
    - width
    type: object
    properties:
      allow_backorder:
        description: Whether the Product Variant should be purchasable when `inventory_quantity`
          is 0.
        type: boolean
      barcode:
        description: A generic field for a GTIN number that can be used to identify
          the Product Variant.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      ean:
        description: An EAN barcode number that can be used to identify the Product
          Variant.
        nullable: true
        type: string
      height:
        description: The height of the Product Variant. May be used in shipping rate
          calculations.
        nullable: true
        type: number
      hs_code:
        description: The Harmonized System code of the Product Variant. May be used
          by Fulfillment Providers to pass customs information to shipping carriers.
        nullable: true
        type: string
      id:
        description: The product variant's ID
        type: string
        example: variant_01G1G5V2MRX2V3PVSR2WXYPFB6
      inventory_items:
        description: The details inventory items of the product variant.
        type: array
        items:
          $ref: '#/components/schemas/ProductVariantInventoryItem'
      inventory_quantity:
        description: The current quantity of the item that is stocked.
        type: integer
        example: 100
      length:
        description: The length of the Product Variant. May be used in shipping rate
          calculations.
        nullable: true
        type: number
      manage_inventory:
        description: Whether Medusa should manage inventory for the Product Variant.
        type: boolean
      material:
        description: The material and composition that the Product Variant is made
          of, May be used by Fulfillment Providers to pass customs information to
          shipping carriers.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      mid_code:
        description: The Manufacturers Identification code that identifies the manufacturer
          of the Product Variant. May be used by Fulfillment Providers to pass customs
          information to shipping carriers.
        nullable: true
        type: string
      options:
        description: The details of the product options that this product variant
          defines values for.
        type: array
        items:
          $ref: '#/components/schemas/ProductOptionValue'
      origin_country:
        description: The country in which the Product Variant was produced. May be
          used by Fulfillment Providers to pass customs information to shipping carriers.
        nullable: true
        type: string
      prices:
        description: The details of the prices of the Product Variant, each represented
          as a Money Amount. Each Money Amount represents a price in a given currency
          or a specific Region.
        type: array
        items:
          $ref: '#/components/schemas/MoneyAmount'
      product:
        description: The details of the product that the product variant belongs to.
        nullable: true
        $ref: '#/components/schemas/Product'
      product_id:
        description: The ID of the product that the product variant belongs to.
        type: string
        example: prod_01G1G5V2MBA328390B5AXJ610F
      purchasable:
        description: |
          Only used with the inventory modules.
          A boolean value indicating whether the Product Variant is purchasable.
          A variant is purchasable if:
            - inventory is not managed
            - it has no inventory items
            - it is in stock
            - it is backorderable.
        type: boolean
      sku:
        description: The unique stock keeping unit used to identify the Product Variant.
          This will usually be a unique identifer for the item that is to be shipped,
          and can be referenced across multiple systems.
        nullable: true
        type: string
        example: shirt-123
      title:
        description: A title that can be displayed for easy identification of the
          Product Variant.
        type: string
        example: Small
      upc:
        description: A UPC barcode number that can be used to identify the Product
          Variant.
        nullable: true
        type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      variant_rank:
        description: The ranking of this variant
        nullable: true
        type: number
      weight:
        description: The weight of the Product Variant. May be used in shipping rate
          calculations.
        nullable: true
        type: number
      width:
        description: The width of the Product Variant. May be used in shipping rate
          calculations.
        nullable: true
        type: number
  ProductVariantInventoryItem:
    description: A Product Variant Inventory Item links variants with inventory items
      and denotes the required quantity of the variant.
    required:
    - created_at
    - deleted_at
    - id
    - inventory_item_id
    - required_quantity
    - updated_at
    - variant_id
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The product variant inventory item's ID
        type: string
        example: pvitem_01G8X9A7ESKAJXG2H0E6F1MW7A
      inventory_item_id:
        description: The id of the inventory item
        type: string
      required_quantity:
        description: The quantity of an inventory item required for the variant.
        type: integer
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      variant:
        description: The details of the product variant.
        nullable: true
        $ref: '#/components/schemas/ProductVariant'
      variant_id:
        description: The id of the variant.
        type: string
  PublishableApiKey:
    description: A Publishable API key defines scopes that resources are available
      in. Then, it can be used in request to infer the resources without having to
      directly pass them. For example, a publishable API key can be associated with
      one or more sales channels. Then, when the publishable API key is passed in
      the header of a request, it is inferred what sales channel is being used without
      having to pass the sales channel as a query or body parameter of the request.
      Publishable API keys can only be used with sales channels, at the moment.
    required:
    - created_at
    - created_by
    - id
    - revoked_by
    - revoked_at
    - title
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      created_by:
        description: The unique identifier of the user that created the key.
        nullable: true
        type: string
        example: usr_01G1G5V26F5TB3GPAPNJ8X1S3V
      id:
        description: The key's ID
        type: string
        example: pk_01G1G5V27GYX4QXNARRQCW1N8T
      revoked_at:
        description: The date with timezone at which the key was revoked.
        nullable: true
        type: string
        format: date-time
      revoked_by:
        description: The unique identifier of the user that revoked the key.
        nullable: true
        type: string
        example: usr_01G1G5V26F5TB3GPAPNJ8X1S3V
      title:
        description: The key's title.
        type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  PublishableApiKeySalesChannel:
    description: This represents the association between the Publishable API keys
      and Sales Channels
    required:
    - publishable_key_id
    - sales_channel_id
    - created_at
    - updated_at
    - deleted_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The relation's ID
        type: string
        example: pksc_01G8X9A7ESKAJXG2H0E6F1MW7A
      publishable_key_id:
        description: The publishable API key's ID
        type: string
        example: pak_01G1G5V21KADXNGH29BJMAJ4B4
      sales_channel_id:
        description: The sales channel's ID
        type: string
        example: sc_01G1G5V21KADXNGH29BJMAJ4B4
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  Refund:
    description: A refund represents an amount of money transfered back to the customer
      for a given reason. Refunds may occur in relation to Returns, Swaps and Claims,
      but can also be initiated by an admin for an order.
    required:
    - amount
    - created_at
    - id
    - idempotency_key
    - metadata
    - note
    - order_id
    - payment_id
    - reason
    - updated_at
    type: object
    properties:
      amount:
        description: The amount that has be refunded to the Customer.
        type: integer
        example: 1000
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      id:
        description: The refund's ID
        type: string
        example: ref_01G1G5V27GYX4QXNARRQCW1N8T
      idempotency_key:
        description: Randomly generated key used to continue the completion of the
          refund in case of failure.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      note:
        description: An optional note explaining why the amount was refunded.
        nullable: true
        type: string
        example: I didn't like it
      order:
        description: The details of the order this refund was created for.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order this refund was created for.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      payment:
        description: The details of the payment associated with the refund.
        nullable: true
        $ref: '#/components/schemas/Payment'
      payment_id:
        description: The payment's ID, if available.
        nullable: true
        type: string
        example: pay_01G8ZCC5W42ZNY842124G7P5R9
      reason:
        description: The reason given for the Refund, will automatically be set when
          processed as part of a Swap, Claim or Return.
        type: string
        enum:
        - discount
        - return
        - swap
        - claim
        - other
        example: return
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  Region:
    description: A region holds settings specific to a geographical location, including
      the currency, tax rates, and fulfillment and payment providers. A Region can
      consist of multiple countries to accomodate common shopping settings across
      countries.
    required:
    - automatic_taxes
    - created_at
    - currency_code
    - deleted_at
    - gift_cards_taxable
    - id
    - metadata
    - name
    - tax_code
    - tax_provider_id
    - tax_rate
    - updated_at
    type: object
    properties:
      automatic_taxes:
        description: Whether taxes should be automated in this region.
        type: boolean
      countries:
        description: The details of the countries included in this region.
        type: array
        items:
          $ref: '#/components/schemas/Country'
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      currency:
        description: The details of the currency used in the region.
        nullable: true
        $ref: '#/components/schemas/Currency'
      currency_code:
        description: The three character currency code used in the region.
        type: string
        example: usd
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      fulfillment_providers:
        description: The details of the fulfillment providers that can be used to
          fulfill items of orders and similar resources in the region.
        type: array
        items:
          $ref: '#/components/schemas/FulfillmentProvider'
      gift_cards_taxable:
        description: Whether the gift cards are taxable or not in this region.
        type: boolean
      id:
        description: The region's ID
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      includes_tax:
        description: Whether the prices for the region include tax
        type: boolean
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: The name of the region as displayed to the customer. If the Region
          only has one country it is recommended to write the country name.
        type: string
        example: EU
      payment_providers:
        description: The details of the payment providers that can be used to process
          payments in the region.
        type: array
        items:
          $ref: '#/components/schemas/PaymentProvider'
      tax_code:
        description: The tax code used on purchases in the Region. This may be used
          by other systems for accounting purposes.
        nullable: true
        type: string
      tax_provider:
        description: The details of the tax provider used in the region.
        nullable: true
        $ref: '#/components/schemas/TaxProvider'
      tax_provider_id:
        description: The ID of the tax provider used in this region
        nullable: true
        type: string
      tax_rate:
        description: The tax rate that should be charged on purchases in the Region.
        type: number
        example: 0
      tax_rates:
        description: The details of the tax rates used in the region, aside from the
          default rate.
        type: array
        items:
          $ref: '#/components/schemas/TaxRate'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ResetPasswordRequest:
    description: The details of the password reset request.
    required:
    - token
    - password
    type: object
    properties:
      email:
        description: The User's email.
        type: string
        format: email
      password:
        description: The User's new password.
        type: string
        format: password
      token:
        description: The password-reset token generated when the password reset was
          requested.
        type: string
  ResetPasswordTokenRequest:
    description: The details of the password reset token request.
    required:
    - email
    type: object
    properties:
      email:
        description: The User's email.
        type: string
        format: email
  Return:
    description: A Return holds information about Line Items that a Customer wishes
      to send back, along with how the items will be returned. Returns can also be
      used as part of a Swap or a Claim.
    required:
    - claim_order_id
    - created_at
    - id
    - idempotency_key
    - location_id
    - metadata
    - no_notification
    - order_id
    - received_at
    - refund_amount
    - shipping_data
    - status
    - swap_id
    - updated_at
    type: object
    properties:
      claim_order:
        description: The details of the claim that the return may belong to.
        nullable: true
        $ref: '#/components/schemas/ClaimOrder'
      claim_order_id:
        description: The ID of the claim that the return may belong to.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      id:
        description: The return's ID
        type: string
        example: ret_01F0YET7XPCMF8RZ0Y151NZV2V
      idempotency_key:
        description: Randomly generated key used to continue the completion of the
          return in case of failure.
        nullable: true
        type: string
      items:
        description: The details of the items that the customer is returning.
        type: array
        items:
          $ref: '#/components/schemas/ReturnItem'
      location_id:
        description: The ID of the stock location the return will be added back.
        nullable: true
        type: string
        example: sloc_01G8TJSYT9M6AVS5N4EMNFS1EK
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      no_notification:
        description: When set to true, no notification will be sent related to this
          return.
        nullable: true
        type: boolean
        example: false
      order:
        description: The details of the order that the return was created for.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the return was created for.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      received_at:
        description: The date with timezone at which the return was received.
        nullable: true
        type: string
        format: date-time
      refund_amount:
        description: The amount that should be refunded as a result of the return.
        type: integer
        example: 1000
      shipping_data:
        description: Data about the return shipment as provided by the Fulfilment
          Provider that handles the return shipment.
        nullable: true
        type: object
        example: {}
      shipping_method:
        description: The details of the Shipping Method that will be used to send
          the Return back. Can be null if the Customer will handle the return shipment
          themselves.
        nullable: true
        $ref: '#/components/schemas/ShippingMethod'
      status:
        description: Status of the Return.
        type: string
        enum:
        - requested
        - received
        - requires_action
        - canceled
      swap:
        description: The details of the swap that the return may belong to.
        nullable: true
        $ref: '#/components/schemas/Swap'
      swap_id:
        description: The ID of the swap that the return may belong to.
        nullable: true
        type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ReturnItem:
    description: A return item represents a line item in an order that is to be returned.
      It includes details related to the return and the reason behind it.
    required:
    - is_requested
    - item_id
    - metadata
    - note
    - quantity
    - reason_id
    - received_quantity
    - requested_quantity
    - return_id
    type: object
    properties:
      is_requested:
        description: Whether the Return Item was requested initially or received unexpectedly
          in the warehouse.
        type: boolean
      item:
        description: The details of the line item in the original order to be returned.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      item_id:
        description: The ID of the Line Item that the Return Item references.
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      note:
        description: An optional note with additional details about the Return.
        nullable: true
        type: string
        example: I didn't like it.
      quantity:
        description: The quantity of the Line Item to be returned.
        type: integer
        example: 1
      reason:
        description: The details of the reason for returning the item.
        nullable: true
        $ref: '#/components/schemas/ReturnReason'
      reason_id:
        description: The ID of the reason for returning the item.
        nullable: true
        type: string
        example: rr_01G8X82GCCV2KSQHDBHSSAH5TQ
      received_quantity:
        description: The quantity that was received in the warehouse.
        nullable: true
        type: integer
        example: 1
      requested_quantity:
        description: The quantity that was originally requested to be returned.
        nullable: true
        type: integer
        example: 1
      return_id:
        description: The ID of the Return that the Return Item belongs to.
        type: string
        example: ret_01F0YET7XPCMF8RZ0Y151NZV2V
      return_order:
        description: Details of the Return that the Return Item belongs to.
        nullable: true
        $ref: '#/components/schemas/Return'
  ReturnReason:
    description: A Return Reason is a value defined by an admin. It can be used on
      Return Items in order to indicate why a Line Item was returned.
    required:
    - created_at
    - deleted_at
    - description
    - id
    - label
    - metadata
    - parent_return_reason_id
    - updated_at
    - value
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      description:
        description: A description of the Reason.
        nullable: true
        type: string
        example: Items that are damaged
      id:
        description: The return reason's ID
        type: string
        example: rr_01G8X82GCCV2KSQHDBHSSAH5TQ
      label:
        description: A text that can be displayed to the Customer as a reason.
        type: string
        example: Damaged goods
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      parent_return_reason:
        description: The details of the parent reason.
        nullable: true
        $ref: '#/components/schemas/ReturnReason'
      parent_return_reason_id:
        description: The ID of the parent reason.
        nullable: true
        type: string
      return_reason_children:
        description: The details of the child reasons.
        $ref: '#/components/schemas/ReturnReason'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value to identify the reason by.
        type: string
        example: damaged
  SalesChannelLocation:
    description: This represents the association between a sales channel and a stock
      locations.
    required:
    - created_at
    - deleted_at
    - id
    - location_id
    - sales_channel_id
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The Sales Channel Stock Location's ID
        type: string
        example: scloc_01G8X9A7ESKAJXG2H0E6F1MW7A
      location_id:
        description: The ID of the Location Stock.
        type: string
      sales_channel:
        description: The details of the sales channel the location is associated with.
        nullable: true
        $ref: '#/components/schemas/SalesChannel'
      sales_channel_id:
        description: The ID of the Sales Channel
        type: string
        example: sc_01G8X9A7ESKAJXG2H0E6F1MW7A
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ShippingMethod:
    description: A Shipping Method represents a way in which an Order or Return can
      be shipped. Shipping Methods are created from a Shipping Option, but may contain
      additional details that can be necessary for the Fulfillment Provider to handle
      the shipment. If the shipping method is created for a return, it may be associated
      with a claim or a swap that the return is part of.
    required:
    - cart_id
    - claim_order_id
    - data
    - id
    - order_id
    - price
    - return_id
    - shipping_option_id
    - swap_id
    type: object
    properties:
      cart:
        description: The details of the cart that the shipping method is used in.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart that the shipping method is used in.
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      claim_order:
        description: The details of the claim that the shipping method is used in.
        nullable: true
        $ref: '#/components/schemas/ClaimOrder'
      claim_order_id:
        description: The ID of the claim that the shipping method is used in.
        nullable: true
        type: string
      data:
        description: Additional data that the Fulfillment Provider needs to fulfill
          the shipment. This is used in combination with the Shipping Options data,
          and may contain information such as a drop point id.
        type: object
        example: {}
      id:
        description: The shipping method's ID
        type: string
        example: sm_01F0YET7DR2E7CYVSDHM593QG2
      includes_tax:
        description: Whether the shipping method price include tax
        type: boolean
      order:
        description: The details of the order that the shipping method is used in.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the shipping method is used in.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      price:
        description: The amount to charge for the Shipping Method. The currency of
          the price is defined by the Region that the Order that the Shipping Method
          belongs to is a part of.
        type: integer
        example: 200
      return_id:
        description: The ID of the return that the shipping method is used in.
        nullable: true
        type: string
      return_order:
        description: The details of the return that the shipping method is used in.
        nullable: true
        $ref: '#/components/schemas/Return'
      shipping_option:
        description: The details of the shipping option the method was created from.
        nullable: true
        $ref: '#/components/schemas/ShippingOption'
      shipping_option_id:
        description: The ID of the Shipping Option that the Shipping Method is built
          from.
        type: string
        example: so_01G1G5V27GYX4QXNARRQCW1N8T
      subtotal:
        description: The subtotal of the shipping
        type: integer
        example: 8000
      swap:
        description: The details of the swap that the shipping method is used in.
        nullable: true
        $ref: '#/components/schemas/Swap'
      swap_id:
        description: The ID of the swap that the shipping method is used in.
        nullable: true
        type: string
      tax_lines:
        description: The details of the tax lines applied on the shipping method.
        type: array
        items:
          $ref: '#/components/schemas/ShippingMethodTaxLine'
      tax_total:
        description: The total of tax
        type: integer
        example: 0
      total:
        description: The total amount of the shipping
        type: integer
        example: 8200
  ShippingOption:
    description: A Shipping Option represents a way in which an Order or Return can
      be shipped. Shipping Options have an associated Fulfillment Provider that will
      be used when the fulfillment of an Order is initiated. Shipping Options themselves
      cannot be added to Carts, but serve as a template for Shipping Methods. This
      distinction makes it possible to customize individual Shipping Methods with
      additional information.
    required:
    - admin_only
    - amount
    - created_at
    - data
    - deleted_at
    - id
    - is_return
    - metadata
    - name
    - price_type
    - profile_id
    - provider_id
    - region_id
    - updated_at
    type: object
    properties:
      admin_only:
        description: Flag to indicate if the Shipping Option usage is restricted to
          admin users.
        type: boolean
      amount:
        description: The amount to charge for shipping when the Shipping Option price
          type is `flat_rate`.
        nullable: true
        type: integer
        example: 200
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      data:
        description: The data needed for the Fulfillment Provider to identify the
          Shipping Option.
        type: object
        example: {}
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The shipping option's ID
        type: string
        example: so_01G1G5V27GYX4QXNARRQCW1N8T
      includes_tax:
        description: Whether the shipping option price include tax
        type: boolean
      is_return:
        description: Flag to indicate if the Shipping Option can be used for Return
          shipments.
        type: boolean
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: The name given to the Shipping Option - this may be displayed
          to the Customer.
        type: string
        example: PostFake Standard
      price_type:
        description: The type of pricing calculation that is used when creatin Shipping
          Methods from the Shipping Option. Can be `flat_rate` for fixed prices or
          `calculated` if the Fulfillment Provider can provide price calulations.
        type: string
        enum:
        - flat_rate
        - calculated
        example: flat_rate
      profile:
        description: The details of the shipping profile that the shipping option
          belongs to.
        nullable: true
        $ref: '#/components/schemas/ShippingProfile'
      profile_id:
        description: The ID of the Shipping Profile that the shipping option belongs
          to.
        type: string
        example: sp_01G1G5V239ENSZ5MV4JAR737BM
      provider:
        description: The details of the fulfillment provider that will be used to
          later to process the shipping method created from this shipping option and
          its fulfillments.
        nullable: true
        $ref: '#/components/schemas/FulfillmentProvider'
      provider_id:
        description: The ID of the fulfillment provider that will be used to later
          to process the shipping method created from this shipping option and its
          fulfillments.
        type: string
        example: manual
      region:
        description: The details of the region this shipping option can be used in.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The ID of the region this shipping option can be used in.
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      requirements:
        description: The details of the requirements that must be satisfied for the
          Shipping Option to be available for usage in a Cart.
        type: array
        items:
          $ref: '#/components/schemas/ShippingOptionRequirement'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ShippingOptionRequirement:
    description: A shipping option requirement defines conditions that a Cart must
      satisfy for the Shipping Option to be available for usage in the Cart.
    required:
    - amount
    - deleted_at
    - id
    - shipping_option_id
    - type
    type: object
    properties:
      amount:
        description: The amount to compare the Cart subtotal to.
        type: integer
        example: 100
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The shipping option requirement's ID
        type: string
        example: sor_01G1G5V29AB4CTNDRFSRWSRKWD
      shipping_option:
        description: The details of the shipping option that the requirements belong
          to.
        nullable: true
        $ref: '#/components/schemas/ShippingOption'
      shipping_option_id:
        description: The ID of the shipping option that the requirements belong to.
        type: string
        example: so_01G1G5V27GYX4QXNARRQCW1N8T
      type:
        description: The type of the requirement, this defines how the value will
          be compared to the Cart's total. `min_subtotal` requirements define the
          minimum subtotal that is needed for the Shipping Option to be available,
          while the `max_subtotal` defines the maximum subtotal that the Cart can
          have for the Shipping Option to be available.
        type: string
        enum:
        - min_subtotal
        - max_subtotal
        example: min_subtotal
  ShippingProfile:
    description: A Shipping Profile has a set of defined Shipping Options that can
      be used to fulfill a given set of Products. For example, gift cards are shipped
      differently than physical products, so a shipping profile with the type `gift_card`
      groups together the shipping options that can only be used for gift cards.
    required:
    - created_at
    - deleted_at
    - id
    - metadata
    - name
    - type
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The shipping profile's ID
        type: string
        example: sp_01G1G5V239ENSZ5MV4JAR737BM
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: The name given to the Shipping profile - this may be displayed
          to the Customer.
        type: string
        example: Default Shipping Profile
      products:
        description: The details of the products that the Shipping Profile defines
          Shipping Options for. Available if the relation `products` is expanded.
        type: array
        items:
          $ref: '#/components/schemas/Product'
      shipping_options:
        description: The details of the shipping options that can be used to create
          shipping methods for the Products in the Shipping Profile.
        type: array
        items:
          $ref: '#/components/schemas/ShippingOption'
      type:
        description: The type of the Shipping Profile, may be `default`, `gift_card`
          or `custom`.
        type: string
        enum:
        - default
        - gift_card
        - custom
        example: default
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ShippingTaxRate:
    description: This represents the tax rates applied on a shipping option.
    required:
    - created_at
    - metadata
    - rate_id
    - shipping_option_id
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      rate_id:
        description: The ID of the associated tax rate.
        type: string
        example: txr_01G8XDBAWKBHHJRKH0AV02KXBR
      shipping_option:
        description: The details of the shipping option.
        nullable: true
        $ref: '#/components/schemas/ShippingOption'
      shipping_option_id:
        description: The ID of the shipping option.
        type: string
        example: so_01G1G5V27GYX4QXNARRQCW1N8T
      tax_rate:
        description: The details of the associated tax rate.
        nullable: true
        $ref: '#/components/schemas/TaxRate'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  StagedJob:
    description: A staged job resource
    required:
    - data
    - event_name
    - id
    - options
    type: object
    properties:
      data:
        description: Data necessary for the job
        type: object
        example: {}
      event_name:
        description: The name of the event
        type: string
        example: order.placed
      id:
        description: The staged job's ID
        type: string
        example: job_01F0YET7BZTARY9MKN1SJ7AAXF
      option:
        description: The staged job's option
        type: object
        example: {}
  Swap:
    description: A swap can be created when a Customer wishes to exchange Products
      that they have purchased with different Products. It consists of a Return of
      previously purchased Products and a Fulfillment of new Products. It also includes
      information on any additional payment or refund required based on the difference
      between the exchanged products.
    required:
    - allow_backorder
    - canceled_at
    - cart_id
    - confirmed_at
    - created_at
    - deleted_at
    - difference_due
    - fulfillment_status
    - id
    - idempotency_key
    - metadata
    - no_notification
    - order_id
    - payment_status
    - shipping_address_id
    - updated_at
    type: object
    properties:
      additional_items:
        description: The details of the new products to send to the customer, represented
          as line items.
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      allow_backorder:
        description: If true, swaps can be completed with items out of stock
        type: boolean
      canceled_at:
        description: The date with timezone at which the Swap was canceled.
        nullable: true
        type: string
        format: date-time
      cart:
        description: The details of the cart that the customer uses to complete the
          swap.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart that the customer uses to complete the swap.
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      confirmed_at:
        description: The date with timezone at which the Swap was confirmed by the
          Customer.
        nullable: true
        type: string
        format: date-time
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      difference_due:
        description: The difference amount between the order’s original total and
          the new total imposed by the swap. If its value is negative, a refund must
          be issues to the customer. If it's positive, additional payment must be
          authorized by the customer. Otherwise, no payment processing is required.
        nullable: true
        type: integer
        example: 0
      fulfillment_status:
        description: The status of the Fulfillment of the Swap.
        type: string
        enum:
        - not_fulfilled
        - fulfilled
        - shipped
        - partially_shipped
        - canceled
        - requires_action
        example: not_fulfilled
      fulfillments:
        description: The details of the fulfillments that are used to send the new
          items to the customer.
        type: array
        items:
          $ref: '#/components/schemas/Fulfillment'
      id:
        description: The swap's ID
        type: string
        example: swap_01F0YET86Y9G92D3YDR9Y6V676
      idempotency_key:
        description: Randomly generated key used to continue the completion of the
          swap in case of failure.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      no_notification:
        description: If set to true, no notification will be sent related to this
          swap
        nullable: true
        type: boolean
        example: false
      order:
        description: The details of the order that the swap belongs to.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the swap belongs to.
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      payment:
        description: The details of the additional payment authorized by the customer
          when `difference_due` is positive.
        nullable: true
        $ref: '#/components/schemas/Payment'
      payment_status:
        description: The status of the Payment of the Swap. The payment may either
          refer to the refund of an amount or the authorization of a new amount.
        type: string
        enum:
        - not_paid
        - awaiting
        - captured
        - confirmed
        - canceled
        - difference_refunded
        - partially_refunded
        - refunded
        - requires_action
        example: not_paid
      return_order:
        description: The details of the return that belongs to the swap, which holds
          the details on the items being returned.
        nullable: true
        $ref: '#/components/schemas/Return'
      shipping_address:
        description: The details of the shipping address that the new items should
          be sent to.
        nullable: true
        $ref: '#/components/schemas/Address'
      shipping_address_id:
        description: The Address to send the new Line Items to - in most cases this
          will be the same as the shipping address on the Order.
        nullable: true
        type: string
        example: addr_01G8ZH853YPY9B94857DY91YGW
      shipping_methods:
        description: The details of the shipping methods used to fulfill the additional
          items purchased.
        type: array
        items:
          $ref: '#/components/schemas/ShippingMethod'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  TaxLine:
    description: A tax line represents the taxes amount applied to a line item.
    required:
    - code
    - created_at
    - id
    - metadata
    - name
    - rate
    - updated_at
    type: object
    properties:
      code:
        description: A code to identify the tax type by
        nullable: true
        type: string
        example: tax01
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      id:
        description: The tax line's ID
        type: string
        example: tl_01G1G5V2DRX1SK6NQQ8VVX4HQ8
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: A human friendly name for the tax
        type: string
        example: Tax Example
      rate:
        description: The numeric rate to charge tax by
        type: number
        example: 10
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  TaxProvider:
    description: A tax provider represents a tax service installed in the Medusa backend,
      either through a plugin or backend customizations. It holds the tax service's
      installation status.
    required:
    - id
    - is_installed
    type: object
    properties:
      id:
        description: The ID of the tax provider as given by the tax service.
        type: string
        example: manual
      is_installed:
        description: Whether the tax service is installed in the current version.
          If a tax service is no longer installed, the `is_installed` attribute is
          set to `false`.
        type: boolean
  TaxRate:
    description: A Tax Rate can be used to define a custom rate to charge on specified
      products, product types, and shipping options within a given region.
    required:
    - code
    - created_at
    - id
    - metadata
    - name
    - rate
    - region_id
    - updated_at
    type: object
    properties:
      code:
        description: A code to identify the tax type by
        nullable: true
        type: string
        example: tax01
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      id:
        description: The tax rate's ID
        type: string
        example: txr_01G8XDBAWKBHHJRKH0AV02KXBR
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: A human friendly name for the tax
        type: string
        example: Tax Example
      product_count:
        description: The count of products
        type: integer
        example: 10
      product_type_count:
        description: The count of product types
        type: integer
        example: 2
      product_types:
        description: The details of the product types that belong to this tax rate.
        type: array
        items:
          $ref: '#/components/schemas/ProductType'
      products:
        description: The details of the products that belong to this tax rate.
        type: array
        items:
          $ref: '#/components/schemas/Product'
      rate:
        description: The numeric rate to charge
        nullable: true
        type: number
        example: 10
      region:
        description: The details of the region that the rate belongs to.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The ID of the region that the rate belongs to.
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      shipping_option_count:
        description: The count of shipping options
        type: integer
        example: 1
      shipping_options:
        description: The details of the shipping options that belong to this tax rate.
        type: array
        items:
          $ref: '#/components/schemas/ShippingOption'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  TrackingLink:
    description: A tracking link holds information about tracking numbers for a Fulfillment.
      Tracking Links can optionally contain a URL that can be visited to see the status
      of the shipment. Typically, the tracking link is provided from the third-party
      service integrated through the used fulfillment provider.
    required:
    - created_at
    - deleted_at
    - fulfillment_id
    - id
    - idempotency_key
    - metadata
    - tracking_number
    - updated_at
    - url
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      fulfillment:
        description: The details of the fulfillment that the tracking link belongs
          to.
        nullable: true
        $ref: '#/components/schemas/Fulfillment'
      fulfillment_id:
        description: The ID of the fulfillment that the tracking link belongs to.
        type: string
        example: ful_01G8ZRTMQCA76TXNAT81KPJZRF
      id:
        description: The tracking link's ID
        type: string
        example: tlink_01G8ZH853Y6TFXWPG5EYE81X63
      idempotency_key:
        description: Randomly generated key used to continue the completion of a process
          in case of failure.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      tracking_number:
        description: The tracking number given by the shipping carrier.
        type: string
        format: RH370168054CN
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      url:
        description: The URL at which the status of the shipment can be tracked.
        nullable: true
        type: string
        format: uri
  User:
    description: A User is an administrator who can manage store settings and data.
    required:
    - api_token
    - created_at
    - deleted_at
    - email
    - first_name
    - id
    - last_name
    - metadata
    - role
    - updated_at
    type: object
    properties:
      api_token:
        description: An API token associated with the user.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      email:
        description: The email of the User
        type: string
        format: email
      first_name:
        description: The first name of the User
        nullable: true
        type: string
        example: Levi
      id:
        description: The user's ID
        type: string
        example: usr_01G1G5V26F5TB3GPAPNJ8X1S3V
      last_name:
        description: The last name of the User
        nullable: true
        type: string
        example: Bogan
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      role:
        description: The user's role. These roles don't provide any different privileges.
        type: string
        enum:
        - admin
        - member
        - developer
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  examples:
    database_error:
      summary: Database Error
      value:
        code: api_error
        message: An error occured while hashing password
        type: database_error
    default_error:
      summary: Default Error
      value:
        code: unknown_error
        message: An unknown error occurred.
        type: unknown_error
    invalid_argument_error:
      summary: Invalid Argument Error
      value:
        message: cart.total must be defined
        type: unexpected_state
    invalid_data_error:
      summary: Invalid Data Error
      value:
        message: first_name must be a string
        type: invalid_data
    multiple_errors:
      summary: Multiple Errors
      value:
        errors:
        - message: first_name must be a string
          type: invalid_data
        - message: Discount must be set to dynamic
          type: not_allowed
        message: Provided request body contains errors. Please check the data and
          retry the request
    not_allowed_error:
      summary: Not Allowed Error
      value:
        message: Discount must be set to dynamic
        type: not_allowed
    unexpected_state_error:
      summary: Unexpected State Error
      value:
        message: cart.total must be defined
        type: unexpected_state
  responses:
    400_error:
      content:
        application/json:
          examples:
            MultipleErrors:
              $ref: '#/components/examples/multiple_errors'
            invalid_data:
              $ref: '#/components/examples/invalid_data_error'
            not_allowed:
              $ref: '#/components/examples/not_allowed_error'
          schema:
            oneOf:
            - $ref: '#/components/schemas/Error'
            - $ref: '#/components/schemas/MultipleErrors'
      description: Client Error or Multiple Errors
    500_error:
      content:
        application/json:
          examples:
            database:
              $ref: '#/components/examples/database_error'
            default_error:
              $ref: '#/components/examples/default_error'
            invalid_argument:
              $ref: '#/components/examples/invalid_argument_error'
            unexpected_state:
              $ref: '#/components/examples/unexpected_state_error'
          schema:
            $ref: '#/components/schemas/Error'
      description: Server Error
    default_error:
      content:
        application/json:
          example:
            code: unknown_error
            message: An unknown error occurred.
            type: unknown_error
          schema:
            $ref: '#/components/schemas/Error'
      description: Default Error
    incorrect_credentials:
      content:
        text/plain:
          schema:
            default: Unauthorized
            example: Unauthorized
            type: string
      description: User does not exist or incorrect credentials
    invalid_request_error:
      content:
        application/json:
          example:
            code: invalid_request_error
            message: Discount with code TEST already exists.
            type: duplicate_error
          schema:
            $ref: '#/components/schemas/Error'
      description: Invalid Request Error
    invalid_state_error:
      content:
        application/json:
          example:
            code: unknown_error
            message: The request conflicted with another request. You may retry the
              request with the provided Idempotency-Key.
            type: QueryRunnerAlreadyReleasedError
          schema:
            $ref: '#/components/schemas/Error'
      description: Invalid State Error
    not_found_error:
      content:
        application/json:
          example:
            message: Entity with id 1 was not found
            type: not_found
          schema:
            $ref: '#/components/schemas/Error'
      description: Not Found Error
    unauthorized:
      content:
        text/plain:
          schema:
            default: Unauthorized
            example: Unauthorized
            type: string
      description: User is not authorized. Must log in first
  securitySchemes:
    api_token:
      in: header
      name: x-medusa-access-token
      type: apiKey
      x-displayName: API Token
    cookie_auth:
      in: cookie
      name: connect.sid
      type: apiKey
      x-displayName: Cookie Session ID
    jwt_token:
      scheme: bearer
      type: http
      x-displayName: JWT Token
