// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/driver005/gateway/model"
)

func newCustomerAddress(db *gorm.DB, opts ...gen.DOOption) customerAddress {
	_customerAddress := customerAddress{}

	_customerAddress.customerAddressDo.UseDB(db, opts...)
	_customerAddress.customerAddressDo.UseModel(&model.CustomerAddress{})

	tableName := _customerAddress.customerAddressDo.TableName()
	_customerAddress.ALL = field.NewAsterisk(tableName)
	_customerAddress.ID = field.NewString(tableName, "id")
	_customerAddress.CustomerID = field.NewString(tableName, "customer_id")
	_customerAddress.AddressName = field.NewString(tableName, "address_name")
	_customerAddress.IsDefaultShipping = field.NewBool(tableName, "is_default_shipping")
	_customerAddress.IsDefaultBilling = field.NewBool(tableName, "is_default_billing")
	_customerAddress.Company = field.NewString(tableName, "company")
	_customerAddress.FirstName = field.NewString(tableName, "first_name")
	_customerAddress.LastName = field.NewString(tableName, "last_name")
	_customerAddress.Address1 = field.NewString(tableName, "address_1")
	_customerAddress.Address2 = field.NewString(tableName, "address_2")
	_customerAddress.City = field.NewString(tableName, "city")
	_customerAddress.CountryCode = field.NewString(tableName, "country_code")
	_customerAddress.Province = field.NewString(tableName, "province")
	_customerAddress.PostalCode = field.NewString(tableName, "postal_code")
	_customerAddress.Phone = field.NewString(tableName, "phone")
	_customerAddress.Metadata = field.NewString(tableName, "metadata")
	_customerAddress.CreatedAt = field.NewTime(tableName, "created_at")
	_customerAddress.UpdatedAt = field.NewTime(tableName, "updated_at")

	_customerAddress.fillFieldMap()

	return _customerAddress
}

type customerAddress struct {
	customerAddressDo customerAddressDo

	ALL               field.Asterisk
	ID                field.String
	CustomerID        field.String
	AddressName       field.String
	IsDefaultShipping field.Bool
	IsDefaultBilling  field.Bool
	Company           field.String
	FirstName         field.String
	LastName          field.String
	Address1          field.String
	Address2          field.String
	City              field.String
	CountryCode       field.String
	Province          field.String
	PostalCode        field.String
	Phone             field.String
	Metadata          field.String
	CreatedAt         field.Time
	UpdatedAt         field.Time

	fieldMap map[string]field.Expr
}

func (c customerAddress) Table(newTableName string) *customerAddress {
	c.customerAddressDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c customerAddress) As(alias string) *customerAddress {
	c.customerAddressDo.DO = *(c.customerAddressDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *customerAddress) updateTableName(table string) *customerAddress {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewString(table, "id")
	c.CustomerID = field.NewString(table, "customer_id")
	c.AddressName = field.NewString(table, "address_name")
	c.IsDefaultShipping = field.NewBool(table, "is_default_shipping")
	c.IsDefaultBilling = field.NewBool(table, "is_default_billing")
	c.Company = field.NewString(table, "company")
	c.FirstName = field.NewString(table, "first_name")
	c.LastName = field.NewString(table, "last_name")
	c.Address1 = field.NewString(table, "address_1")
	c.Address2 = field.NewString(table, "address_2")
	c.City = field.NewString(table, "city")
	c.CountryCode = field.NewString(table, "country_code")
	c.Province = field.NewString(table, "province")
	c.PostalCode = field.NewString(table, "postal_code")
	c.Phone = field.NewString(table, "phone")
	c.Metadata = field.NewString(table, "metadata")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.UpdatedAt = field.NewTime(table, "updated_at")

	c.fillFieldMap()

	return c
}

func (c *customerAddress) WithContext(ctx context.Context) *customerAddressDo {
	return c.customerAddressDo.WithContext(ctx)
}

func (c customerAddress) TableName() string { return c.customerAddressDo.TableName() }

func (c customerAddress) Alias() string { return c.customerAddressDo.Alias() }

func (c customerAddress) Columns(cols ...field.Expr) gen.Columns {
	return c.customerAddressDo.Columns(cols...)
}

func (c *customerAddress) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *customerAddress) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 18)
	c.fieldMap["id"] = c.ID
	c.fieldMap["customer_id"] = c.CustomerID
	c.fieldMap["address_name"] = c.AddressName
	c.fieldMap["is_default_shipping"] = c.IsDefaultShipping
	c.fieldMap["is_default_billing"] = c.IsDefaultBilling
	c.fieldMap["company"] = c.Company
	c.fieldMap["first_name"] = c.FirstName
	c.fieldMap["last_name"] = c.LastName
	c.fieldMap["address_1"] = c.Address1
	c.fieldMap["address_2"] = c.Address2
	c.fieldMap["city"] = c.City
	c.fieldMap["country_code"] = c.CountryCode
	c.fieldMap["province"] = c.Province
	c.fieldMap["postal_code"] = c.PostalCode
	c.fieldMap["phone"] = c.Phone
	c.fieldMap["metadata"] = c.Metadata
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["updated_at"] = c.UpdatedAt
}

func (c customerAddress) clone(db *gorm.DB) customerAddress {
	c.customerAddressDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c customerAddress) replaceDB(db *gorm.DB) customerAddress {
	c.customerAddressDo.ReplaceDB(db)
	return c
}

type customerAddressDo struct{ gen.DO }

func (c customerAddressDo) Debug() *customerAddressDo {
	return c.withDO(c.DO.Debug())
}

func (c customerAddressDo) WithContext(ctx context.Context) *customerAddressDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c customerAddressDo) ReadDB() *customerAddressDo {
	return c.Clauses(dbresolver.Read)
}

func (c customerAddressDo) WriteDB() *customerAddressDo {
	return c.Clauses(dbresolver.Write)
}

func (c customerAddressDo) Session(config *gorm.Session) *customerAddressDo {
	return c.withDO(c.DO.Session(config))
}

func (c customerAddressDo) Clauses(conds ...clause.Expression) *customerAddressDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c customerAddressDo) Returning(value interface{}, columns ...string) *customerAddressDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c customerAddressDo) Not(conds ...gen.Condition) *customerAddressDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c customerAddressDo) Or(conds ...gen.Condition) *customerAddressDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c customerAddressDo) Select(conds ...field.Expr) *customerAddressDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c customerAddressDo) Where(conds ...gen.Condition) *customerAddressDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c customerAddressDo) Order(conds ...field.Expr) *customerAddressDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c customerAddressDo) Distinct(cols ...field.Expr) *customerAddressDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c customerAddressDo) Omit(cols ...field.Expr) *customerAddressDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c customerAddressDo) Join(table schema.Tabler, on ...field.Expr) *customerAddressDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c customerAddressDo) LeftJoin(table schema.Tabler, on ...field.Expr) *customerAddressDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c customerAddressDo) RightJoin(table schema.Tabler, on ...field.Expr) *customerAddressDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c customerAddressDo) Group(cols ...field.Expr) *customerAddressDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c customerAddressDo) Having(conds ...gen.Condition) *customerAddressDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c customerAddressDo) Limit(limit int) *customerAddressDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c customerAddressDo) Offset(offset int) *customerAddressDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c customerAddressDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *customerAddressDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c customerAddressDo) Unscoped() *customerAddressDo {
	return c.withDO(c.DO.Unscoped())
}

func (c customerAddressDo) Create(values ...*model.CustomerAddress) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c customerAddressDo) CreateInBatches(values []*model.CustomerAddress, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c customerAddressDo) Save(values ...*model.CustomerAddress) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c customerAddressDo) First() (*model.CustomerAddress, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.CustomerAddress), nil
	}
}

func (c customerAddressDo) Take() (*model.CustomerAddress, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.CustomerAddress), nil
	}
}

func (c customerAddressDo) Last() (*model.CustomerAddress, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.CustomerAddress), nil
	}
}

func (c customerAddressDo) Find() ([]*model.CustomerAddress, error) {
	result, err := c.DO.Find()
	return result.([]*model.CustomerAddress), err
}

func (c customerAddressDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CustomerAddress, err error) {
	buf := make([]*model.CustomerAddress, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c customerAddressDo) FindInBatches(result *[]*model.CustomerAddress, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c customerAddressDo) Attrs(attrs ...field.AssignExpr) *customerAddressDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c customerAddressDo) Assign(attrs ...field.AssignExpr) *customerAddressDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c customerAddressDo) Joins(fields ...field.RelationField) *customerAddressDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c customerAddressDo) Preload(fields ...field.RelationField) *customerAddressDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c customerAddressDo) FirstOrInit() (*model.CustomerAddress, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.CustomerAddress), nil
	}
}

func (c customerAddressDo) FirstOrCreate() (*model.CustomerAddress, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.CustomerAddress), nil
	}
}

func (c customerAddressDo) FindByPage(offset int, limit int) (result []*model.CustomerAddress, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c customerAddressDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c customerAddressDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c customerAddressDo) Delete(models ...*model.CustomerAddress) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *customerAddressDo) withDO(do gen.Dao) *customerAddressDo {
	c.DO = *do.(*gen.DO)
	return c
}
