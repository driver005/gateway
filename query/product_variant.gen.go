// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/driver005/gateway/model"
)

func newProductVariant(db *gorm.DB, opts ...gen.DOOption) productVariant {
	_productVariant := productVariant{}

	_productVariant.productVariantDo.UseDB(db, opts...)
	_productVariant.productVariantDo.UseModel(&model.ProductVariant{})

	tableName := _productVariant.productVariantDo.TableName()
	_productVariant.ALL = field.NewAsterisk(tableName)
	_productVariant.ID = field.NewString(tableName, "id")
	_productVariant.Title = field.NewString(tableName, "title")
	_productVariant.Sku = field.NewString(tableName, "sku")
	_productVariant.Barcode = field.NewString(tableName, "barcode")
	_productVariant.Ean = field.NewString(tableName, "ean")
	_productVariant.Upc = field.NewString(tableName, "upc")
	_productVariant.InventoryQuantity = field.NewFloat64(tableName, "inventory_quantity")
	_productVariant.AllowBackorder = field.NewBool(tableName, "allow_backorder")
	_productVariant.ManageInventory = field.NewBool(tableName, "manage_inventory")
	_productVariant.HsCode = field.NewString(tableName, "hs_code")
	_productVariant.OriginCountry = field.NewString(tableName, "origin_country")
	_productVariant.MidCode = field.NewString(tableName, "mid_code")
	_productVariant.Material = field.NewString(tableName, "material")
	_productVariant.Weight = field.NewFloat64(tableName, "weight")
	_productVariant.Length = field.NewFloat64(tableName, "length")
	_productVariant.Height = field.NewFloat64(tableName, "height")
	_productVariant.Width = field.NewFloat64(tableName, "width")
	_productVariant.Metadata = field.NewString(tableName, "metadata")
	_productVariant.VariantRank = field.NewFloat64(tableName, "variant_rank")
	_productVariant.ProductID = field.NewString(tableName, "product_id")
	_productVariant.CreatedAt = field.NewTime(tableName, "created_at")
	_productVariant.UpdatedAt = field.NewTime(tableName, "updated_at")
	_productVariant.DeletedAt = field.NewField(tableName, "deleted_at")

	_productVariant.fillFieldMap()

	return _productVariant
}

type productVariant struct {
	productVariantDo productVariantDo

	ALL               field.Asterisk
	ID                field.String
	Title             field.String
	Sku               field.String
	Barcode           field.String
	Ean               field.String
	Upc               field.String
	InventoryQuantity field.Float64
	AllowBackorder    field.Bool
	ManageInventory   field.Bool
	HsCode            field.String
	OriginCountry     field.String
	MidCode           field.String
	Material          field.String
	Weight            field.Float64
	Length            field.Float64
	Height            field.Float64
	Width             field.Float64
	Metadata          field.String
	VariantRank       field.Float64
	ProductID         field.String
	CreatedAt         field.Time
	UpdatedAt         field.Time
	DeletedAt         field.Field

	fieldMap map[string]field.Expr
}

func (p productVariant) Table(newTableName string) *productVariant {
	p.productVariantDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p productVariant) As(alias string) *productVariant {
	p.productVariantDo.DO = *(p.productVariantDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *productVariant) updateTableName(table string) *productVariant {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewString(table, "id")
	p.Title = field.NewString(table, "title")
	p.Sku = field.NewString(table, "sku")
	p.Barcode = field.NewString(table, "barcode")
	p.Ean = field.NewString(table, "ean")
	p.Upc = field.NewString(table, "upc")
	p.InventoryQuantity = field.NewFloat64(table, "inventory_quantity")
	p.AllowBackorder = field.NewBool(table, "allow_backorder")
	p.ManageInventory = field.NewBool(table, "manage_inventory")
	p.HsCode = field.NewString(table, "hs_code")
	p.OriginCountry = field.NewString(table, "origin_country")
	p.MidCode = field.NewString(table, "mid_code")
	p.Material = field.NewString(table, "material")
	p.Weight = field.NewFloat64(table, "weight")
	p.Length = field.NewFloat64(table, "length")
	p.Height = field.NewFloat64(table, "height")
	p.Width = field.NewFloat64(table, "width")
	p.Metadata = field.NewString(table, "metadata")
	p.VariantRank = field.NewFloat64(table, "variant_rank")
	p.ProductID = field.NewString(table, "product_id")
	p.CreatedAt = field.NewTime(table, "created_at")
	p.UpdatedAt = field.NewTime(table, "updated_at")
	p.DeletedAt = field.NewField(table, "deleted_at")

	p.fillFieldMap()

	return p
}

func (p *productVariant) WithContext(ctx context.Context) *productVariantDo {
	return p.productVariantDo.WithContext(ctx)
}

func (p productVariant) TableName() string { return p.productVariantDo.TableName() }

func (p productVariant) Alias() string { return p.productVariantDo.Alias() }

func (p productVariant) Columns(cols ...field.Expr) gen.Columns {
	return p.productVariantDo.Columns(cols...)
}

func (p *productVariant) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *productVariant) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 23)
	p.fieldMap["id"] = p.ID
	p.fieldMap["title"] = p.Title
	p.fieldMap["sku"] = p.Sku
	p.fieldMap["barcode"] = p.Barcode
	p.fieldMap["ean"] = p.Ean
	p.fieldMap["upc"] = p.Upc
	p.fieldMap["inventory_quantity"] = p.InventoryQuantity
	p.fieldMap["allow_backorder"] = p.AllowBackorder
	p.fieldMap["manage_inventory"] = p.ManageInventory
	p.fieldMap["hs_code"] = p.HsCode
	p.fieldMap["origin_country"] = p.OriginCountry
	p.fieldMap["mid_code"] = p.MidCode
	p.fieldMap["material"] = p.Material
	p.fieldMap["weight"] = p.Weight
	p.fieldMap["length"] = p.Length
	p.fieldMap["height"] = p.Height
	p.fieldMap["width"] = p.Width
	p.fieldMap["metadata"] = p.Metadata
	p.fieldMap["variant_rank"] = p.VariantRank
	p.fieldMap["product_id"] = p.ProductID
	p.fieldMap["created_at"] = p.CreatedAt
	p.fieldMap["updated_at"] = p.UpdatedAt
	p.fieldMap["deleted_at"] = p.DeletedAt
}

func (p productVariant) clone(db *gorm.DB) productVariant {
	p.productVariantDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p productVariant) replaceDB(db *gorm.DB) productVariant {
	p.productVariantDo.ReplaceDB(db)
	return p
}

type productVariantDo struct{ gen.DO }

func (p productVariantDo) Debug() *productVariantDo {
	return p.withDO(p.DO.Debug())
}

func (p productVariantDo) WithContext(ctx context.Context) *productVariantDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p productVariantDo) ReadDB() *productVariantDo {
	return p.Clauses(dbresolver.Read)
}

func (p productVariantDo) WriteDB() *productVariantDo {
	return p.Clauses(dbresolver.Write)
}

func (p productVariantDo) Session(config *gorm.Session) *productVariantDo {
	return p.withDO(p.DO.Session(config))
}

func (p productVariantDo) Clauses(conds ...clause.Expression) *productVariantDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p productVariantDo) Returning(value interface{}, columns ...string) *productVariantDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p productVariantDo) Not(conds ...gen.Condition) *productVariantDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p productVariantDo) Or(conds ...gen.Condition) *productVariantDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p productVariantDo) Select(conds ...field.Expr) *productVariantDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p productVariantDo) Where(conds ...gen.Condition) *productVariantDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p productVariantDo) Order(conds ...field.Expr) *productVariantDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p productVariantDo) Distinct(cols ...field.Expr) *productVariantDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p productVariantDo) Omit(cols ...field.Expr) *productVariantDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p productVariantDo) Join(table schema.Tabler, on ...field.Expr) *productVariantDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p productVariantDo) LeftJoin(table schema.Tabler, on ...field.Expr) *productVariantDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p productVariantDo) RightJoin(table schema.Tabler, on ...field.Expr) *productVariantDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p productVariantDo) Group(cols ...field.Expr) *productVariantDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p productVariantDo) Having(conds ...gen.Condition) *productVariantDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p productVariantDo) Limit(limit int) *productVariantDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p productVariantDo) Offset(offset int) *productVariantDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p productVariantDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *productVariantDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p productVariantDo) Unscoped() *productVariantDo {
	return p.withDO(p.DO.Unscoped())
}

func (p productVariantDo) Create(values ...*model.ProductVariant) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p productVariantDo) CreateInBatches(values []*model.ProductVariant, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p productVariantDo) Save(values ...*model.ProductVariant) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p productVariantDo) First() (*model.ProductVariant, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductVariant), nil
	}
}

func (p productVariantDo) Take() (*model.ProductVariant, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductVariant), nil
	}
}

func (p productVariantDo) Last() (*model.ProductVariant, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductVariant), nil
	}
}

func (p productVariantDo) Find() ([]*model.ProductVariant, error) {
	result, err := p.DO.Find()
	return result.([]*model.ProductVariant), err
}

func (p productVariantDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ProductVariant, err error) {
	buf := make([]*model.ProductVariant, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p productVariantDo) FindInBatches(result *[]*model.ProductVariant, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p productVariantDo) Attrs(attrs ...field.AssignExpr) *productVariantDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p productVariantDo) Assign(attrs ...field.AssignExpr) *productVariantDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p productVariantDo) Joins(fields ...field.RelationField) *productVariantDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p productVariantDo) Preload(fields ...field.RelationField) *productVariantDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p productVariantDo) FirstOrInit() (*model.ProductVariant, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductVariant), nil
	}
}

func (p productVariantDo) FirstOrCreate() (*model.ProductVariant, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductVariant), nil
	}
}

func (p productVariantDo) FindByPage(offset int, limit int) (result []*model.ProductVariant, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p productVariantDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p productVariantDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p productVariantDo) Delete(models ...*model.ProductVariant) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *productVariantDo) withDO(do gen.Dao) *productVariantDo {
	p.DO = *do.(*gen.DO)
	return p
}
