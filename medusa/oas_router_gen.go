// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [3]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/admin/"
			origElem := elem
			if l := len("/admin/"); len(elem) >= l && elem[0:l] == "/admin/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "api-keys"
				origElem := elem
				if l := len("api-keys"); len(elem) >= l && elem[0:l] == "api-keys" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleGetApiKeysRequest([0]string{}, elemIsEscaped, w, r)
					case "POST":
						s.handlePostApiKeysRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET,POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "DELETE":
							s.handleDeleteApiKeysIdRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "GET":
							s.handleGetApiKeysIdRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "POST":
							s.handlePostApiKeysIdRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/revoke"
						origElem := elem
						if l := len("/revoke"); len(elem) >= l && elem[0:l] == "/revoke" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handlePostApiKeysIdRevokeRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'c': // Prefix: "c"
				origElem := elem
				if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ampaigns"
					origElem := elem
					if l := len("ampaigns"); len(elem) >= l && elem[0:l] == "ampaigns" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetCampaignsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handlePostCampaignsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleDeleteCampaignsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetCampaignsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handlePostCampaignsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,POST")
							}

							return
						}

						elem = origElem
					}

					elem = origElem
				case 'o': // Prefix: "ollections"
					origElem := elem
					if l := len("ollections"); len(elem) >= l && elem[0:l] == "ollections" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetCollectionsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handlePostCollectionsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleDeleteCollectionsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetCollectionsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handlePostCollectionsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,POST")
							}

							return
						}

						elem = origElem
					}

					elem = origElem
				case 'u': // Prefix: "u"
					origElem := elem
					if l := len("u"); len(elem) >= l && elem[0:l] == "u" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'r': // Prefix: "rrencies"
						origElem := elem
						if l := len("rrencies"); len(elem) >= l && elem[0:l] == "rrencies" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetCurrenciesRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "code"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetCurrenciesCodeRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					case 's': // Prefix: "stomer"
						origElem := elem
						if l := len("stomer"); len(elem) >= l && elem[0:l] == "stomer" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-groups"
							origElem := elem
							if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetCustomerGroupsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handlePostCustomerGroupsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteCustomerGroupsIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetCustomerGroupsIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handlePostCustomerGroupsIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/customers"
									origElem := elem
									if l := len("/customers"); len(elem) >= l && elem[0:l] == "/customers" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGetCustomerGroupsIdCustomersRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										origElem := elem
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'b': // Prefix: "batch"
											origElem := elem
											if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handlePostCustomerGroupsIdCustomersBatchRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										case 'r': // Prefix: "remove"
											origElem := elem
											if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handlePostCustomerGroupsIdCustomersRemoveRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 's': // Prefix: "s"
							origElem := elem
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetCustomersRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handlePostCustomersRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteCustomersIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetCustomersIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handlePostCustomersIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/addresses"
									origElem := elem
									if l := len("/addresses"); len(elem) >= l && elem[0:l] == "/addresses" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGetCustomersIdAddressesRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "POST":
											s.handlePostCustomersIdAddressesRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										origElem := elem
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "address_id"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleDeleteCustomersIdAddressesAddressIDRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleGetCustomersIdAddressesAddressIDRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handlePostCustomersIdAddressesAddressIDRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,POST")
											}

											return
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'f': // Prefix: "fulfillment/shipping-options/"
				origElem := elem
				if l := len("fulfillment/shipping-options/"); len(elem) >= l && elem[0:l] == "fulfillment/shipping-options/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/rules/batch/"
					origElem := elem
					if l := len("/rules/batch/"); len(elem) >= l && elem[0:l] == "/rules/batch/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "add"
						origElem := elem
						if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handlePostFulfillmentShippingOptionsIdRulesBatchAddRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

						elem = origElem
					case 'r': // Prefix: "remove"
						origElem := elem
						if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handlePostFulfillmentShippingOptionsIdRulesBatchRemoveRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'i': // Prefix: "inv"
				origElem := elem
				if l := len("inv"); len(elem) >= l && elem[0:l] == "inv" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "entory-items"
					origElem := elem
					if l := len("entory-items"); len(elem) >= l && elem[0:l] == "entory-items" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetInventoryItemsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handlePostInventoryItemsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteInventoryItemsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetInventoryItemsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handlePostInventoryItemsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/location-levels"
							origElem := elem
							if l := len("/location-levels"); len(elem) >= l && elem[0:l] == "/location-levels" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "POST":
									s.handlePostInventoryItemsIdLocationLevelsRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "location_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteInventoryItemsIdLocationLevelsLocationIDRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handlePostInventoryItemsIdLocationLevelsLocationIDRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,POST")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'i': // Prefix: "ites"
					origElem := elem
					if l := len("ites"); len(elem) >= l && elem[0:l] == "ites" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetInvitesRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handlePostInvitesRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "accept"
							origElem := elem
							if l := len("accept"); len(elem) >= l && elem[0:l] == "accept" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handlePostInvitesAcceptRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

							elem = origElem
						}
						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteInvitesIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetInvitesIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/resend"
							origElem := elem
							if l := len("/resend"); len(elem) >= l && elem[0:l] == "/resend" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handlePostInvitesIdResendRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'p': // Prefix: "p"
				origElem := elem
				if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ayments"
					origElem := elem
					if l := len("ayments"); len(elem) >= l && elem[0:l] == "ayments" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetPaymentsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetPaymentsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "capture"
								origElem := elem
								if l := len("capture"); len(elem) >= l && elem[0:l] == "capture" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handlePostPaymentsIdCaptureRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							case 'r': // Prefix: "refund"
								origElem := elem
								if l := len("refund"); len(elem) >= l && elem[0:l] == "refund" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handlePostPaymentsIdRefundRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'r': // Prefix: "r"
					origElem := elem
					if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'i': // Prefix: "ic"
						origElem := elem
						if l := len("ic"); len(elem) >= l && elem[0:l] == "ic" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "e-lists"
							origElem := elem
							if l := len("e-lists"); len(elem) >= l && elem[0:l] == "e-lists" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetPriceListsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handlePostPriceListsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeletePriceListsIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetPriceListsIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handlePostPriceListsIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/prices/batch/"
									origElem := elem
									if l := len("/prices/batch/"); len(elem) >= l && elem[0:l] == "/prices/batch/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "add"
										origElem := elem
										if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handlePostPriceListsIdPricesBatchAddRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

										elem = origElem
									case 'r': // Prefix: "remove"
										origElem := elem
										if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handlePostPriceListsIdPricesBatchRemoveRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'i': // Prefix: "ing/rule-types"
							origElem := elem
							if l := len("ing/rule-types"); len(elem) >= l && elem[0:l] == "ing/rule-types" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetPricingRuleTypesRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handlePostPricingRuleTypesRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeletePricingRuleTypesIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetPricingRuleTypesIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handlePostPricingRuleTypesIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,POST")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					case 'o': // Prefix: "o"
						origElem := elem
						if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "ducts"
							origElem := elem
							if l := len("ducts"); len(elem) >= l && elem[0:l] == "ducts" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetProductsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handlePostProductsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteProductsIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetProductsIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handlePostProductsIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									origElem := elem
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'o': // Prefix: "options"
										origElem := elem
										if l := len("options"); len(elem) >= l && elem[0:l] == "options" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleGetProductsIdOptionsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handlePostProductsIdOptionsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											origElem := elem
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "option_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleDeleteProductsIdOptionsOptionIDRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleGetProductsIdOptionsOptionIDRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handlePostProductsIdOptionsOptionIDRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,POST")
												}

												return
											}

											elem = origElem
										}

										elem = origElem
									case 'v': // Prefix: "variants"
										origElem := elem
										if l := len("variants"); len(elem) >= l && elem[0:l] == "variants" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleGetProductsIdVariantsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handlePostProductsIdVariantsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											origElem := elem
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "variant_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleDeleteProductsIdVariantsVariantIDRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleGetProductsIdVariantsVariantIDRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handlePostProductsIdVariantsVariantIDRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,POST")
												}

												return
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'm': // Prefix: "motions"
							origElem := elem
							if l := len("motions"); len(elem) >= l && elem[0:l] == "motions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetPromotionsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handlePostPromotionsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeletePromotionsIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetPromotionsIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handlePostPromotionsIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									origElem := elem
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'b': // Prefix: "buy-rules/batch/"
										origElem := elem
										if l := len("buy-rules/batch/"); len(elem) >= l && elem[0:l] == "buy-rules/batch/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "add"
											origElem := elem
											if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handlePostPromotionsIdBuyRulesBatchAddRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										case 'r': // Prefix: "remove"
											origElem := elem
											if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handlePostPromotionsIdBuyRulesBatchRemoveRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										}

										elem = origElem
									case 'r': // Prefix: "rules/batch/"
										origElem := elem
										if l := len("rules/batch/"); len(elem) >= l && elem[0:l] == "rules/batch/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "add"
											origElem := elem
											if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handlePostPromotionsIdRulesBatchAddRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										case 'r': // Prefix: "remove"
											origElem := elem
											if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handlePostPromotionsIdRulesBatchRemoveRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										case 'u': // Prefix: "update"
											origElem := elem
											if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handlePostPromotionsIdRulesBatchUpdateRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										}

										elem = origElem
									case 't': // Prefix: "target-rules/batch/"
										origElem := elem
										if l := len("target-rules/batch/"); len(elem) >= l && elem[0:l] == "target-rules/batch/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "add"
											origElem := elem
											if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handlePostPromotionsIdTargetRulesBatchAddRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										case 'r': // Prefix: "remove"
											origElem := elem
											if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handlePostPromotionsIdTargetRulesBatchRemoveRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'r': // Prefix: "regions"
				origElem := elem
				if l := len("regions"); len(elem) >= l && elem[0:l] == "regions" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleGetRegionsRequest([0]string{}, elemIsEscaped, w, r)
					case "POST":
						s.handlePostRegionsRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET,POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "DELETE":
							s.handleDeleteRegionsIdRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "GET":
							s.handleGetRegionsIdRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "POST":
							s.handlePostRegionsIdRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,POST")
						}

						return
					}

					elem = origElem
				}

				elem = origElem
			case 's': // Prefix: "s"
				origElem := elem
				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ales-channels"
					origElem := elem
					if l := len("ales-channels"); len(elem) >= l && elem[0:l] == "ales-channels" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetSalesChannelsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handlePostSalesChannelsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteSalesChannelsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetSalesChannelsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handlePostSalesChannelsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/products/batch/add"
							origElem := elem
							if l := len("/products/batch/add"); len(elem) >= l && elem[0:l] == "/products/batch/add" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handlePostSalesChannelsIdProductsBatchAddRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 't': // Prefix: "to"
					origElem := elem
					if l := len("to"); len(elem) >= l && elem[0:l] == "to" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "ck-locations"
						origElem := elem
						if l := len("ck-locations"); len(elem) >= l && elem[0:l] == "ck-locations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "POST":
								s.handlePostStockLocationsRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleDeleteStockLocationsIdRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleGetStockLocationsIdRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					case 'r': // Prefix: "res"
						origElem := elem
						if l := len("res"); len(elem) >= l && elem[0:l] == "res" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetStoresRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetStoresIdRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "POST":
									s.handlePostStoresIdRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 't': // Prefix: "tax-r"
				origElem := elem
				if l := len("tax-r"); len(elem) >= l && elem[0:l] == "tax-r" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ates"
					origElem := elem
					if l := len("ates"); len(elem) >= l && elem[0:l] == "ates" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetTaxRatesRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handlePostTaxRatesRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteTaxRatesIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetTaxRatesIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handlePostTaxRatesIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/rules"
							origElem := elem
							if l := len("/rules"); len(elem) >= l && elem[0:l] == "/rules" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "POST":
									s.handlePostTaxRatesIdRulesRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "rule_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteTaxRatesIdRulesRuleIDRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'e': // Prefix: "egions"
					origElem := elem
					if l := len("egions"); len(elem) >= l && elem[0:l] == "egions" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "POST":
							s.handlePostTaxRegionsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleDeleteTaxRegionsIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE")
							}

							return
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'u': // Prefix: "users"
				origElem := elem
				if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleGetUsersRequest([0]string{}, elemIsEscaped, w, r)
					case "POST":
						s.handlePostUsersRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET,POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'm': // Prefix: "me"
						origElem := elem
						if l := len("me"); len(elem) >= l && elem[0:l] == "me" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetUsersMeRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

						elem = origElem
					}
					// Param: "id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "DELETE":
							s.handleDeleteUsersIdRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "GET":
							s.handleGetUsersIdRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "POST":
							s.handlePostUsersIdRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,POST")
						}

						return
					}

					elem = origElem
				}

				elem = origElem
			case 'w': // Prefix: "workflows-executions"
				origElem := elem
				if l := len("workflows-executions"); len(elem) >= l && elem[0:l] == "workflows-executions" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleGetWorkflowsExecutionsRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetWorkflowsExecutionsIdRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'r': // Prefix: "run"
							origElem := elem
							if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handlePostWorkflowsExecutionsWorkflowIdRunRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

							elem = origElem
						case 's': // Prefix: "s"
							origElem := elem
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 't': // Prefix: "teps/"
								origElem := elem
								if l := len("teps/"); len(elem) >= l && elem[0:l] == "teps/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'f': // Prefix: "failure"
									origElem := elem
									if l := len("failure"); len(elem) >= l && elem[0:l] == "failure" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handlePostWorkflowsExecutionsWorkflowIdStepsFailureRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								case 's': // Prefix: "success"
									origElem := elem
									if l := len("success"); len(elem) >= l && elem[0:l] == "success" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handlePostWorkflowsExecutionsWorkflowIdStepsSuccessRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}

								elem = origElem
							case 'u': // Prefix: "ubscribe"
								origElem := elem
								if l := len("ubscribe"); len(elem) >= l && elem[0:l] == "ubscribe" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetWorkflowsExecutionsWorkflowIdSubscribeRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						}
						// Param: "transaction_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetWorkflowsExecutionsWorkflowIdTransactionIDRequest([2]string{
									args[0],
									args[1],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "step_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[2] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/subscribe"
								origElem := elem
								if l := len("/subscribe"); len(elem) >= l && elem[0:l] == "/subscribe" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			}

			elem = origElem
		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name        string
	summary     string
	operationID string
	pathPattern string
	count       int
	args        [3]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/admin/"
			origElem := elem
			if l := len("/admin/"); len(elem) >= l && elem[0:l] == "/admin/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "api-keys"
				origElem := elem
				if l := len("api-keys"); len(elem) >= l && elem[0:l] == "api-keys" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "GetApiKeys"
						r.summary = "List Api Keys"
						r.operationID = "GetApiKeys"
						r.pathPattern = "/admin/api-keys"
						r.args = args
						r.count = 0
						return r, true
					case "POST":
						r.name = "PostApiKeys"
						r.summary = "Create Api Key"
						r.operationID = "PostApiKeys"
						r.pathPattern = "/admin/api-keys"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							r.name = "DeleteApiKeysId"
							r.summary = "Delete a Api Key"
							r.operationID = "DeleteApiKeysId"
							r.pathPattern = "/admin/api-keys/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							r.name = "GetApiKeysId"
							r.summary = "Get a Api Key"
							r.operationID = "GetApiKeysId"
							r.pathPattern = "/admin/api-keys/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "POST":
							r.name = "PostApiKeysId"
							r.summary = "Update a Api Key"
							r.operationID = "PostApiKeysId"
							r.pathPattern = "/admin/api-keys/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/revoke"
						origElem := elem
						if l := len("/revoke"); len(elem) >= l && elem[0:l] == "/revoke" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								// Leaf: PostApiKeysIdRevoke
								r.name = "PostApiKeysIdRevoke"
								r.summary = "Add Revokes to Api Key"
								r.operationID = "PostApiKeysIdRevoke"
								r.pathPattern = "/admin/api-keys/{id}/revoke"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'c': // Prefix: "c"
				origElem := elem
				if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ampaigns"
					origElem := elem
					if l := len("ampaigns"); len(elem) >= l && elem[0:l] == "ampaigns" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "GetCampaigns"
							r.summary = "List Campaigns"
							r.operationID = "GetCampaigns"
							r.pathPattern = "/admin/campaigns"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "PostCampaigns"
							r.summary = "Create Campaign"
							r.operationID = "PostCampaigns"
							r.pathPattern = "/admin/campaigns"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: DeleteCampaignsId
								r.name = "DeleteCampaignsId"
								r.summary = "Delete a Campaign"
								r.operationID = "DeleteCampaignsId"
								r.pathPattern = "/admin/campaigns/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								// Leaf: GetCampaignsId
								r.name = "GetCampaignsId"
								r.summary = "Get a Campaign"
								r.operationID = "GetCampaignsId"
								r.pathPattern = "/admin/campaigns/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								// Leaf: PostCampaignsId
								r.name = "PostCampaignsId"
								r.summary = "Update a Campaign"
								r.operationID = "PostCampaignsId"
								r.pathPattern = "/admin/campaigns/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}

					elem = origElem
				case 'o': // Prefix: "ollections"
					origElem := elem
					if l := len("ollections"); len(elem) >= l && elem[0:l] == "ollections" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "GetCollections"
							r.summary = "List Collections"
							r.operationID = "GetCollections"
							r.pathPattern = "/admin/collections"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "PostCollections"
							r.summary = "Create Collection"
							r.operationID = "PostCollections"
							r.pathPattern = "/admin/collections"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: DeleteCollectionsId
								r.name = "DeleteCollectionsId"
								r.summary = "Delete a Collection"
								r.operationID = "DeleteCollectionsId"
								r.pathPattern = "/admin/collections/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								// Leaf: GetCollectionsId
								r.name = "GetCollectionsId"
								r.summary = "Get a Collection"
								r.operationID = "GetCollectionsId"
								r.pathPattern = "/admin/collections/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								// Leaf: PostCollectionsId
								r.name = "PostCollectionsId"
								r.summary = "Update a Collection"
								r.operationID = "PostCollectionsId"
								r.pathPattern = "/admin/collections/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}

					elem = origElem
				case 'u': // Prefix: "u"
					origElem := elem
					if l := len("u"); len(elem) >= l && elem[0:l] == "u" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'r': // Prefix: "rrencies"
						origElem := elem
						if l := len("rrencies"); len(elem) >= l && elem[0:l] == "rrencies" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "GetCurrencies"
								r.summary = "List Currencies"
								r.operationID = "GetCurrencies"
								r.pathPattern = "/admin/currencies"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "code"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GetCurrenciesCode
									r.name = "GetCurrenciesCode"
									r.summary = "Get a Currency"
									r.operationID = "GetCurrenciesCode"
									r.pathPattern = "/admin/currencies/{code}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					case 's': // Prefix: "stomer"
						origElem := elem
						if l := len("stomer"); len(elem) >= l && elem[0:l] == "stomer" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-groups"
							origElem := elem
							if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "GetCustomerGroups"
									r.summary = "List Customer Groups"
									r.operationID = "GetCustomerGroups"
									r.pathPattern = "/admin/customer-groups"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = "PostCustomerGroups"
									r.summary = "Create Customer Group"
									r.operationID = "PostCustomerGroups"
									r.pathPattern = "/admin/customer-groups"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = "DeleteCustomerGroupsId"
										r.summary = "Delete a Customer Group"
										r.operationID = "DeleteCustomerGroupsId"
										r.pathPattern = "/admin/customer-groups/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = "GetCustomerGroupsId"
										r.summary = "Get a Customer Group"
										r.operationID = "GetCustomerGroupsId"
										r.pathPattern = "/admin/customer-groups/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = "PostCustomerGroupsId"
										r.summary = "Update a Customer Group"
										r.operationID = "PostCustomerGroupsId"
										r.pathPattern = "/admin/customer-groups/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/customers"
									origElem := elem
									if l := len("/customers"); len(elem) >= l && elem[0:l] == "/customers" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "GetCustomerGroupsIdCustomers"
											r.summary = "List Customers"
											r.operationID = "GetCustomerGroupsIdCustomers"
											r.pathPattern = "/admin/customer-groups/{id}/customers"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										origElem := elem
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'b': // Prefix: "batch"
											origElem := elem
											if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: PostCustomerGroupsIdCustomersBatch
													r.name = "PostCustomerGroupsIdCustomersBatch"
													r.summary = "Add Customers to Customer Group"
													r.operationID = "PostCustomerGroupsIdCustomersBatch"
													r.pathPattern = "/admin/customer-groups/{id}/customers/batch"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

											elem = origElem
										case 'r': // Prefix: "remove"
											origElem := elem
											if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: PostCustomerGroupsIdCustomersRemove
													r.name = "PostCustomerGroupsIdCustomersRemove"
													r.summary = "Add Removes to Customer Group"
													r.operationID = "PostCustomerGroupsIdCustomersRemove"
													r.pathPattern = "/admin/customer-groups/{id}/customers/remove"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 's': // Prefix: "s"
							origElem := elem
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "GetCustomers"
									r.summary = "List Customers"
									r.operationID = "GetCustomers"
									r.pathPattern = "/admin/customers"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = "PostCustomers"
									r.summary = "Create Customer"
									r.operationID = "PostCustomers"
									r.pathPattern = "/admin/customers"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = "DeleteCustomersId"
										r.summary = "Delete a Customer"
										r.operationID = "DeleteCustomersId"
										r.pathPattern = "/admin/customers/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = "GetCustomersId"
										r.summary = "Get a Customer"
										r.operationID = "GetCustomersId"
										r.pathPattern = "/admin/customers/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = "PostCustomersId"
										r.summary = "Update a Customer"
										r.operationID = "PostCustomersId"
										r.pathPattern = "/admin/customers/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/addresses"
									origElem := elem
									if l := len("/addresses"); len(elem) >= l && elem[0:l] == "/addresses" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "GetCustomersIdAddresses"
											r.summary = "List Addresses"
											r.operationID = "GetCustomersIdAddresses"
											r.pathPattern = "/admin/customers/{id}/addresses"
											r.args = args
											r.count = 1
											return r, true
										case "POST":
											r.name = "PostCustomersIdAddresses"
											r.summary = "Add Addresses to Customer"
											r.operationID = "PostCustomersIdAddresses"
											r.pathPattern = "/admin/customers/{id}/addresses"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										origElem := elem
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "address_id"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												// Leaf: DeleteCustomersIdAddressesAddressID
												r.name = "DeleteCustomersIdAddressesAddressID"
												r.summary = "Remove Addresses from Customer"
												r.operationID = "DeleteCustomersIdAddressesAddress_id"
												r.pathPattern = "/admin/customers/{id}/addresses/{address_id}"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												// Leaf: GetCustomersIdAddressesAddressID
												r.name = "GetCustomersIdAddressesAddressID"
												r.summary = "List Addresses"
												r.operationID = "GetCustomersIdAddressesAddress_id"
												r.pathPattern = "/admin/customers/{id}/addresses/{address_id}"
												r.args = args
												r.count = 2
												return r, true
											case "POST":
												// Leaf: PostCustomersIdAddressesAddressID
												r.name = "PostCustomersIdAddressesAddressID"
												r.summary = "Add Addresses to Customer"
												r.operationID = "PostCustomersIdAddressesAddress_id"
												r.pathPattern = "/admin/customers/{id}/addresses/{address_id}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'f': // Prefix: "fulfillment/shipping-options/"
				origElem := elem
				if l := len("fulfillment/shipping-options/"); len(elem) >= l && elem[0:l] == "fulfillment/shipping-options/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/rules/batch/"
					origElem := elem
					if l := len("/rules/batch/"); len(elem) >= l && elem[0:l] == "/rules/batch/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "add"
						origElem := elem
						if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								// Leaf: PostFulfillmentShippingOptionsIdRulesBatchAdd
								r.name = "PostFulfillmentShippingOptionsIdRulesBatchAdd"
								r.summary = "Add Adds to Fulfillment"
								r.operationID = "PostFulfillmentShippingOptionsIdRulesBatchAdd"
								r.pathPattern = "/admin/fulfillment/shipping-options/{id}/rules/batch/add"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 'r': // Prefix: "remove"
						origElem := elem
						if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								// Leaf: PostFulfillmentShippingOptionsIdRulesBatchRemove
								r.name = "PostFulfillmentShippingOptionsIdRulesBatchRemove"
								r.summary = "Add Removes to Fulfillment"
								r.operationID = "PostFulfillmentShippingOptionsIdRulesBatchRemove"
								r.pathPattern = "/admin/fulfillment/shipping-options/{id}/rules/batch/remove"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'i': // Prefix: "inv"
				origElem := elem
				if l := len("inv"); len(elem) >= l && elem[0:l] == "inv" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "entory-items"
					origElem := elem
					if l := len("entory-items"); len(elem) >= l && elem[0:l] == "entory-items" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "GetInventoryItems"
							r.summary = "List Inventory Items"
							r.operationID = "GetInventoryItems"
							r.pathPattern = "/admin/inventory-items"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "PostInventoryItems"
							r.summary = "Create Inventory Item"
							r.operationID = "PostInventoryItems"
							r.pathPattern = "/admin/inventory-items"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteInventoryItemsId"
								r.summary = "Delete a Inventory Item"
								r.operationID = "DeleteInventoryItemsId"
								r.pathPattern = "/admin/inventory-items/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "GetInventoryItemsId"
								r.summary = "Get a Inventory Item"
								r.operationID = "GetInventoryItemsId"
								r.pathPattern = "/admin/inventory-items/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								r.name = "PostInventoryItemsId"
								r.summary = "Update a Inventory Item"
								r.operationID = "PostInventoryItemsId"
								r.pathPattern = "/admin/inventory-items/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/location-levels"
							origElem := elem
							if l := len("/location-levels"); len(elem) >= l && elem[0:l] == "/location-levels" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									r.name = "PostInventoryItemsIdLocationLevels"
									r.summary = "Add Location Levels to Inventory Item"
									r.operationID = "PostInventoryItemsIdLocationLevels"
									r.pathPattern = "/admin/inventory-items/{id}/location-levels"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "location_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: DeleteInventoryItemsIdLocationLevelsLocationID
										r.name = "DeleteInventoryItemsIdLocationLevelsLocationID"
										r.summary = "Remove Location Levels from Inventory Item"
										r.operationID = "DeleteInventoryItemsIdLocationLevelsLocation_id"
										r.pathPattern = "/admin/inventory-items/{id}/location-levels/{location_id}"
										r.args = args
										r.count = 2
										return r, true
									case "POST":
										// Leaf: PostInventoryItemsIdLocationLevelsLocationID
										r.name = "PostInventoryItemsIdLocationLevelsLocationID"
										r.summary = "Add Location Levels to Inventory Item"
										r.operationID = "PostInventoryItemsIdLocationLevelsLocation_id"
										r.pathPattern = "/admin/inventory-items/{id}/location-levels/{location_id}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'i': // Prefix: "ites"
					origElem := elem
					if l := len("ites"); len(elem) >= l && elem[0:l] == "ites" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "GetInvites"
							r.summary = "List Invites"
							r.operationID = "GetInvites"
							r.pathPattern = "/admin/invites"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "PostInvites"
							r.summary = "Create Invite"
							r.operationID = "PostInvites"
							r.pathPattern = "/admin/invites"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "accept"
							origElem := elem
							if l := len("accept"); len(elem) >= l && elem[0:l] == "accept" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: PostInvitesAccept
									r.name = "PostInvitesAccept"
									r.summary = "Create Invite"
									r.operationID = "PostInvitesAccept"
									r.pathPattern = "/admin/invites/accept"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}
						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteInvitesId"
								r.summary = "Delete a Invite"
								r.operationID = "DeleteInvitesId"
								r.pathPattern = "/admin/invites/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "GetInvitesId"
								r.summary = "Get a Invite"
								r.operationID = "GetInvitesId"
								r.pathPattern = "/admin/invites/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/resend"
							origElem := elem
							if l := len("/resend"); len(elem) >= l && elem[0:l] == "/resend" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: PostInvitesIdResend
									r.name = "PostInvitesIdResend"
									r.summary = "Add Resends to Invite"
									r.operationID = "PostInvitesIdResend"
									r.pathPattern = "/admin/invites/{id}/resend"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'p': // Prefix: "p"
				origElem := elem
				if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ayments"
					origElem := elem
					if l := len("ayments"); len(elem) >= l && elem[0:l] == "ayments" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "GetPayments"
							r.summary = "List Payments"
							r.operationID = "GetPayments"
							r.pathPattern = "/admin/payments"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "GetPaymentsId"
								r.summary = "Get a Payment"
								r.operationID = "GetPaymentsId"
								r.pathPattern = "/admin/payments/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "capture"
								origElem := elem
								if l := len("capture"); len(elem) >= l && elem[0:l] == "capture" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: PostPaymentsIdCapture
										r.name = "PostPaymentsIdCapture"
										r.summary = "Add Captures to Payment"
										r.operationID = "PostPaymentsIdCapture"
										r.pathPattern = "/admin/payments/{id}/capture"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'r': // Prefix: "refund"
								origElem := elem
								if l := len("refund"); len(elem) >= l && elem[0:l] == "refund" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: PostPaymentsIdRefund
										r.name = "PostPaymentsIdRefund"
										r.summary = "Add Refunds to Payment"
										r.operationID = "PostPaymentsIdRefund"
										r.pathPattern = "/admin/payments/{id}/refund"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'r': // Prefix: "r"
					origElem := elem
					if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'i': // Prefix: "ic"
						origElem := elem
						if l := len("ic"); len(elem) >= l && elem[0:l] == "ic" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "e-lists"
							origElem := elem
							if l := len("e-lists"); len(elem) >= l && elem[0:l] == "e-lists" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "GetPriceLists"
									r.summary = "List Price Lists"
									r.operationID = "GetPriceLists"
									r.pathPattern = "/admin/price-lists"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = "PostPriceLists"
									r.summary = "Create Price List"
									r.operationID = "PostPriceLists"
									r.pathPattern = "/admin/price-lists"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = "DeletePriceListsId"
										r.summary = "Delete a Price List"
										r.operationID = "DeletePriceListsId"
										r.pathPattern = "/admin/price-lists/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = "GetPriceListsId"
										r.summary = "Get a Price List"
										r.operationID = "GetPriceListsId"
										r.pathPattern = "/admin/price-lists/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = "PostPriceListsId"
										r.summary = "Update a Price List"
										r.operationID = "PostPriceListsId"
										r.pathPattern = "/admin/price-lists/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/prices/batch/"
									origElem := elem
									if l := len("/prices/batch/"); len(elem) >= l && elem[0:l] == "/prices/batch/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "add"
										origElem := elem
										if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "POST":
												// Leaf: PostPriceListsIdPricesBatchAdd
												r.name = "PostPriceListsIdPricesBatchAdd"
												r.summary = "Add Adds to Price List"
												r.operationID = "PostPriceListsIdPricesBatchAdd"
												r.pathPattern = "/admin/price-lists/{id}/prices/batch/add"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									case 'r': // Prefix: "remove"
										origElem := elem
										if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "POST":
												// Leaf: PostPriceListsIdPricesBatchRemove
												r.name = "PostPriceListsIdPricesBatchRemove"
												r.summary = "Add Removes to Price List"
												r.operationID = "PostPriceListsIdPricesBatchRemove"
												r.pathPattern = "/admin/price-lists/{id}/prices/batch/remove"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'i': // Prefix: "ing/rule-types"
							origElem := elem
							if l := len("ing/rule-types"); len(elem) >= l && elem[0:l] == "ing/rule-types" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "GetPricingRuleTypes"
									r.summary = "List Pricing"
									r.operationID = "GetPricingRuleTypes"
									r.pathPattern = "/admin/pricing/rule-types"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = "PostPricingRuleTypes"
									r.summary = "Create Pricing"
									r.operationID = "PostPricingRuleTypes"
									r.pathPattern = "/admin/pricing/rule-types"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: DeletePricingRuleTypesId
										r.name = "DeletePricingRuleTypesId"
										r.summary = "Remove Rule Types from Pricing"
										r.operationID = "DeletePricingRuleTypesId"
										r.pathPattern = "/admin/pricing/rule-types/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										// Leaf: GetPricingRuleTypesId
										r.name = "GetPricingRuleTypesId"
										r.summary = "List Rule Types"
										r.operationID = "GetPricingRuleTypesId"
										r.pathPattern = "/admin/pricing/rule-types/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										// Leaf: PostPricingRuleTypesId
										r.name = "PostPricingRuleTypesId"
										r.summary = "Add Rule Types to Pricing"
										r.operationID = "PostPricingRuleTypesId"
										r.pathPattern = "/admin/pricing/rule-types/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					case 'o': // Prefix: "o"
						origElem := elem
						if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "ducts"
							origElem := elem
							if l := len("ducts"); len(elem) >= l && elem[0:l] == "ducts" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "GetProducts"
									r.summary = "List Products"
									r.operationID = "GetProducts"
									r.pathPattern = "/admin/products"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = "PostProducts"
									r.summary = "Create Product"
									r.operationID = "PostProducts"
									r.pathPattern = "/admin/products"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = "DeleteProductsId"
										r.summary = "Delete a Product"
										r.operationID = "DeleteProductsId"
										r.pathPattern = "/admin/products/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = "GetProductsId"
										r.summary = "Get a Product"
										r.operationID = "GetProductsId"
										r.pathPattern = "/admin/products/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = "PostProductsId"
										r.summary = "Update a Product"
										r.operationID = "PostProductsId"
										r.pathPattern = "/admin/products/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									origElem := elem
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'o': // Prefix: "options"
										origElem := elem
										if l := len("options"); len(elem) >= l && elem[0:l] == "options" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "GetProductsIdOptions"
												r.summary = "List Options"
												r.operationID = "GetProductsIdOptions"
												r.pathPattern = "/admin/products/{id}/options"
												r.args = args
												r.count = 1
												return r, true
											case "POST":
												r.name = "PostProductsIdOptions"
												r.summary = "Add Options to Product"
												r.operationID = "PostProductsIdOptions"
												r.pathPattern = "/admin/products/{id}/options"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											origElem := elem
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "option_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													// Leaf: DeleteProductsIdOptionsOptionID
													r.name = "DeleteProductsIdOptionsOptionID"
													r.summary = "Remove Options from Product"
													r.operationID = "DeleteProductsIdOptionsOption_id"
													r.pathPattern = "/admin/products/{id}/options/{option_id}"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													// Leaf: GetProductsIdOptionsOptionID
													r.name = "GetProductsIdOptionsOptionID"
													r.summary = "List Options"
													r.operationID = "GetProductsIdOptionsOption_id"
													r.pathPattern = "/admin/products/{id}/options/{option_id}"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													// Leaf: PostProductsIdOptionsOptionID
													r.name = "PostProductsIdOptionsOptionID"
													r.summary = "Add Options to Product"
													r.operationID = "PostProductsIdOptionsOption_id"
													r.pathPattern = "/admin/products/{id}/options/{option_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}

										elem = origElem
									case 'v': // Prefix: "variants"
										origElem := elem
										if l := len("variants"); len(elem) >= l && elem[0:l] == "variants" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "GetProductsIdVariants"
												r.summary = "List Variants"
												r.operationID = "GetProductsIdVariants"
												r.pathPattern = "/admin/products/{id}/variants"
												r.args = args
												r.count = 1
												return r, true
											case "POST":
												r.name = "PostProductsIdVariants"
												r.summary = "Add Variants to Product"
												r.operationID = "PostProductsIdVariants"
												r.pathPattern = "/admin/products/{id}/variants"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											origElem := elem
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "variant_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													// Leaf: DeleteProductsIdVariantsVariantID
													r.name = "DeleteProductsIdVariantsVariantID"
													r.summary = "Remove Variants from Product"
													r.operationID = "DeleteProductsIdVariantsVariant_id"
													r.pathPattern = "/admin/products/{id}/variants/{variant_id}"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													// Leaf: GetProductsIdVariantsVariantID
													r.name = "GetProductsIdVariantsVariantID"
													r.summary = "List Variants"
													r.operationID = "GetProductsIdVariantsVariant_id"
													r.pathPattern = "/admin/products/{id}/variants/{variant_id}"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													// Leaf: PostProductsIdVariantsVariantID
													r.name = "PostProductsIdVariantsVariantID"
													r.summary = "Add Variants to Product"
													r.operationID = "PostProductsIdVariantsVariant_id"
													r.pathPattern = "/admin/products/{id}/variants/{variant_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'm': // Prefix: "motions"
							origElem := elem
							if l := len("motions"); len(elem) >= l && elem[0:l] == "motions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "GetPromotions"
									r.summary = "List Promotions"
									r.operationID = "GetPromotions"
									r.pathPattern = "/admin/promotions"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = "PostPromotions"
									r.summary = "Create Promotion"
									r.operationID = "PostPromotions"
									r.pathPattern = "/admin/promotions"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = "DeletePromotionsId"
										r.summary = "Delete a Promotion"
										r.operationID = "DeletePromotionsId"
										r.pathPattern = "/admin/promotions/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = "GetPromotionsId"
										r.summary = "Get a Promotion"
										r.operationID = "GetPromotionsId"
										r.pathPattern = "/admin/promotions/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = "PostPromotionsId"
										r.summary = "Update a Promotion"
										r.operationID = "PostPromotionsId"
										r.pathPattern = "/admin/promotions/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									origElem := elem
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'b': // Prefix: "buy-rules/batch/"
										origElem := elem
										if l := len("buy-rules/batch/"); len(elem) >= l && elem[0:l] == "buy-rules/batch/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "add"
											origElem := elem
											if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: PostPromotionsIdBuyRulesBatchAdd
													r.name = "PostPromotionsIdBuyRulesBatchAdd"
													r.summary = "Add Adds to Promotion"
													r.operationID = "PostPromotionsIdBuyRulesBatchAdd"
													r.pathPattern = "/admin/promotions/{id}/buy-rules/batch/add"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

											elem = origElem
										case 'r': // Prefix: "remove"
											origElem := elem
											if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: PostPromotionsIdBuyRulesBatchRemove
													r.name = "PostPromotionsIdBuyRulesBatchRemove"
													r.summary = "Add Removes to Promotion"
													r.operationID = "PostPromotionsIdBuyRulesBatchRemove"
													r.pathPattern = "/admin/promotions/{id}/buy-rules/batch/remove"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}

										elem = origElem
									case 'r': // Prefix: "rules/batch/"
										origElem := elem
										if l := len("rules/batch/"); len(elem) >= l && elem[0:l] == "rules/batch/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "add"
											origElem := elem
											if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: PostPromotionsIdRulesBatchAdd
													r.name = "PostPromotionsIdRulesBatchAdd"
													r.summary = "Add Adds to Promotion"
													r.operationID = "PostPromotionsIdRulesBatchAdd"
													r.pathPattern = "/admin/promotions/{id}/rules/batch/add"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

											elem = origElem
										case 'r': // Prefix: "remove"
											origElem := elem
											if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: PostPromotionsIdRulesBatchRemove
													r.name = "PostPromotionsIdRulesBatchRemove"
													r.summary = "Add Removes to Promotion"
													r.operationID = "PostPromotionsIdRulesBatchRemove"
													r.pathPattern = "/admin/promotions/{id}/rules/batch/remove"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

											elem = origElem
										case 'u': // Prefix: "update"
											origElem := elem
											if l := len("update"); len(elem) >= l && elem[0:l] == "update" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: PostPromotionsIdRulesBatchUpdate
													r.name = "PostPromotionsIdRulesBatchUpdate"
													r.summary = "Add Updates to Promotion"
													r.operationID = "PostPromotionsIdRulesBatchUpdate"
													r.pathPattern = "/admin/promotions/{id}/rules/batch/update"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}

										elem = origElem
									case 't': // Prefix: "target-rules/batch/"
										origElem := elem
										if l := len("target-rules/batch/"); len(elem) >= l && elem[0:l] == "target-rules/batch/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "add"
											origElem := elem
											if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: PostPromotionsIdTargetRulesBatchAdd
													r.name = "PostPromotionsIdTargetRulesBatchAdd"
													r.summary = "Add Adds to Promotion"
													r.operationID = "PostPromotionsIdTargetRulesBatchAdd"
													r.pathPattern = "/admin/promotions/{id}/target-rules/batch/add"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

											elem = origElem
										case 'r': // Prefix: "remove"
											origElem := elem
											if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: PostPromotionsIdTargetRulesBatchRemove
													r.name = "PostPromotionsIdTargetRulesBatchRemove"
													r.summary = "Add Removes to Promotion"
													r.operationID = "PostPromotionsIdTargetRulesBatchRemove"
													r.pathPattern = "/admin/promotions/{id}/target-rules/batch/remove"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'r': // Prefix: "regions"
				origElem := elem
				if l := len("regions"); len(elem) >= l && elem[0:l] == "regions" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "GetRegions"
						r.summary = "List Regions"
						r.operationID = "GetRegions"
						r.pathPattern = "/admin/regions"
						r.args = args
						r.count = 0
						return r, true
					case "POST":
						r.name = "PostRegions"
						r.summary = "Create Region"
						r.operationID = "PostRegions"
						r.pathPattern = "/admin/regions"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							// Leaf: DeleteRegionsId
							r.name = "DeleteRegionsId"
							r.summary = "Delete a Region"
							r.operationID = "DeleteRegionsId"
							r.pathPattern = "/admin/regions/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							// Leaf: GetRegionsId
							r.name = "GetRegionsId"
							r.summary = "Get a Region"
							r.operationID = "GetRegionsId"
							r.pathPattern = "/admin/regions/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "POST":
							// Leaf: PostRegionsId
							r.name = "PostRegionsId"
							r.summary = "Update a Region"
							r.operationID = "PostRegionsId"
							r.pathPattern = "/admin/regions/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

					elem = origElem
				}

				elem = origElem
			case 's': // Prefix: "s"
				origElem := elem
				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ales-channels"
					origElem := elem
					if l := len("ales-channels"); len(elem) >= l && elem[0:l] == "ales-channels" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "GetSalesChannels"
							r.summary = "List Sales Channels"
							r.operationID = "GetSalesChannels"
							r.pathPattern = "/admin/sales-channels"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "PostSalesChannels"
							r.summary = "Create Sales Channel"
							r.operationID = "PostSalesChannels"
							r.pathPattern = "/admin/sales-channels"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteSalesChannelsId"
								r.summary = "Delete a Sales Channel"
								r.operationID = "DeleteSalesChannelsId"
								r.pathPattern = "/admin/sales-channels/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "GetSalesChannelsId"
								r.summary = "Get a Sales Channel"
								r.operationID = "GetSalesChannelsId"
								r.pathPattern = "/admin/sales-channels/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								r.name = "PostSalesChannelsId"
								r.summary = "Update a Sales Channel"
								r.operationID = "PostSalesChannelsId"
								r.pathPattern = "/admin/sales-channels/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/products/batch/add"
							origElem := elem
							if l := len("/products/batch/add"); len(elem) >= l && elem[0:l] == "/products/batch/add" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: PostSalesChannelsIdProductsBatchAdd
									r.name = "PostSalesChannelsIdProductsBatchAdd"
									r.summary = "Add Adds to Sales Channel"
									r.operationID = "PostSalesChannelsIdProductsBatchAdd"
									r.pathPattern = "/admin/sales-channels/{id}/products/batch/add"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 't': // Prefix: "to"
					origElem := elem
					if l := len("to"); len(elem) >= l && elem[0:l] == "to" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "ck-locations"
						origElem := elem
						if l := len("ck-locations"); len(elem) >= l && elem[0:l] == "ck-locations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								r.name = "PostStockLocations"
								r.summary = "Create Stock Location"
								r.operationID = "PostStockLocations"
								r.pathPattern = "/admin/stock-locations"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: DeleteStockLocationsId
									r.name = "DeleteStockLocationsId"
									r.summary = "Delete a Stock Location"
									r.operationID = "DeleteStockLocationsId"
									r.pathPattern = "/admin/stock-locations/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									// Leaf: GetStockLocationsId
									r.name = "GetStockLocationsId"
									r.summary = "Get a Stock Location"
									r.operationID = "GetStockLocationsId"
									r.pathPattern = "/admin/stock-locations/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					case 'r': // Prefix: "res"
						origElem := elem
						if l := len("res"); len(elem) >= l && elem[0:l] == "res" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "GetStores"
								r.summary = "List Stores"
								r.operationID = "GetStores"
								r.pathPattern = "/admin/stores"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GetStoresId
									r.name = "GetStoresId"
									r.summary = "Get a Store"
									r.operationID = "GetStoresId"
									r.pathPattern = "/admin/stores/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "POST":
									// Leaf: PostStoresId
									r.name = "PostStoresId"
									r.summary = "Update a Store"
									r.operationID = "PostStoresId"
									r.pathPattern = "/admin/stores/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 't': // Prefix: "tax-r"
				origElem := elem
				if l := len("tax-r"); len(elem) >= l && elem[0:l] == "tax-r" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ates"
					origElem := elem
					if l := len("ates"); len(elem) >= l && elem[0:l] == "ates" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "GetTaxRates"
							r.summary = "List Tax Rates"
							r.operationID = "GetTaxRates"
							r.pathPattern = "/admin/tax-rates"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "PostTaxRates"
							r.summary = "Create Tax Rate"
							r.operationID = "PostTaxRates"
							r.pathPattern = "/admin/tax-rates"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteTaxRatesId"
								r.summary = "Delete a Tax Rate"
								r.operationID = "DeleteTaxRatesId"
								r.pathPattern = "/admin/tax-rates/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "GetTaxRatesId"
								r.summary = "Get a Tax Rate"
								r.operationID = "GetTaxRatesId"
								r.pathPattern = "/admin/tax-rates/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								r.name = "PostTaxRatesId"
								r.summary = "Update a Tax Rate"
								r.operationID = "PostTaxRatesId"
								r.pathPattern = "/admin/tax-rates/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/rules"
							origElem := elem
							if l := len("/rules"); len(elem) >= l && elem[0:l] == "/rules" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									r.name = "PostTaxRatesIdRules"
									r.summary = "Add Rules to Tax Rate"
									r.operationID = "PostTaxRatesIdRules"
									r.pathPattern = "/admin/tax-rates/{id}/rules"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "rule_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: DeleteTaxRatesIdRulesRuleID
										r.name = "DeleteTaxRatesIdRulesRuleID"
										r.summary = "Remove Rules from Tax Rate"
										r.operationID = "DeleteTaxRatesIdRulesRule_id"
										r.pathPattern = "/admin/tax-rates/{id}/rules/{rule_id}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'e': // Prefix: "egions"
					origElem := elem
					if l := len("egions"); len(elem) >= l && elem[0:l] == "egions" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "POST":
							r.name = "PostTaxRegions"
							r.summary = "Create Tax Region"
							r.operationID = "PostTaxRegions"
							r.pathPattern = "/admin/tax-regions"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: DeleteTaxRegionsId
								r.name = "DeleteTaxRegionsId"
								r.summary = "Delete a Tax Region"
								r.operationID = "DeleteTaxRegionsId"
								r.pathPattern = "/admin/tax-regions/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'u': // Prefix: "users"
				origElem := elem
				if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "GetUsers"
						r.summary = "List Users"
						r.operationID = "GetUsers"
						r.pathPattern = "/admin/users"
						r.args = args
						r.count = 0
						return r, true
					case "POST":
						r.name = "PostUsers"
						r.summary = "Create User"
						r.operationID = "PostUsers"
						r.pathPattern = "/admin/users"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'm': // Prefix: "me"
						origElem := elem
						if l := len("me"); len(elem) >= l && elem[0:l] == "me" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetUsersMe
								r.name = "GetUsersMe"
								r.summary = "List Users"
								r.operationID = "GetUsersMe"
								r.pathPattern = "/admin/users/me"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}
					// Param: "id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							// Leaf: DeleteUsersId
							r.name = "DeleteUsersId"
							r.summary = "Delete a User"
							r.operationID = "DeleteUsersId"
							r.pathPattern = "/admin/users/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							// Leaf: GetUsersId
							r.name = "GetUsersId"
							r.summary = "Get a User"
							r.operationID = "GetUsersId"
							r.pathPattern = "/admin/users/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "POST":
							// Leaf: PostUsersId
							r.name = "PostUsersId"
							r.summary = "Update a User"
							r.operationID = "PostUsersId"
							r.pathPattern = "/admin/users/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

					elem = origElem
				}

				elem = origElem
			case 'w': // Prefix: "workflows-executions"
				origElem := elem
				if l := len("workflows-executions"); len(elem) >= l && elem[0:l] == "workflows-executions" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "GetWorkflowsExecutions"
						r.summary = "List Workflows Executions"
						r.operationID = "GetWorkflowsExecutions"
						r.pathPattern = "/admin/workflows-executions"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "GetWorkflowsExecutionsId"
							r.summary = "Get a Workflows Execution"
							r.operationID = "GetWorkflowsExecutionsId"
							r.pathPattern = "/admin/workflows-executions/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'r': // Prefix: "run"
							origElem := elem
							if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: PostWorkflowsExecutionsWorkflowIdRun
									r.name = "PostWorkflowsExecutionsWorkflowIdRun"
									r.summary = "Add Runs to Workflows Execution"
									r.operationID = "PostWorkflowsExecutionsWorkflow_idRun"
									r.pathPattern = "/admin/workflows-executions/{workflow_id}/run"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 's': // Prefix: "s"
							origElem := elem
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 't': // Prefix: "teps/"
								origElem := elem
								if l := len("teps/"); len(elem) >= l && elem[0:l] == "teps/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'f': // Prefix: "failure"
									origElem := elem
									if l := len("failure"); len(elem) >= l && elem[0:l] == "failure" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: PostWorkflowsExecutionsWorkflowIdStepsFailure
											r.name = "PostWorkflowsExecutionsWorkflowIdStepsFailure"
											r.summary = "Add Failures to Workflows Execution"
											r.operationID = "PostWorkflowsExecutionsWorkflow_idStepsFailure"
											r.pathPattern = "/admin/workflows-executions/{workflow_id}/steps/failure"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 's': // Prefix: "success"
									origElem := elem
									if l := len("success"); len(elem) >= l && elem[0:l] == "success" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: PostWorkflowsExecutionsWorkflowIdStepsSuccess
											r.name = "PostWorkflowsExecutionsWorkflowIdStepsSuccess"
											r.summary = "Add Successes to Workflows Execution"
											r.operationID = "PostWorkflowsExecutionsWorkflow_idStepsSuccess"
											r.pathPattern = "/admin/workflows-executions/{workflow_id}/steps/success"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}

								elem = origElem
							case 'u': // Prefix: "ubscribe"
								origElem := elem
								if l := len("ubscribe"); len(elem) >= l && elem[0:l] == "ubscribe" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetWorkflowsExecutionsWorkflowIdSubscribe
										r.name = "GetWorkflowsExecutionsWorkflowIdSubscribe"
										r.summary = "List Subscribes"
										r.operationID = "GetWorkflowsExecutionsWorkflow_idSubscribe"
										r.pathPattern = "/admin/workflows-executions/{workflow_id}/subscribe"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						}
						// Param: "transaction_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "GetWorkflowsExecutionsWorkflowIdTransactionID"
								r.summary = "List "
								r.operationID = "GetWorkflowsExecutionsWorkflow_idTransaction_id"
								r.pathPattern = "/admin/workflows-executions/{workflow_id}/{transaction_id}"
								r.args = args
								r.count = 2
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "step_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[2] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/subscribe"
								origElem := elem
								if l := len("/subscribe"); len(elem) >= l && elem[0:l] == "/subscribe" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe
										r.name = "GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe"
										r.summary = "List Subscribes"
										r.operationID = "GetWorkflowsExecutionsWorkflow_idTransaction_idStep_idSubscribe"
										r.pathPattern = "/admin/workflows-executions/{workflow_id}/{transaction_id}/{step_id}/subscribe"
										r.args = args
										r.count = 3
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			}

			elem = origElem
		}
	}
	return r, false
}
