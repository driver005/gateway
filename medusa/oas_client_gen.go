// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// DeleteApiKeysId invokes DeleteApiKeysId operation.
	//
	// Delete a api key.
	//
	// DELETE /admin/api-keys/{id}
	DeleteApiKeysId(ctx context.Context, request jx.Raw, params DeleteApiKeysIdParams) (DeleteApiKeysIdRes, error)
	// DeleteCampaignsId invokes DeleteCampaignsId operation.
	//
	// Delete a campaign.
	//
	// DELETE /admin/campaigns/{id}
	DeleteCampaignsId(ctx context.Context, request jx.Raw, params DeleteCampaignsIdParams) (DeleteCampaignsIdRes, error)
	// DeleteCollectionsId invokes DeleteCollectionsId operation.
	//
	// Delete a collection.
	//
	// DELETE /admin/collections/{id}
	DeleteCollectionsId(ctx context.Context, request jx.Raw, params DeleteCollectionsIdParams) (DeleteCollectionsIdRes, error)
	// DeleteCustomerGroupsId invokes DeleteCustomerGroupsId operation.
	//
	// Delete a customer group.
	//
	// DELETE /admin/customer-groups/{id}
	DeleteCustomerGroupsId(ctx context.Context, request jx.Raw, params DeleteCustomerGroupsIdParams) (DeleteCustomerGroupsIdRes, error)
	// DeleteCustomersId invokes DeleteCustomersId operation.
	//
	// Delete a customer.
	//
	// DELETE /admin/customers/{id}
	DeleteCustomersId(ctx context.Context, request jx.Raw, params DeleteCustomersIdParams) (DeleteCustomersIdRes, error)
	// DeleteCustomersIdAddressesAddressID invokes DeleteCustomersIdAddressesAddress_id operation.
	//
	// Remove a list of addresses from a customer. This doesn't delete the Address, only the association
	// between the Address and the customer.
	//
	// DELETE /admin/customers/{id}/addresses/{address_id}
	DeleteCustomersIdAddressesAddressID(ctx context.Context, request jx.Raw, params DeleteCustomersIdAddressesAddressIDParams) (DeleteCustomersIdAddressesAddressIDRes, error)
	// DeleteInventoryItemsId invokes DeleteInventoryItemsId operation.
	//
	// Delete a inventory item.
	//
	// DELETE /admin/inventory-items/{id}
	DeleteInventoryItemsId(ctx context.Context, request jx.Raw, params DeleteInventoryItemsIdParams) (DeleteInventoryItemsIdRes, error)
	// DeleteInventoryItemsIdLocationLevelsLocationID invokes DeleteInventoryItemsIdLocationLevelsLocation_id operation.
	//
	// Remove a list of location levels from a inventory item. This doesn't delete the Location Level,
	// only the association between the Location Level and the inventory item.
	//
	// DELETE /admin/inventory-items/{id}/location-levels/{location_id}
	DeleteInventoryItemsIdLocationLevelsLocationID(ctx context.Context, request jx.Raw, params DeleteInventoryItemsIdLocationLevelsLocationIDParams) (DeleteInventoryItemsIdLocationLevelsLocationIDRes, error)
	// DeleteInvitesId invokes DeleteInvitesId operation.
	//
	// Delete a invite.
	//
	// DELETE /admin/invites/{id}
	DeleteInvitesId(ctx context.Context, request jx.Raw, params DeleteInvitesIdParams) (DeleteInvitesIdRes, error)
	// DeletePriceListsId invokes DeletePriceListsId operation.
	//
	// Delete a price list.
	//
	// DELETE /admin/price-lists/{id}
	DeletePriceListsId(ctx context.Context, request jx.Raw, params DeletePriceListsIdParams) (DeletePriceListsIdRes, error)
	// DeletePricingRuleTypesId invokes DeletePricingRuleTypesId operation.
	//
	// Remove a list of rule types from a pricing. This doesn't delete the Rule Type, only the
	// association between the Rule Type and the pricing.
	//
	// DELETE /admin/pricing/rule-types/{id}
	DeletePricingRuleTypesId(ctx context.Context, request *AdminDeletePricingRuleTypesRuleTypeReq, params DeletePricingRuleTypesIdParams) (DeletePricingRuleTypesIdRes, error)
	// DeleteProductsId invokes DeleteProductsId operation.
	//
	// Delete a product.
	//
	// DELETE /admin/products/{id}
	DeleteProductsId(ctx context.Context, request jx.Raw, params DeleteProductsIdParams) (DeleteProductsIdRes, error)
	// DeleteProductsIdOptionsOptionID invokes DeleteProductsIdOptionsOption_id operation.
	//
	// Remove a list of options from a product. This doesn't delete the Option, only the association
	// between the Option and the product.
	//
	// DELETE /admin/products/{id}/options/{option_id}
	DeleteProductsIdOptionsOptionID(ctx context.Context, request jx.Raw, params DeleteProductsIdOptionsOptionIDParams) (DeleteProductsIdOptionsOptionIDRes, error)
	// DeleteProductsIdVariantsVariantID invokes DeleteProductsIdVariantsVariant_id operation.
	//
	// Remove a list of variants from a product. This doesn't delete the Variant, only the association
	// between the Variant and the product.
	//
	// DELETE /admin/products/{id}/variants/{variant_id}
	DeleteProductsIdVariantsVariantID(ctx context.Context, request jx.Raw, params DeleteProductsIdVariantsVariantIDParams) (DeleteProductsIdVariantsVariantIDRes, error)
	// DeletePromotionsId invokes DeletePromotionsId operation.
	//
	// Delete a promotion.
	//
	// DELETE /admin/promotions/{id}
	DeletePromotionsId(ctx context.Context, request jx.Raw, params DeletePromotionsIdParams) (DeletePromotionsIdRes, error)
	// DeleteRegionsId invokes DeleteRegionsId operation.
	//
	// Delete a region.
	//
	// DELETE /admin/regions/{id}
	DeleteRegionsId(ctx context.Context, request jx.Raw, params DeleteRegionsIdParams) (DeleteRegionsIdRes, error)
	// DeleteSalesChannelsId invokes DeleteSalesChannelsId operation.
	//
	// Delete a sales channel.
	//
	// DELETE /admin/sales-channels/{id}
	DeleteSalesChannelsId(ctx context.Context, request jx.Raw, params DeleteSalesChannelsIdParams) (DeleteSalesChannelsIdRes, error)
	// DeleteStockLocationsId invokes DeleteStockLocationsId operation.
	//
	// Delete a stock location.
	//
	// DELETE /admin/stock-locations/{id}
	DeleteStockLocationsId(ctx context.Context, params DeleteStockLocationsIdParams) (DeleteStockLocationsIdRes, error)
	// DeleteTaxRatesId invokes DeleteTaxRatesId operation.
	//
	// Delete a tax rate.
	//
	// DELETE /admin/tax-rates/{id}
	DeleteTaxRatesId(ctx context.Context, request jx.Raw, params DeleteTaxRatesIdParams) (DeleteTaxRatesIdRes, error)
	// DeleteTaxRatesIdRulesRuleID invokes DeleteTaxRatesIdRulesRule_id operation.
	//
	// Remove a list of rules from a tax rate. This doesn't delete the Rule, only the association between
	// the Rule and the tax rate.
	//
	// DELETE /admin/tax-rates/{id}/rules/{rule_id}
	DeleteTaxRatesIdRulesRuleID(ctx context.Context, request jx.Raw, params DeleteTaxRatesIdRulesRuleIDParams) (DeleteTaxRatesIdRulesRuleIDRes, error)
	// DeleteTaxRegionsId invokes DeleteTaxRegionsId operation.
	//
	// Delete a tax region.
	//
	// DELETE /admin/tax-regions/{id}
	DeleteTaxRegionsId(ctx context.Context, request jx.Raw, params DeleteTaxRegionsIdParams) (DeleteTaxRegionsIdRes, error)
	// DeleteUsersId invokes DeleteUsersId operation.
	//
	// Delete a user.
	//
	// DELETE /admin/users/{id}
	DeleteUsersId(ctx context.Context, request jx.Raw, params DeleteUsersIdParams) (DeleteUsersIdRes, error)
	// GetApiKeys invokes GetApiKeys operation.
	//
	// Retrieve a list of api keys. The api keys can be filtered by fields such as `id`. The api keys can
	// also be sorted or paginated.
	//
	// GET /admin/api-keys
	GetApiKeys(ctx context.Context, request jx.Raw) (GetApiKeysRes, error)
	// GetApiKeysId invokes GetApiKeysId operation.
	//
	// Retrieve a api key by its ID. You can expand the api key's relations or select the fields that
	// should be returned.
	//
	// GET /admin/api-keys/{id}
	GetApiKeysId(ctx context.Context, request jx.Raw, params GetApiKeysIdParams) (GetApiKeysIdRes, error)
	// GetCampaigns invokes GetCampaigns operation.
	//
	// Retrieve a list of campaigns. The campaigns can be filtered by fields such as `id`. The campaigns
	// can also be sorted or paginated.
	//
	// GET /admin/campaigns
	GetCampaigns(ctx context.Context, request jx.Raw) (GetCampaignsRes, error)
	// GetCampaignsId invokes GetCampaignsId operation.
	//
	// Retrieve a campaign by its ID. You can expand the campaign's relations or select the fields that
	// should be returned.
	//
	// GET /admin/campaigns/{id}
	GetCampaignsId(ctx context.Context, request jx.Raw, params GetCampaignsIdParams) (GetCampaignsIdRes, error)
	// GetCollections invokes GetCollections operation.
	//
	// Retrieve a list of collections. The collections can be filtered by fields such as `id`. The
	// collections can also be sorted or paginated.
	//
	// GET /admin/collections
	GetCollections(ctx context.Context, request jx.Raw) (GetCollectionsRes, error)
	// GetCollectionsId invokes GetCollectionsId operation.
	//
	// Retrieve a collection by its ID. You can expand the collection's relations or select the fields
	// that should be returned.
	//
	// GET /admin/collections/{id}
	GetCollectionsId(ctx context.Context, request jx.Raw, params GetCollectionsIdParams) (GetCollectionsIdRes, error)
	// GetCurrencies invokes GetCurrencies operation.
	//
	// Retrieve a list of currencies. The currencies can be filtered by fields such as `id`. The
	// currencies can also be sorted or paginated.
	//
	// GET /admin/currencies
	GetCurrencies(ctx context.Context, request jx.Raw) (GetCurrenciesRes, error)
	// GetCurrenciesCode invokes GetCurrenciesCode operation.
	//
	// Retrieve a currency by its ID. You can expand the currency's relations or select the fields that
	// should be returned.
	//
	// GET /admin/currencies/{code}
	GetCurrenciesCode(ctx context.Context, request jx.Raw, params GetCurrenciesCodeParams) (GetCurrenciesCodeRes, error)
	// GetCustomerGroups invokes GetCustomerGroups operation.
	//
	// Retrieve a list of customer groups. The customer groups can be filtered by fields such as `id`.
	// The customer groups can also be sorted or paginated.
	//
	// GET /admin/customer-groups
	GetCustomerGroups(ctx context.Context, request jx.Raw) (GetCustomerGroupsRes, error)
	// GetCustomerGroupsId invokes GetCustomerGroupsId operation.
	//
	// Retrieve a customer group by its ID. You can expand the customer group's relations or select the
	// fields that should be returned.
	//
	// GET /admin/customer-groups/{id}
	GetCustomerGroupsId(ctx context.Context, request jx.Raw, params GetCustomerGroupsIdParams) (GetCustomerGroupsIdRes, error)
	// GetCustomerGroupsIdCustomers invokes GetCustomerGroupsIdCustomers operation.
	//
	// Retrieve a list of customers in a customer group. The customers can be filtered by fields like
	// FILTER FIELDS. The customers can also be paginated.
	//
	// GET /admin/customer-groups/{id}/customers
	GetCustomerGroupsIdCustomers(ctx context.Context, request jx.Raw, params GetCustomerGroupsIdCustomersParams) (GetCustomerGroupsIdCustomersRes, error)
	// GetCustomers invokes GetCustomers operation.
	//
	// Retrieve a list of customers. The customers can be filtered by fields such as `id`. The customers
	// can also be sorted or paginated.
	//
	// GET /admin/customers
	GetCustomers(ctx context.Context, request jx.Raw) (GetCustomersRes, error)
	// GetCustomersId invokes GetCustomersId operation.
	//
	// Retrieve a customer by its ID. You can expand the customer's relations or select the fields that
	// should be returned.
	//
	// GET /admin/customers/{id}
	GetCustomersId(ctx context.Context, request jx.Raw, params GetCustomersIdParams) (GetCustomersIdRes, error)
	// GetCustomersIdAddresses invokes GetCustomersIdAddresses operation.
	//
	// Retrieve a list of addresses in a customer. The addresses can be filtered by fields like FILTER
	// FIELDS. The addresses can also be paginated.
	//
	// GET /admin/customers/{id}/addresses
	GetCustomersIdAddresses(ctx context.Context, request jx.Raw, params GetCustomersIdAddressesParams) (GetCustomersIdAddressesRes, error)
	// GetCustomersIdAddressesAddressID invokes GetCustomersIdAddressesAddress_id operation.
	//
	// Retrieve a list of addresses in a customer. The addresses can be filtered by fields like FILTER
	// FIELDS. The addresses can also be paginated.
	//
	// GET /admin/customers/{id}/addresses/{address_id}
	GetCustomersIdAddressesAddressID(ctx context.Context, request jx.Raw, params GetCustomersIdAddressesAddressIDParams) (GetCustomersIdAddressesAddressIDRes, error)
	// GetInventoryItems invokes GetInventoryItems operation.
	//
	// Retrieve a list of inventory items. The inventory items can be filtered by fields such as `id`.
	// The inventory items can also be sorted or paginated.
	//
	// GET /admin/inventory-items
	GetInventoryItems(ctx context.Context, request jx.Raw) (GetInventoryItemsRes, error)
	// GetInventoryItemsId invokes GetInventoryItemsId operation.
	//
	// Retrieve a inventory item by its ID. You can expand the inventory item's relations or select the
	// fields that should be returned.
	//
	// GET /admin/inventory-items/{id}
	GetInventoryItemsId(ctx context.Context, request jx.Raw, params GetInventoryItemsIdParams) (GetInventoryItemsIdRes, error)
	// GetInvites invokes GetInvites operation.
	//
	// Retrieve a list of invites. The invites can be filtered by fields such as `id`. The invites can
	// also be sorted or paginated.
	//
	// GET /admin/invites
	GetInvites(ctx context.Context, request jx.Raw) (GetInvitesRes, error)
	// GetInvitesId invokes GetInvitesId operation.
	//
	// Retrieve a invite by its ID. You can expand the invite's relations or select the fields that
	// should be returned.
	//
	// GET /admin/invites/{id}
	GetInvitesId(ctx context.Context, request jx.Raw, params GetInvitesIdParams) (GetInvitesIdRes, error)
	// GetPayments invokes GetPayments operation.
	//
	// Retrieve a list of payments. The payments can be filtered by fields such as `id`. The payments can
	// also be sorted or paginated.
	//
	// GET /admin/payments
	GetPayments(ctx context.Context, request jx.Raw) (GetPaymentsRes, error)
	// GetPaymentsId invokes GetPaymentsId operation.
	//
	// Retrieve a payment by its ID. You can expand the payment's relations or select the fields that
	// should be returned.
	//
	// GET /admin/payments/{id}
	GetPaymentsId(ctx context.Context, request jx.Raw, params GetPaymentsIdParams) (GetPaymentsIdRes, error)
	// GetPriceLists invokes GetPriceLists operation.
	//
	// Retrieve a list of price lists. The price lists can be filtered by fields such as `id`. The price
	// lists can also be sorted or paginated.
	//
	// GET /admin/price-lists
	GetPriceLists(ctx context.Context, request jx.Raw) (GetPriceListsRes, error)
	// GetPriceListsId invokes GetPriceListsId operation.
	//
	// Retrieve a price list by its ID. You can expand the price list's relations or select the fields
	// that should be returned.
	//
	// GET /admin/price-lists/{id}
	GetPriceListsId(ctx context.Context, request jx.Raw, params GetPriceListsIdParams) (GetPriceListsIdRes, error)
	// GetPricingRuleTypes invokes GetPricingRuleTypes operation.
	//
	// Retrieve a list of pricing. The pricing can be filtered by fields such as `id`. The pricing can
	// also be sorted or paginated.
	//
	// GET /admin/pricing/rule-types
	GetPricingRuleTypes(ctx context.Context, request OptAdminGetPricingRuleTypesParams) (GetPricingRuleTypesRes, error)
	// GetPricingRuleTypesId invokes GetPricingRuleTypesId operation.
	//
	// Retrieve a list of rule types in a pricing. The rule types can be filtered by fields like FILTER
	// FIELDS. The rule types can also be paginated.
	//
	// GET /admin/pricing/rule-types/{id}
	GetPricingRuleTypesId(ctx context.Context, request OptAdminGetPricingRuleTypesRuleTypeParams, params GetPricingRuleTypesIdParams) (GetPricingRuleTypesIdRes, error)
	// GetProducts invokes GetProducts operation.
	//
	// Retrieve a list of products. The products can be filtered by fields such as `id`. The products can
	// also be sorted or paginated.
	//
	// GET /admin/products
	GetProducts(ctx context.Context, request OptAdminGetProductsParams) (GetProductsRes, error)
	// GetProductsId invokes GetProductsId operation.
	//
	// Retrieve a product by its ID. You can expand the product's relations or select the fields that
	// should be returned.
	//
	// GET /admin/products/{id}
	GetProductsId(ctx context.Context, request jx.Raw, params GetProductsIdParams) (GetProductsIdRes, error)
	// GetProductsIdOptions invokes GetProductsIdOptions operation.
	//
	// Retrieve a list of options in a product. The options can be filtered by fields like FILTER FIELDS.
	// The options can also be paginated.
	//
	// GET /admin/products/{id}/options
	GetProductsIdOptions(ctx context.Context, request jx.Raw, params GetProductsIdOptionsParams) (GetProductsIdOptionsRes, error)
	// GetProductsIdOptionsOptionID invokes GetProductsIdOptionsOption_id operation.
	//
	// Retrieve a list of options in a product. The options can be filtered by fields like FILTER FIELDS.
	// The options can also be paginated.
	//
	// GET /admin/products/{id}/options/{option_id}
	GetProductsIdOptionsOptionID(ctx context.Context, request jx.Raw, params GetProductsIdOptionsOptionIDParams) (GetProductsIdOptionsOptionIDRes, error)
	// GetProductsIdVariants invokes GetProductsIdVariants operation.
	//
	// Retrieve a list of variants in a product. The variants can be filtered by fields like FILTER
	// FIELDS. The variants can also be paginated.
	//
	// GET /admin/products/{id}/variants
	GetProductsIdVariants(ctx context.Context, request jx.Raw, params GetProductsIdVariantsParams) (GetProductsIdVariantsRes, error)
	// GetProductsIdVariantsVariantID invokes GetProductsIdVariantsVariant_id operation.
	//
	// Retrieve a list of variants in a product. The variants can be filtered by fields like FILTER
	// FIELDS. The variants can also be paginated.
	//
	// GET /admin/products/{id}/variants/{variant_id}
	GetProductsIdVariantsVariantID(ctx context.Context, request jx.Raw, params GetProductsIdVariantsVariantIDParams) (GetProductsIdVariantsVariantIDRes, error)
	// GetPromotions invokes GetPromotions operation.
	//
	// Retrieve a list of promotions. The promotions can be filtered by fields such as `id`. The
	// promotions can also be sorted or paginated.
	//
	// GET /admin/promotions
	GetPromotions(ctx context.Context, request jx.Raw) (GetPromotionsRes, error)
	// GetPromotionsId invokes GetPromotionsId operation.
	//
	// Retrieve a promotion by its ID. You can expand the promotion's relations or select the fields that
	// should be returned.
	//
	// GET /admin/promotions/{id}
	GetPromotionsId(ctx context.Context, request OptAdminGetPromotionsParams, params GetPromotionsIdParams) (GetPromotionsIdRes, error)
	// GetRegions invokes GetRegions operation.
	//
	// Retrieve a list of regions. The regions can be filtered by fields such as `id`. The regions can
	// also be sorted or paginated.
	//
	// GET /admin/regions
	GetRegions(ctx context.Context, request jx.Raw) (GetRegionsRes, error)
	// GetRegionsId invokes GetRegionsId operation.
	//
	// Retrieve a region by its ID. You can expand the region's relations or select the fields that
	// should be returned.
	//
	// GET /admin/regions/{id}
	GetRegionsId(ctx context.Context, request jx.Raw, params GetRegionsIdParams) (GetRegionsIdRes, error)
	// GetSalesChannels invokes GetSalesChannels operation.
	//
	// Retrieve a list of sales channels. The sales channels can be filtered by fields such as `id`. The
	// sales channels can also be sorted or paginated.
	//
	// GET /admin/sales-channels
	GetSalesChannels(ctx context.Context, request jx.Raw) (GetSalesChannelsRes, error)
	// GetSalesChannelsId invokes GetSalesChannelsId operation.
	//
	// Retrieve a sales channel by its ID. You can expand the sales channel's relations or select the
	// fields that should be returned.
	//
	// GET /admin/sales-channels/{id}
	GetSalesChannelsId(ctx context.Context, request jx.Raw, params GetSalesChannelsIdParams) (GetSalesChannelsIdRes, error)
	// GetStockLocationsId invokes GetStockLocationsId operation.
	//
	// Retrieve a stock location by its ID. You can expand the stock location's relations or select the
	// fields that should be returned.
	//
	// GET /admin/stock-locations/{id}
	GetStockLocationsId(ctx context.Context, params GetStockLocationsIdParams) (GetStockLocationsIdRes, error)
	// GetStores invokes GetStores operation.
	//
	// Retrieve a list of stores. The stores can be filtered by fields such as `id`. The stores can also
	// be sorted or paginated.
	//
	// GET /admin/stores
	GetStores(ctx context.Context, request jx.Raw) (GetStoresRes, error)
	// GetStoresId invokes GetStoresId operation.
	//
	// Retrieve a store by its ID. You can expand the store's relations or select the fields that should
	// be returned.
	//
	// GET /admin/stores/{id}
	GetStoresId(ctx context.Context, request jx.Raw, params GetStoresIdParams) (GetStoresIdRes, error)
	// GetTaxRates invokes GetTaxRates operation.
	//
	// Retrieve a list of tax rates. The tax rates can be filtered by fields such as `id`. The tax rates
	// can also be sorted or paginated.
	//
	// GET /admin/tax-rates
	GetTaxRates(ctx context.Context, request jx.Raw) (GetTaxRatesRes, error)
	// GetTaxRatesId invokes GetTaxRatesId operation.
	//
	// Retrieve a tax rate by its ID. You can expand the tax rate's relations or select the fields that
	// should be returned.
	//
	// GET /admin/tax-rates/{id}
	GetTaxRatesId(ctx context.Context, request jx.Raw, params GetTaxRatesIdParams) (GetTaxRatesIdRes, error)
	// GetUsers invokes GetUsers operation.
	//
	// Retrieve a list of users. The users can be filtered by fields such as `id`. The users can also be
	// sorted or paginated.
	//
	// GET /admin/users
	GetUsers(ctx context.Context, request jx.Raw) (GetUsersRes, error)
	// GetUsersId invokes GetUsersId operation.
	//
	// Retrieve a user by its ID. You can expand the user's relations or select the fields that should be
	// returned.
	//
	// GET /admin/users/{id}
	GetUsersId(ctx context.Context, request jx.Raw, params GetUsersIdParams) (GetUsersIdRes, error)
	// GetUsersMe invokes GetUsersMe operation.
	//
	// Retrieve a list of users. The users can be filtered by fields such as `id`. The users can also be
	// sorted or paginated.
	//
	// GET /admin/users/me
	GetUsersMe(ctx context.Context, request jx.Raw) (GetUsersMeRes, error)
	// GetWorkflowsExecutions invokes GetWorkflowsExecutions operation.
	//
	// Retrieve a list of workflows executions. The workflows executions can be filtered by fields such
	// as `id`. The workflows executions can also be sorted or paginated.
	//
	// GET /admin/workflows-executions
	GetWorkflowsExecutions(ctx context.Context, request jx.Raw) (GetWorkflowsExecutionsRes, error)
	// GetWorkflowsExecutionsId invokes GetWorkflowsExecutionsId operation.
	//
	// Retrieve a workflows execution by its ID. You can expand the workflows execution's relations or
	// select the fields that should be returned.
	//
	// GET /admin/workflows-executions/{id}
	GetWorkflowsExecutionsId(ctx context.Context, request jx.Raw, params GetWorkflowsExecutionsIdParams) (GetWorkflowsExecutionsIdRes, error)
	// GetWorkflowsExecutionsWorkflowIdSubscribe invokes GetWorkflowsExecutionsWorkflow_idSubscribe operation.
	//
	// Retrieve a list of subscribes in a workflows execution. The subscribes can be filtered by fields
	// like FILTER FIELDS. The subscribes can also be paginated.
	//
	// GET /admin/workflows-executions/{workflow_id}/subscribe
	GetWorkflowsExecutionsWorkflowIdSubscribe(ctx context.Context, request jx.Raw, params GetWorkflowsExecutionsWorkflowIdSubscribeParams) (GetWorkflowsExecutionsWorkflowIdSubscribeRes, error)
	// GetWorkflowsExecutionsWorkflowIdTransactionID invokes GetWorkflowsExecutionsWorkflow_idTransaction_id operation.
	//
	// Retrieve a list of  in a workflows execution. The  can be filtered by fields like FILTER FIELDS.
	// The  can also be paginated.
	//
	// GET /admin/workflows-executions/{workflow_id}/{transaction_id}
	GetWorkflowsExecutionsWorkflowIdTransactionID(ctx context.Context, request jx.Raw, params GetWorkflowsExecutionsWorkflowIdTransactionIDParams) (GetWorkflowsExecutionsWorkflowIdTransactionIDRes, error)
	// GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe invokes GetWorkflowsExecutionsWorkflow_idTransaction_idStep_idSubscribe operation.
	//
	// Retrieve a list of subscribes in a workflows execution. The subscribes can be filtered by fields
	// like FILTER FIELDS. The subscribes can also be paginated.
	//
	// GET /admin/workflows-executions/{workflow_id}/{transaction_id}/{step_id}/subscribe
	GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe(ctx context.Context, request jx.Raw, params GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeParams) (GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeRes, error)
	// PostApiKeys invokes PostApiKeys operation.
	//
	// Create a api key.
	//
	// POST /admin/api-keys
	PostApiKeys(ctx context.Context, request jx.Raw) (PostApiKeysRes, error)
	// PostApiKeysId invokes PostApiKeysId operation.
	//
	// Update a api key's details.
	//
	// POST /admin/api-keys/{id}
	PostApiKeysId(ctx context.Context, request jx.Raw, params PostApiKeysIdParams) (PostApiKeysIdRes, error)
	// PostApiKeysIdRevoke invokes PostApiKeysIdRevoke operation.
	//
	// Add a list of revokes to a api key.
	//
	// POST /admin/api-keys/{id}/revoke
	PostApiKeysIdRevoke(ctx context.Context, request jx.Raw, params PostApiKeysIdRevokeParams) (PostApiKeysIdRevokeRes, error)
	// PostCampaigns invokes PostCampaigns operation.
	//
	// Create a campaign.
	//
	// POST /admin/campaigns
	PostCampaigns(ctx context.Context, request jx.Raw) (PostCampaignsRes, error)
	// PostCampaignsId invokes PostCampaignsId operation.
	//
	// Update a campaign's details.
	//
	// POST /admin/campaigns/{id}
	PostCampaignsId(ctx context.Context, request OptAdminPostCampaignsReq, params PostCampaignsIdParams) (PostCampaignsIdRes, error)
	// PostCollections invokes PostCollections operation.
	//
	// Create a collection.
	//
	// POST /admin/collections
	PostCollections(ctx context.Context, request jx.Raw) (PostCollectionsRes, error)
	// PostCollectionsId invokes PostCollectionsId operation.
	//
	// Update a collection's details.
	//
	// POST /admin/collections/{id}
	PostCollectionsId(ctx context.Context, request jx.Raw, params PostCollectionsIdParams) (PostCollectionsIdRes, error)
	// PostCustomerGroups invokes PostCustomerGroups operation.
	//
	// Create a customer group.
	//
	// POST /admin/customer-groups
	PostCustomerGroups(ctx context.Context, request jx.Raw) (PostCustomerGroupsRes, error)
	// PostCustomerGroupsId invokes PostCustomerGroupsId operation.
	//
	// Update a customer group's details.
	//
	// POST /admin/customer-groups/{id}
	PostCustomerGroupsId(ctx context.Context, request jx.Raw, params PostCustomerGroupsIdParams) (PostCustomerGroupsIdRes, error)
	// PostCustomerGroupsIdCustomersBatch invokes PostCustomerGroupsIdCustomersBatch operation.
	//
	// Add a list of customers to a customer group.
	//
	// POST /admin/customer-groups/{id}/customers/batch
	PostCustomerGroupsIdCustomersBatch(ctx context.Context, request OptAdminPostCustomerGroupsGroupCustomersBatchReq, params PostCustomerGroupsIdCustomersBatchParams) (PostCustomerGroupsIdCustomersBatchRes, error)
	// PostCustomerGroupsIdCustomersRemove invokes PostCustomerGroupsIdCustomersRemove operation.
	//
	// Add a list of removes to a customer group.
	//
	// POST /admin/customer-groups/{id}/customers/remove
	PostCustomerGroupsIdCustomersRemove(ctx context.Context, request OptAdminPostCustomerGroupsGroupCustomersBatchReq, params PostCustomerGroupsIdCustomersRemoveParams) (PostCustomerGroupsIdCustomersRemoveRes, error)
	// PostCustomers invokes PostCustomers operation.
	//
	// Create a customer.
	//
	// POST /admin/customers
	PostCustomers(ctx context.Context, request jx.Raw) (PostCustomersRes, error)
	// PostCustomersId invokes PostCustomersId operation.
	//
	// Update a customer's details.
	//
	// POST /admin/customers/{id}
	PostCustomersId(ctx context.Context, request jx.Raw, params PostCustomersIdParams) (PostCustomersIdRes, error)
	// PostCustomersIdAddresses invokes PostCustomersIdAddresses operation.
	//
	// Add a list of addresses to a customer.
	//
	// POST /admin/customers/{id}/addresses
	PostCustomersIdAddresses(ctx context.Context, request jx.Raw, params PostCustomersIdAddressesParams) (PostCustomersIdAddressesRes, error)
	// PostCustomersIdAddressesAddressID invokes PostCustomersIdAddressesAddress_id operation.
	//
	// Add a list of addresses to a customer.
	//
	// POST /admin/customers/{id}/addresses/{address_id}
	PostCustomersIdAddressesAddressID(ctx context.Context, request jx.Raw, params PostCustomersIdAddressesAddressIDParams) (PostCustomersIdAddressesAddressIDRes, error)
	// PostFulfillmentShippingOptionsIdRulesBatchAdd invokes PostFulfillmentShippingOptionsIdRulesBatchAdd operation.
	//
	// Add a list of adds to a fulfillment.
	//
	// POST /admin/fulfillment/shipping-options/{id}/rules/batch/add
	PostFulfillmentShippingOptionsIdRulesBatchAdd(ctx context.Context, request OptAdminPostFulfillmentShippingOptionsRulesBatchAddReq, params PostFulfillmentShippingOptionsIdRulesBatchAddParams) (PostFulfillmentShippingOptionsIdRulesBatchAddRes, error)
	// PostFulfillmentShippingOptionsIdRulesBatchRemove invokes PostFulfillmentShippingOptionsIdRulesBatchRemove operation.
	//
	// Add a list of removes to a fulfillment.
	//
	// POST /admin/fulfillment/shipping-options/{id}/rules/batch/remove
	PostFulfillmentShippingOptionsIdRulesBatchRemove(ctx context.Context, request OptAdminPostFulfillmentShippingOptionsRulesBatchRemoveReq, params PostFulfillmentShippingOptionsIdRulesBatchRemoveParams) (PostFulfillmentShippingOptionsIdRulesBatchRemoveRes, error)
	// PostInventoryItems invokes PostInventoryItems operation.
	//
	// Create a inventory item.
	//
	// POST /admin/inventory-items
	PostInventoryItems(ctx context.Context, request OptAdminPostInventoryItemsReq) (PostInventoryItemsRes, error)
	// PostInventoryItemsId invokes PostInventoryItemsId operation.
	//
	// Update a inventory item's details.
	//
	// POST /admin/inventory-items/{id}
	PostInventoryItemsId(ctx context.Context, request OptAdminPostInventoryItemsInventoryItemReq, params PostInventoryItemsIdParams) (PostInventoryItemsIdRes, error)
	// PostInventoryItemsIdLocationLevels invokes PostInventoryItemsIdLocationLevels operation.
	//
	// Add a list of location levels to a inventory item.
	//
	// POST /admin/inventory-items/{id}/location-levels
	PostInventoryItemsIdLocationLevels(ctx context.Context, request OptAdminPostInventoryItemsItemLocationLevelsReq, params PostInventoryItemsIdLocationLevelsParams) (PostInventoryItemsIdLocationLevelsRes, error)
	// PostInventoryItemsIdLocationLevelsLocationID invokes PostInventoryItemsIdLocationLevelsLocation_id operation.
	//
	// Add a list of location levels to a inventory item.
	//
	// POST /admin/inventory-items/{id}/location-levels/{location_id}
	PostInventoryItemsIdLocationLevelsLocationID(ctx context.Context, request OptAdminPostInventoryItemsItemLocationLevelsLevelReq, params PostInventoryItemsIdLocationLevelsLocationIDParams) (PostInventoryItemsIdLocationLevelsLocationIDRes, error)
	// PostInvites invokes PostInvites operation.
	//
	// Create a invite.
	//
	// POST /admin/invites
	PostInvites(ctx context.Context, request jx.Raw) (PostInvitesRes, error)
	// PostInvitesAccept invokes PostInvitesAccept operation.
	//
	// Create a invite.
	//
	// POST /admin/invites/accept
	PostInvitesAccept(ctx context.Context, request OptAdminPostInvitesInviteAcceptReq) (PostInvitesAcceptRes, error)
	// PostInvitesIdResend invokes PostInvitesIdResend operation.
	//
	// Add a list of resends to a invite.
	//
	// POST /admin/invites/{id}/resend
	PostInvitesIdResend(ctx context.Context, request jx.Raw, params PostInvitesIdResendParams) (PostInvitesIdResendRes, error)
	// PostPaymentsIdCapture invokes PostPaymentsIdCapture operation.
	//
	// Add a list of captures to a payment.
	//
	// POST /admin/payments/{id}/capture
	PostPaymentsIdCapture(ctx context.Context, request OptAdminPostPaymentsCapturesReq, params PostPaymentsIdCaptureParams) (PostPaymentsIdCaptureRes, error)
	// PostPaymentsIdRefund invokes PostPaymentsIdRefund operation.
	//
	// Add a list of refunds to a payment.
	//
	// POST /admin/payments/{id}/refund
	PostPaymentsIdRefund(ctx context.Context, request OptAdminPostPaymentsRefundsReq, params PostPaymentsIdRefundParams) (PostPaymentsIdRefundRes, error)
	// PostPriceLists invokes PostPriceLists operation.
	//
	// Create a price list.
	//
	// POST /admin/price-lists
	PostPriceLists(ctx context.Context, request OptAdminPostPriceListsReq) (PostPriceListsRes, error)
	// PostPriceListsId invokes PostPriceListsId operation.
	//
	// Update a price list's details.
	//
	// POST /admin/price-lists/{id}
	PostPriceListsId(ctx context.Context, request OptAdminPostPriceListsPriceListReq, params PostPriceListsIdParams) (PostPriceListsIdRes, error)
	// PostPriceListsIdPricesBatchAdd invokes PostPriceListsIdPricesBatchAdd operation.
	//
	// Add a list of adds to a price list.
	//
	// POST /admin/price-lists/{id}/prices/batch/add
	PostPriceListsIdPricesBatchAdd(ctx context.Context, request OptAdminPostPriceListsPriceListPricesBatchAddReq, params PostPriceListsIdPricesBatchAddParams) (PostPriceListsIdPricesBatchAddRes, error)
	// PostPriceListsIdPricesBatchRemove invokes PostPriceListsIdPricesBatchRemove operation.
	//
	// Add a list of removes to a price list.
	//
	// POST /admin/price-lists/{id}/prices/batch/remove
	PostPriceListsIdPricesBatchRemove(ctx context.Context, request OptAdminPostPriceListsPriceListPricesBatchRemoveReq, params PostPriceListsIdPricesBatchRemoveParams) (PostPriceListsIdPricesBatchRemoveRes, error)
	// PostPricingRuleTypes invokes PostPricingRuleTypes operation.
	//
	// Create a pricing.
	//
	// POST /admin/pricing/rule-types
	PostPricingRuleTypes(ctx context.Context, request OptAdminPostPricingRuleTypesReq) (PostPricingRuleTypesRes, error)
	// PostPricingRuleTypesId invokes PostPricingRuleTypesId operation.
	//
	// Add a list of rule types to a pricing.
	//
	// POST /admin/pricing/rule-types/{id}
	PostPricingRuleTypesId(ctx context.Context, request OptAdminPostPricingRuleTypesRuleTypeReq, params PostPricingRuleTypesIdParams) (PostPricingRuleTypesIdRes, error)
	// PostProducts invokes PostProducts operation.
	//
	// Create a product.
	//
	// POST /admin/products
	PostProducts(ctx context.Context, request jx.Raw) (PostProductsRes, error)
	// PostProductsId invokes PostProductsId operation.
	//
	// Update a product's details.
	//
	// POST /admin/products/{id}
	PostProductsId(ctx context.Context, request jx.Raw, params PostProductsIdParams) (PostProductsIdRes, error)
	// PostProductsIdOptions invokes PostProductsIdOptions operation.
	//
	// Add a list of options to a product.
	//
	// POST /admin/products/{id}/options
	PostProductsIdOptions(ctx context.Context, request jx.Raw, params PostProductsIdOptionsParams) (PostProductsIdOptionsRes, error)
	// PostProductsIdOptionsOptionID invokes PostProductsIdOptionsOption_id operation.
	//
	// Add a list of options to a product.
	//
	// POST /admin/products/{id}/options/{option_id}
	PostProductsIdOptionsOptionID(ctx context.Context, request jx.Raw, params PostProductsIdOptionsOptionIDParams) (PostProductsIdOptionsOptionIDRes, error)
	// PostProductsIdVariants invokes PostProductsIdVariants operation.
	//
	// Add a list of variants to a product.
	//
	// POST /admin/products/{id}/variants
	PostProductsIdVariants(ctx context.Context, request jx.Raw, params PostProductsIdVariantsParams) (PostProductsIdVariantsRes, error)
	// PostProductsIdVariantsVariantID invokes PostProductsIdVariantsVariant_id operation.
	//
	// Add a list of variants to a product.
	//
	// POST /admin/products/{id}/variants/{variant_id}
	PostProductsIdVariantsVariantID(ctx context.Context, request jx.Raw, params PostProductsIdVariantsVariantIDParams) (PostProductsIdVariantsVariantIDRes, error)
	// PostPromotions invokes PostPromotions operation.
	//
	// Create a promotion.
	//
	// POST /admin/promotions
	PostPromotions(ctx context.Context, request jx.Raw) (PostPromotionsRes, error)
	// PostPromotionsId invokes PostPromotionsId operation.
	//
	// Update a promotion's details.
	//
	// POST /admin/promotions/{id}
	PostPromotionsId(ctx context.Context, request OptAdminPostPromotionsPromotionReq, params PostPromotionsIdParams) (PostPromotionsIdRes, error)
	// PostPromotionsIdBuyRulesBatchAdd invokes PostPromotionsIdBuyRulesBatchAdd operation.
	//
	// Add a list of adds to a promotion.
	//
	// POST /admin/promotions/{id}/buy-rules/batch/add
	PostPromotionsIdBuyRulesBatchAdd(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchAddReq, params PostPromotionsIdBuyRulesBatchAddParams) (PostPromotionsIdBuyRulesBatchAddRes, error)
	// PostPromotionsIdBuyRulesBatchRemove invokes PostPromotionsIdBuyRulesBatchRemove operation.
	//
	// Add a list of removes to a promotion.
	//
	// POST /admin/promotions/{id}/buy-rules/batch/remove
	PostPromotionsIdBuyRulesBatchRemove(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchRemoveReq, params PostPromotionsIdBuyRulesBatchRemoveParams) (PostPromotionsIdBuyRulesBatchRemoveRes, error)
	// PostPromotionsIdRulesBatchAdd invokes PostPromotionsIdRulesBatchAdd operation.
	//
	// Add a list of adds to a promotion.
	//
	// POST /admin/promotions/{id}/rules/batch/add
	PostPromotionsIdRulesBatchAdd(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchAddReq, params PostPromotionsIdRulesBatchAddParams) (PostPromotionsIdRulesBatchAddRes, error)
	// PostPromotionsIdRulesBatchRemove invokes PostPromotionsIdRulesBatchRemove operation.
	//
	// Add a list of removes to a promotion.
	//
	// POST /admin/promotions/{id}/rules/batch/remove
	PostPromotionsIdRulesBatchRemove(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchRemoveReq, params PostPromotionsIdRulesBatchRemoveParams) (PostPromotionsIdRulesBatchRemoveRes, error)
	// PostPromotionsIdRulesBatchUpdate invokes PostPromotionsIdRulesBatchUpdate operation.
	//
	// Add a list of updates to a promotion.
	//
	// POST /admin/promotions/{id}/rules/batch/update
	PostPromotionsIdRulesBatchUpdate(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchUpdateReq, params PostPromotionsIdRulesBatchUpdateParams) (PostPromotionsIdRulesBatchUpdateRes, error)
	// PostPromotionsIdTargetRulesBatchAdd invokes PostPromotionsIdTargetRulesBatchAdd operation.
	//
	// Add a list of adds to a promotion.
	//
	// POST /admin/promotions/{id}/target-rules/batch/add
	PostPromotionsIdTargetRulesBatchAdd(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchAddReq, params PostPromotionsIdTargetRulesBatchAddParams) (PostPromotionsIdTargetRulesBatchAddRes, error)
	// PostPromotionsIdTargetRulesBatchRemove invokes PostPromotionsIdTargetRulesBatchRemove operation.
	//
	// Add a list of removes to a promotion.
	//
	// POST /admin/promotions/{id}/target-rules/batch/remove
	PostPromotionsIdTargetRulesBatchRemove(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchRemoveReq, params PostPromotionsIdTargetRulesBatchRemoveParams) (PostPromotionsIdTargetRulesBatchRemoveRes, error)
	// PostRegions invokes PostRegions operation.
	//
	// Create a region.
	//
	// POST /admin/regions
	PostRegions(ctx context.Context, request jx.Raw) (PostRegionsRes, error)
	// PostRegionsId invokes PostRegionsId operation.
	//
	// Update a region's details.
	//
	// POST /admin/regions/{id}
	PostRegionsId(ctx context.Context, request jx.Raw, params PostRegionsIdParams) (PostRegionsIdRes, error)
	// PostSalesChannels invokes PostSalesChannels operation.
	//
	// Create a sales channel.
	//
	// POST /admin/sales-channels
	PostSalesChannels(ctx context.Context, request jx.Raw) (PostSalesChannelsRes, error)
	// PostSalesChannelsId invokes PostSalesChannelsId operation.
	//
	// Update a sales channel's details.
	//
	// POST /admin/sales-channels/{id}
	PostSalesChannelsId(ctx context.Context, request jx.Raw, params PostSalesChannelsIdParams) (PostSalesChannelsIdRes, error)
	// PostSalesChannelsIdProductsBatchAdd invokes PostSalesChannelsIdProductsBatchAdd operation.
	//
	// Add a list of adds to a sales channel.
	//
	// POST /admin/sales-channels/{id}/products/batch/add
	PostSalesChannelsIdProductsBatchAdd(ctx context.Context, request jx.Raw, params PostSalesChannelsIdProductsBatchAddParams) (PostSalesChannelsIdProductsBatchAddRes, error)
	// PostStockLocations invokes PostStockLocations operation.
	//
	// Create a stock location.
	//
	// POST /admin/stock-locations
	PostStockLocations(ctx context.Context, request OptAdminPostStockLocationsReq) (PostStockLocationsRes, error)
	// PostStoresId invokes PostStoresId operation.
	//
	// Update a store's details.
	//
	// POST /admin/stores/{id}
	PostStoresId(ctx context.Context, request jx.Raw, params PostStoresIdParams) (PostStoresIdRes, error)
	// PostTaxRates invokes PostTaxRates operation.
	//
	// Create a tax rate.
	//
	// POST /admin/tax-rates
	PostTaxRates(ctx context.Context, request OptAdminPostTaxRatesReq) (PostTaxRatesRes, error)
	// PostTaxRatesId invokes PostTaxRatesId operation.
	//
	// Update a tax rate's details.
	//
	// POST /admin/tax-rates/{id}
	PostTaxRatesId(ctx context.Context, request OptAdminPostTaxRatesTaxRateReq, params PostTaxRatesIdParams) (PostTaxRatesIdRes, error)
	// PostTaxRatesIdRules invokes PostTaxRatesIdRules operation.
	//
	// Add a list of rules to a tax rate.
	//
	// POST /admin/tax-rates/{id}/rules
	PostTaxRatesIdRules(ctx context.Context, request OptAdminPostTaxRatesTaxRateRulesReq, params PostTaxRatesIdRulesParams) (PostTaxRatesIdRulesRes, error)
	// PostTaxRegions invokes PostTaxRegions operation.
	//
	// Create a tax region.
	//
	// POST /admin/tax-regions
	PostTaxRegions(ctx context.Context, request OptAdminPostTaxRegionsReq) (PostTaxRegionsRes, error)
	// PostUsers invokes PostUsers operation.
	//
	// Create a user.
	//
	// POST /admin/users
	PostUsers(ctx context.Context, request jx.Raw) (PostUsersRes, error)
	// PostUsersId invokes PostUsersId operation.
	//
	// Update a user's details.
	//
	// POST /admin/users/{id}
	PostUsersId(ctx context.Context, request OptAdminUpdateUserRequest, params PostUsersIdParams) (PostUsersIdRes, error)
	// PostWorkflowsExecutionsWorkflowIdRun invokes PostWorkflowsExecutionsWorkflow_idRun operation.
	//
	// Add a list of runs to a workflows execution.
	//
	// POST /admin/workflows-executions/{workflow_id}/run
	PostWorkflowsExecutionsWorkflowIdRun(ctx context.Context, request OptAdminPostWorkflowsRunReq, params PostWorkflowsExecutionsWorkflowIdRunParams) (PostWorkflowsExecutionsWorkflowIdRunRes, error)
	// PostWorkflowsExecutionsWorkflowIdStepsFailure invokes PostWorkflowsExecutionsWorkflow_idStepsFailure operation.
	//
	// Add a list of failures to a workflows execution.
	//
	// POST /admin/workflows-executions/{workflow_id}/steps/failure
	PostWorkflowsExecutionsWorkflowIdStepsFailure(ctx context.Context, request OptAdminPostWorkflowsAsyncResponseReq, params PostWorkflowsExecutionsWorkflowIdStepsFailureParams) (PostWorkflowsExecutionsWorkflowIdStepsFailureRes, error)
	// PostWorkflowsExecutionsWorkflowIdStepsSuccess invokes PostWorkflowsExecutionsWorkflow_idStepsSuccess operation.
	//
	// Add a list of successes to a workflows execution.
	//
	// POST /admin/workflows-executions/{workflow_id}/steps/success
	PostWorkflowsExecutionsWorkflowIdStepsSuccess(ctx context.Context, request OptAdminPostWorkflowsAsyncResponseReq, params PostWorkflowsExecutionsWorkflowIdStepsSuccessParams) (PostWorkflowsExecutionsWorkflowIdStepsSuccessRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// DeleteApiKeysId invokes DeleteApiKeysId operation.
//
// Delete a api key.
//
// DELETE /admin/api-keys/{id}
func (c *Client) DeleteApiKeysId(ctx context.Context, request jx.Raw, params DeleteApiKeysIdParams) (DeleteApiKeysIdRes, error) {
	res, err := c.sendDeleteApiKeysId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteApiKeysId(ctx context.Context, request jx.Raw, params DeleteApiKeysIdParams) (res DeleteApiKeysIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteApiKeysId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/api-keys/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteApiKeysId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/api-keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteApiKeysIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteApiKeysId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteApiKeysId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteApiKeysId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteApiKeysIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCampaignsId invokes DeleteCampaignsId operation.
//
// Delete a campaign.
//
// DELETE /admin/campaigns/{id}
func (c *Client) DeleteCampaignsId(ctx context.Context, request jx.Raw, params DeleteCampaignsIdParams) (DeleteCampaignsIdRes, error) {
	res, err := c.sendDeleteCampaignsId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteCampaignsId(ctx context.Context, request jx.Raw, params DeleteCampaignsIdParams) (res DeleteCampaignsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteCampaignsId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/campaigns/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCampaignsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/campaigns/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteCampaignsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteCampaignsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteCampaignsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteCampaignsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCampaignsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCollectionsId invokes DeleteCollectionsId operation.
//
// Delete a collection.
//
// DELETE /admin/collections/{id}
func (c *Client) DeleteCollectionsId(ctx context.Context, request jx.Raw, params DeleteCollectionsIdParams) (DeleteCollectionsIdRes, error) {
	res, err := c.sendDeleteCollectionsId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteCollectionsId(ctx context.Context, request jx.Raw, params DeleteCollectionsIdParams) (res DeleteCollectionsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteCollectionsId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/collections/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCollectionsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/collections/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteCollectionsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteCollectionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteCollectionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteCollectionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCollectionsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCustomerGroupsId invokes DeleteCustomerGroupsId operation.
//
// Delete a customer group.
//
// DELETE /admin/customer-groups/{id}
func (c *Client) DeleteCustomerGroupsId(ctx context.Context, request jx.Raw, params DeleteCustomerGroupsIdParams) (DeleteCustomerGroupsIdRes, error) {
	res, err := c.sendDeleteCustomerGroupsId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteCustomerGroupsId(ctx context.Context, request jx.Raw, params DeleteCustomerGroupsIdParams) (res DeleteCustomerGroupsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteCustomerGroupsId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/customer-groups/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCustomerGroupsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/customer-groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteCustomerGroupsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteCustomerGroupsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteCustomerGroupsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteCustomerGroupsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCustomerGroupsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCustomersId invokes DeleteCustomersId operation.
//
// Delete a customer.
//
// DELETE /admin/customers/{id}
func (c *Client) DeleteCustomersId(ctx context.Context, request jx.Raw, params DeleteCustomersIdParams) (DeleteCustomersIdRes, error) {
	res, err := c.sendDeleteCustomersId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteCustomersId(ctx context.Context, request jx.Raw, params DeleteCustomersIdParams) (res DeleteCustomersIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteCustomersId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/customers/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCustomersId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/customers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteCustomersIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteCustomersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteCustomersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteCustomersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCustomersIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCustomersIdAddressesAddressID invokes DeleteCustomersIdAddressesAddress_id operation.
//
// Remove a list of addresses from a customer. This doesn't delete the Address, only the association
// between the Address and the customer.
//
// DELETE /admin/customers/{id}/addresses/{address_id}
func (c *Client) DeleteCustomersIdAddressesAddressID(ctx context.Context, request jx.Raw, params DeleteCustomersIdAddressesAddressIDParams) (DeleteCustomersIdAddressesAddressIDRes, error) {
	res, err := c.sendDeleteCustomersIdAddressesAddressID(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteCustomersIdAddressesAddressID(ctx context.Context, request jx.Raw, params DeleteCustomersIdAddressesAddressIDParams) (res DeleteCustomersIdAddressesAddressIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteCustomersIdAddressesAddress_id"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/customers/{id}/addresses/{address_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCustomersIdAddressesAddressID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/customers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/addresses/"
	{
		// Encode "address_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "address_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AddressID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteCustomersIdAddressesAddressIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteCustomersIdAddressesAddressID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteCustomersIdAddressesAddressID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteCustomersIdAddressesAddressID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCustomersIdAddressesAddressIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteInventoryItemsId invokes DeleteInventoryItemsId operation.
//
// Delete a inventory item.
//
// DELETE /admin/inventory-items/{id}
func (c *Client) DeleteInventoryItemsId(ctx context.Context, request jx.Raw, params DeleteInventoryItemsIdParams) (DeleteInventoryItemsIdRes, error) {
	res, err := c.sendDeleteInventoryItemsId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteInventoryItemsId(ctx context.Context, request jx.Raw, params DeleteInventoryItemsIdParams) (res DeleteInventoryItemsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteInventoryItemsId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/inventory-items/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteInventoryItemsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/inventory-items/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteInventoryItemsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteInventoryItemsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteInventoryItemsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteInventoryItemsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteInventoryItemsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteInventoryItemsIdLocationLevelsLocationID invokes DeleteInventoryItemsIdLocationLevelsLocation_id operation.
//
// Remove a list of location levels from a inventory item. This doesn't delete the Location Level,
// only the association between the Location Level and the inventory item.
//
// DELETE /admin/inventory-items/{id}/location-levels/{location_id}
func (c *Client) DeleteInventoryItemsIdLocationLevelsLocationID(ctx context.Context, request jx.Raw, params DeleteInventoryItemsIdLocationLevelsLocationIDParams) (DeleteInventoryItemsIdLocationLevelsLocationIDRes, error) {
	res, err := c.sendDeleteInventoryItemsIdLocationLevelsLocationID(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteInventoryItemsIdLocationLevelsLocationID(ctx context.Context, request jx.Raw, params DeleteInventoryItemsIdLocationLevelsLocationIDParams) (res DeleteInventoryItemsIdLocationLevelsLocationIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteInventoryItemsIdLocationLevelsLocation_id"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/inventory-items/{id}/location-levels/{location_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteInventoryItemsIdLocationLevelsLocationID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/inventory-items/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/location-levels/"
	{
		// Encode "location_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "location_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LocationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteInventoryItemsIdLocationLevelsLocationIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteInventoryItemsIdLocationLevelsLocationID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteInventoryItemsIdLocationLevelsLocationID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteInventoryItemsIdLocationLevelsLocationID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteInventoryItemsIdLocationLevelsLocationIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteInvitesId invokes DeleteInvitesId operation.
//
// Delete a invite.
//
// DELETE /admin/invites/{id}
func (c *Client) DeleteInvitesId(ctx context.Context, request jx.Raw, params DeleteInvitesIdParams) (DeleteInvitesIdRes, error) {
	res, err := c.sendDeleteInvitesId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteInvitesId(ctx context.Context, request jx.Raw, params DeleteInvitesIdParams) (res DeleteInvitesIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteInvitesId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/invites/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteInvitesId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/invites/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteInvitesIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteInvitesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteInvitesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteInvitesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteInvitesIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePriceListsId invokes DeletePriceListsId operation.
//
// Delete a price list.
//
// DELETE /admin/price-lists/{id}
func (c *Client) DeletePriceListsId(ctx context.Context, request jx.Raw, params DeletePriceListsIdParams) (DeletePriceListsIdRes, error) {
	res, err := c.sendDeletePriceListsId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeletePriceListsId(ctx context.Context, request jx.Raw, params DeletePriceListsIdParams) (res DeletePriceListsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeletePriceListsId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/price-lists/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeletePriceListsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/price-lists/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeletePriceListsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeletePriceListsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeletePriceListsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeletePriceListsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePriceListsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePricingRuleTypesId invokes DeletePricingRuleTypesId operation.
//
// Remove a list of rule types from a pricing. This doesn't delete the Rule Type, only the
// association between the Rule Type and the pricing.
//
// DELETE /admin/pricing/rule-types/{id}
func (c *Client) DeletePricingRuleTypesId(ctx context.Context, request *AdminDeletePricingRuleTypesRuleTypeReq, params DeletePricingRuleTypesIdParams) (DeletePricingRuleTypesIdRes, error) {
	res, err := c.sendDeletePricingRuleTypesId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeletePricingRuleTypesId(ctx context.Context, request *AdminDeletePricingRuleTypesRuleTypeReq, params DeletePricingRuleTypesIdParams) (res DeletePricingRuleTypesIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeletePricingRuleTypesId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/pricing/rule-types/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeletePricingRuleTypesId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/pricing/rule-types/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeletePricingRuleTypesIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeletePricingRuleTypesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeletePricingRuleTypesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeletePricingRuleTypesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePricingRuleTypesIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProductsId invokes DeleteProductsId operation.
//
// Delete a product.
//
// DELETE /admin/products/{id}
func (c *Client) DeleteProductsId(ctx context.Context, request jx.Raw, params DeleteProductsIdParams) (DeleteProductsIdRes, error) {
	res, err := c.sendDeleteProductsId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteProductsId(ctx context.Context, request jx.Raw, params DeleteProductsIdParams) (res DeleteProductsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteProductsId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/products/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteProductsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteProductsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteProductsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteProductsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteProductsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteProductsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProductsIdOptionsOptionID invokes DeleteProductsIdOptionsOption_id operation.
//
// Remove a list of options from a product. This doesn't delete the Option, only the association
// between the Option and the product.
//
// DELETE /admin/products/{id}/options/{option_id}
func (c *Client) DeleteProductsIdOptionsOptionID(ctx context.Context, request jx.Raw, params DeleteProductsIdOptionsOptionIDParams) (DeleteProductsIdOptionsOptionIDRes, error) {
	res, err := c.sendDeleteProductsIdOptionsOptionID(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteProductsIdOptionsOptionID(ctx context.Context, request jx.Raw, params DeleteProductsIdOptionsOptionIDParams) (res DeleteProductsIdOptionsOptionIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteProductsIdOptionsOption_id"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/products/{id}/options/{option_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteProductsIdOptionsOptionID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/options/"
	{
		// Encode "option_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "option_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OptionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteProductsIdOptionsOptionIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteProductsIdOptionsOptionID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteProductsIdOptionsOptionID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteProductsIdOptionsOptionID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteProductsIdOptionsOptionIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProductsIdVariantsVariantID invokes DeleteProductsIdVariantsVariant_id operation.
//
// Remove a list of variants from a product. This doesn't delete the Variant, only the association
// between the Variant and the product.
//
// DELETE /admin/products/{id}/variants/{variant_id}
func (c *Client) DeleteProductsIdVariantsVariantID(ctx context.Context, request jx.Raw, params DeleteProductsIdVariantsVariantIDParams) (DeleteProductsIdVariantsVariantIDRes, error) {
	res, err := c.sendDeleteProductsIdVariantsVariantID(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteProductsIdVariantsVariantID(ctx context.Context, request jx.Raw, params DeleteProductsIdVariantsVariantIDParams) (res DeleteProductsIdVariantsVariantIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteProductsIdVariantsVariant_id"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/products/{id}/variants/{variant_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteProductsIdVariantsVariantID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/variants/"
	{
		// Encode "variant_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "variant_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VariantID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteProductsIdVariantsVariantIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteProductsIdVariantsVariantID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteProductsIdVariantsVariantID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteProductsIdVariantsVariantID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteProductsIdVariantsVariantIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePromotionsId invokes DeletePromotionsId operation.
//
// Delete a promotion.
//
// DELETE /admin/promotions/{id}
func (c *Client) DeletePromotionsId(ctx context.Context, request jx.Raw, params DeletePromotionsIdParams) (DeletePromotionsIdRes, error) {
	res, err := c.sendDeletePromotionsId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeletePromotionsId(ctx context.Context, request jx.Raw, params DeletePromotionsIdParams) (res DeletePromotionsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeletePromotionsId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/promotions/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeletePromotionsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/promotions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeletePromotionsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeletePromotionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeletePromotionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeletePromotionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePromotionsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRegionsId invokes DeleteRegionsId operation.
//
// Delete a region.
//
// DELETE /admin/regions/{id}
func (c *Client) DeleteRegionsId(ctx context.Context, request jx.Raw, params DeleteRegionsIdParams) (DeleteRegionsIdRes, error) {
	res, err := c.sendDeleteRegionsId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteRegionsId(ctx context.Context, request jx.Raw, params DeleteRegionsIdParams) (res DeleteRegionsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteRegionsId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/regions/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteRegionsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/regions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteRegionsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteRegionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteRegionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteRegionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteRegionsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSalesChannelsId invokes DeleteSalesChannelsId operation.
//
// Delete a sales channel.
//
// DELETE /admin/sales-channels/{id}
func (c *Client) DeleteSalesChannelsId(ctx context.Context, request jx.Raw, params DeleteSalesChannelsIdParams) (DeleteSalesChannelsIdRes, error) {
	res, err := c.sendDeleteSalesChannelsId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteSalesChannelsId(ctx context.Context, request jx.Raw, params DeleteSalesChannelsIdParams) (res DeleteSalesChannelsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteSalesChannelsId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/sales-channels/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteSalesChannelsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/sales-channels/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteSalesChannelsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteSalesChannelsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteSalesChannelsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteSalesChannelsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteSalesChannelsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteStockLocationsId invokes DeleteStockLocationsId operation.
//
// Delete a stock location.
//
// DELETE /admin/stock-locations/{id}
func (c *Client) DeleteStockLocationsId(ctx context.Context, params DeleteStockLocationsIdParams) (DeleteStockLocationsIdRes, error) {
	res, err := c.sendDeleteStockLocationsId(ctx, params)
	return res, err
}

func (c *Client) sendDeleteStockLocationsId(ctx context.Context, params DeleteStockLocationsIdParams) (res DeleteStockLocationsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteStockLocationsId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/stock-locations/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteStockLocationsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/stock-locations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteStockLocationsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteStockLocationsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteStockLocationsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteStockLocationsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTaxRatesId invokes DeleteTaxRatesId operation.
//
// Delete a tax rate.
//
// DELETE /admin/tax-rates/{id}
func (c *Client) DeleteTaxRatesId(ctx context.Context, request jx.Raw, params DeleteTaxRatesIdParams) (DeleteTaxRatesIdRes, error) {
	res, err := c.sendDeleteTaxRatesId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteTaxRatesId(ctx context.Context, request jx.Raw, params DeleteTaxRatesIdParams) (res DeleteTaxRatesIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteTaxRatesId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/tax-rates/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteTaxRatesId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/tax-rates/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteTaxRatesIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteTaxRatesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteTaxRatesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteTaxRatesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteTaxRatesIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTaxRatesIdRulesRuleID invokes DeleteTaxRatesIdRulesRule_id operation.
//
// Remove a list of rules from a tax rate. This doesn't delete the Rule, only the association between
// the Rule and the tax rate.
//
// DELETE /admin/tax-rates/{id}/rules/{rule_id}
func (c *Client) DeleteTaxRatesIdRulesRuleID(ctx context.Context, request jx.Raw, params DeleteTaxRatesIdRulesRuleIDParams) (DeleteTaxRatesIdRulesRuleIDRes, error) {
	res, err := c.sendDeleteTaxRatesIdRulesRuleID(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteTaxRatesIdRulesRuleID(ctx context.Context, request jx.Raw, params DeleteTaxRatesIdRulesRuleIDParams) (res DeleteTaxRatesIdRulesRuleIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteTaxRatesIdRulesRule_id"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/tax-rates/{id}/rules/{rule_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteTaxRatesIdRulesRuleID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/tax-rates/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rules/"
	{
		// Encode "rule_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "rule_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RuleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteTaxRatesIdRulesRuleIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteTaxRatesIdRulesRuleID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteTaxRatesIdRulesRuleID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteTaxRatesIdRulesRuleID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteTaxRatesIdRulesRuleIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTaxRegionsId invokes DeleteTaxRegionsId operation.
//
// Delete a tax region.
//
// DELETE /admin/tax-regions/{id}
func (c *Client) DeleteTaxRegionsId(ctx context.Context, request jx.Raw, params DeleteTaxRegionsIdParams) (DeleteTaxRegionsIdRes, error) {
	res, err := c.sendDeleteTaxRegionsId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteTaxRegionsId(ctx context.Context, request jx.Raw, params DeleteTaxRegionsIdParams) (res DeleteTaxRegionsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteTaxRegionsId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/tax-regions/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteTaxRegionsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/tax-regions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteTaxRegionsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteTaxRegionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteTaxRegionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteTaxRegionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteTaxRegionsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteUsersId invokes DeleteUsersId operation.
//
// Delete a user.
//
// DELETE /admin/users/{id}
func (c *Client) DeleteUsersId(ctx context.Context, request jx.Raw, params DeleteUsersIdParams) (DeleteUsersIdRes, error) {
	res, err := c.sendDeleteUsersId(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteUsersId(ctx context.Context, request jx.Raw, params DeleteUsersIdParams) (res DeleteUsersIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteUsersId"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/admin/users/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteUsersId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/users/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteUsersIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "DeleteUsersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "DeleteUsersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "DeleteUsersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteUsersIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetApiKeys invokes GetApiKeys operation.
//
// Retrieve a list of api keys. The api keys can be filtered by fields such as `id`. The api keys can
// also be sorted or paginated.
//
// GET /admin/api-keys
func (c *Client) GetApiKeys(ctx context.Context, request jx.Raw) (GetApiKeysRes, error) {
	res, err := c.sendGetApiKeys(ctx, request)
	return res, err
}

func (c *Client) sendGetApiKeys(ctx context.Context, request jx.Raw) (res GetApiKeysRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetApiKeys"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/api-keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetApiKeys",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/api-keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetApiKeysRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetApiKeys", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetApiKeys", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetApiKeys", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetApiKeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetApiKeysId invokes GetApiKeysId operation.
//
// Retrieve a api key by its ID. You can expand the api key's relations or select the fields that
// should be returned.
//
// GET /admin/api-keys/{id}
func (c *Client) GetApiKeysId(ctx context.Context, request jx.Raw, params GetApiKeysIdParams) (GetApiKeysIdRes, error) {
	res, err := c.sendGetApiKeysId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetApiKeysId(ctx context.Context, request jx.Raw, params GetApiKeysIdParams) (res GetApiKeysIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetApiKeysId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/api-keys/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetApiKeysId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/api-keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetApiKeysIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetApiKeysId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetApiKeysId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetApiKeysId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetApiKeysIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCampaigns invokes GetCampaigns operation.
//
// Retrieve a list of campaigns. The campaigns can be filtered by fields such as `id`. The campaigns
// can also be sorted or paginated.
//
// GET /admin/campaigns
func (c *Client) GetCampaigns(ctx context.Context, request jx.Raw) (GetCampaignsRes, error) {
	res, err := c.sendGetCampaigns(ctx, request)
	return res, err
}

func (c *Client) sendGetCampaigns(ctx context.Context, request jx.Raw) (res GetCampaignsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCampaigns"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/campaigns"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCampaigns",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/campaigns"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCampaignsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCampaigns", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCampaigns", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCampaigns", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCampaignsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCampaignsId invokes GetCampaignsId operation.
//
// Retrieve a campaign by its ID. You can expand the campaign's relations or select the fields that
// should be returned.
//
// GET /admin/campaigns/{id}
func (c *Client) GetCampaignsId(ctx context.Context, request jx.Raw, params GetCampaignsIdParams) (GetCampaignsIdRes, error) {
	res, err := c.sendGetCampaignsId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetCampaignsId(ctx context.Context, request jx.Raw, params GetCampaignsIdParams) (res GetCampaignsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCampaignsId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/campaigns/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCampaignsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/campaigns/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCampaignsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCampaignsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCampaignsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCampaignsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCampaignsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCollections invokes GetCollections operation.
//
// Retrieve a list of collections. The collections can be filtered by fields such as `id`. The
// collections can also be sorted or paginated.
//
// GET /admin/collections
func (c *Client) GetCollections(ctx context.Context, request jx.Raw) (GetCollectionsRes, error) {
	res, err := c.sendGetCollections(ctx, request)
	return res, err
}

func (c *Client) sendGetCollections(ctx context.Context, request jx.Raw) (res GetCollectionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCollections"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/collections"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCollections",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/collections"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCollectionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCollections", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCollections", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCollections", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCollectionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCollectionsId invokes GetCollectionsId operation.
//
// Retrieve a collection by its ID. You can expand the collection's relations or select the fields
// that should be returned.
//
// GET /admin/collections/{id}
func (c *Client) GetCollectionsId(ctx context.Context, request jx.Raw, params GetCollectionsIdParams) (GetCollectionsIdRes, error) {
	res, err := c.sendGetCollectionsId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetCollectionsId(ctx context.Context, request jx.Raw, params GetCollectionsIdParams) (res GetCollectionsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCollectionsId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/collections/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCollectionsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/collections/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCollectionsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCollectionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCollectionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCollectionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCollectionsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCurrencies invokes GetCurrencies operation.
//
// Retrieve a list of currencies. The currencies can be filtered by fields such as `id`. The
// currencies can also be sorted or paginated.
//
// GET /admin/currencies
func (c *Client) GetCurrencies(ctx context.Context, request jx.Raw) (GetCurrenciesRes, error) {
	res, err := c.sendGetCurrencies(ctx, request)
	return res, err
}

func (c *Client) sendGetCurrencies(ctx context.Context, request jx.Raw) (res GetCurrenciesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCurrencies"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/currencies"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCurrencies",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/currencies"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCurrenciesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCurrencies", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCurrencies", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCurrencies", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCurrenciesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCurrenciesCode invokes GetCurrenciesCode operation.
//
// Retrieve a currency by its ID. You can expand the currency's relations or select the fields that
// should be returned.
//
// GET /admin/currencies/{code}
func (c *Client) GetCurrenciesCode(ctx context.Context, request jx.Raw, params GetCurrenciesCodeParams) (GetCurrenciesCodeRes, error) {
	res, err := c.sendGetCurrenciesCode(ctx, request, params)
	return res, err
}

func (c *Client) sendGetCurrenciesCode(ctx context.Context, request jx.Raw, params GetCurrenciesCodeParams) (res GetCurrenciesCodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCurrenciesCode"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/currencies/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCurrenciesCode",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/currencies/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCurrenciesCodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCurrenciesCode", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCurrenciesCode", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCurrenciesCode", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCurrenciesCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomerGroups invokes GetCustomerGroups operation.
//
// Retrieve a list of customer groups. The customer groups can be filtered by fields such as `id`.
// The customer groups can also be sorted or paginated.
//
// GET /admin/customer-groups
func (c *Client) GetCustomerGroups(ctx context.Context, request jx.Raw) (GetCustomerGroupsRes, error) {
	res, err := c.sendGetCustomerGroups(ctx, request)
	return res, err
}

func (c *Client) sendGetCustomerGroups(ctx context.Context, request jx.Raw) (res GetCustomerGroupsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCustomerGroups"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/customer-groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCustomerGroups",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/customer-groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCustomerGroupsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCustomerGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCustomerGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCustomerGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCustomerGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomerGroupsId invokes GetCustomerGroupsId operation.
//
// Retrieve a customer group by its ID. You can expand the customer group's relations or select the
// fields that should be returned.
//
// GET /admin/customer-groups/{id}
func (c *Client) GetCustomerGroupsId(ctx context.Context, request jx.Raw, params GetCustomerGroupsIdParams) (GetCustomerGroupsIdRes, error) {
	res, err := c.sendGetCustomerGroupsId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetCustomerGroupsId(ctx context.Context, request jx.Raw, params GetCustomerGroupsIdParams) (res GetCustomerGroupsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCustomerGroupsId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/customer-groups/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCustomerGroupsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/customer-groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCustomerGroupsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCustomerGroupsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCustomerGroupsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCustomerGroupsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCustomerGroupsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomerGroupsIdCustomers invokes GetCustomerGroupsIdCustomers operation.
//
// Retrieve a list of customers in a customer group. The customers can be filtered by fields like
// FILTER FIELDS. The customers can also be paginated.
//
// GET /admin/customer-groups/{id}/customers
func (c *Client) GetCustomerGroupsIdCustomers(ctx context.Context, request jx.Raw, params GetCustomerGroupsIdCustomersParams) (GetCustomerGroupsIdCustomersRes, error) {
	res, err := c.sendGetCustomerGroupsIdCustomers(ctx, request, params)
	return res, err
}

func (c *Client) sendGetCustomerGroupsIdCustomers(ctx context.Context, request jx.Raw, params GetCustomerGroupsIdCustomersParams) (res GetCustomerGroupsIdCustomersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCustomerGroupsIdCustomers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/customer-groups/{id}/customers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCustomerGroupsIdCustomers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/customer-groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/customers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCustomerGroupsIdCustomersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCustomerGroupsIdCustomers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCustomerGroupsIdCustomers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCustomerGroupsIdCustomers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCustomerGroupsIdCustomersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomers invokes GetCustomers operation.
//
// Retrieve a list of customers. The customers can be filtered by fields such as `id`. The customers
// can also be sorted or paginated.
//
// GET /admin/customers
func (c *Client) GetCustomers(ctx context.Context, request jx.Raw) (GetCustomersRes, error) {
	res, err := c.sendGetCustomers(ctx, request)
	return res, err
}

func (c *Client) sendGetCustomers(ctx context.Context, request jx.Raw) (res GetCustomersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCustomers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/customers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCustomers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/customers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCustomersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCustomers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCustomers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCustomers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCustomersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomersId invokes GetCustomersId operation.
//
// Retrieve a customer by its ID. You can expand the customer's relations or select the fields that
// should be returned.
//
// GET /admin/customers/{id}
func (c *Client) GetCustomersId(ctx context.Context, request jx.Raw, params GetCustomersIdParams) (GetCustomersIdRes, error) {
	res, err := c.sendGetCustomersId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetCustomersId(ctx context.Context, request jx.Raw, params GetCustomersIdParams) (res GetCustomersIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCustomersId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/customers/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCustomersId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/customers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCustomersIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCustomersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCustomersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCustomersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCustomersIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomersIdAddresses invokes GetCustomersIdAddresses operation.
//
// Retrieve a list of addresses in a customer. The addresses can be filtered by fields like FILTER
// FIELDS. The addresses can also be paginated.
//
// GET /admin/customers/{id}/addresses
func (c *Client) GetCustomersIdAddresses(ctx context.Context, request jx.Raw, params GetCustomersIdAddressesParams) (GetCustomersIdAddressesRes, error) {
	res, err := c.sendGetCustomersIdAddresses(ctx, request, params)
	return res, err
}

func (c *Client) sendGetCustomersIdAddresses(ctx context.Context, request jx.Raw, params GetCustomersIdAddressesParams) (res GetCustomersIdAddressesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCustomersIdAddresses"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/customers/{id}/addresses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCustomersIdAddresses",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/customers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/addresses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCustomersIdAddressesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCustomersIdAddresses", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCustomersIdAddresses", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCustomersIdAddresses", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCustomersIdAddressesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomersIdAddressesAddressID invokes GetCustomersIdAddressesAddress_id operation.
//
// Retrieve a list of addresses in a customer. The addresses can be filtered by fields like FILTER
// FIELDS. The addresses can also be paginated.
//
// GET /admin/customers/{id}/addresses/{address_id}
func (c *Client) GetCustomersIdAddressesAddressID(ctx context.Context, request jx.Raw, params GetCustomersIdAddressesAddressIDParams) (GetCustomersIdAddressesAddressIDRes, error) {
	res, err := c.sendGetCustomersIdAddressesAddressID(ctx, request, params)
	return res, err
}

func (c *Client) sendGetCustomersIdAddressesAddressID(ctx context.Context, request jx.Raw, params GetCustomersIdAddressesAddressIDParams) (res GetCustomersIdAddressesAddressIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetCustomersIdAddressesAddress_id"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/customers/{id}/addresses/{address_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCustomersIdAddressesAddressID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/customers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/addresses/"
	{
		// Encode "address_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "address_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AddressID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCustomersIdAddressesAddressIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetCustomersIdAddressesAddressID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetCustomersIdAddressesAddressID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetCustomersIdAddressesAddressID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCustomersIdAddressesAddressIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInventoryItems invokes GetInventoryItems operation.
//
// Retrieve a list of inventory items. The inventory items can be filtered by fields such as `id`.
// The inventory items can also be sorted or paginated.
//
// GET /admin/inventory-items
func (c *Client) GetInventoryItems(ctx context.Context, request jx.Raw) (GetInventoryItemsRes, error) {
	res, err := c.sendGetInventoryItems(ctx, request)
	return res, err
}

func (c *Client) sendGetInventoryItems(ctx context.Context, request jx.Raw) (res GetInventoryItemsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetInventoryItems"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/inventory-items"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetInventoryItems",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/inventory-items"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetInventoryItemsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetInventoryItems", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetInventoryItems", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetInventoryItems", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetInventoryItemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInventoryItemsId invokes GetInventoryItemsId operation.
//
// Retrieve a inventory item by its ID. You can expand the inventory item's relations or select the
// fields that should be returned.
//
// GET /admin/inventory-items/{id}
func (c *Client) GetInventoryItemsId(ctx context.Context, request jx.Raw, params GetInventoryItemsIdParams) (GetInventoryItemsIdRes, error) {
	res, err := c.sendGetInventoryItemsId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetInventoryItemsId(ctx context.Context, request jx.Raw, params GetInventoryItemsIdParams) (res GetInventoryItemsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetInventoryItemsId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/inventory-items/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetInventoryItemsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/inventory-items/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetInventoryItemsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetInventoryItemsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetInventoryItemsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetInventoryItemsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetInventoryItemsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInvites invokes GetInvites operation.
//
// Retrieve a list of invites. The invites can be filtered by fields such as `id`. The invites can
// also be sorted or paginated.
//
// GET /admin/invites
func (c *Client) GetInvites(ctx context.Context, request jx.Raw) (GetInvitesRes, error) {
	res, err := c.sendGetInvites(ctx, request)
	return res, err
}

func (c *Client) sendGetInvites(ctx context.Context, request jx.Raw) (res GetInvitesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetInvites"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/invites"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetInvites",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/invites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetInvitesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetInvites", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetInvites", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetInvites", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetInvitesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInvitesId invokes GetInvitesId operation.
//
// Retrieve a invite by its ID. You can expand the invite's relations or select the fields that
// should be returned.
//
// GET /admin/invites/{id}
func (c *Client) GetInvitesId(ctx context.Context, request jx.Raw, params GetInvitesIdParams) (GetInvitesIdRes, error) {
	res, err := c.sendGetInvitesId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetInvitesId(ctx context.Context, request jx.Raw, params GetInvitesIdParams) (res GetInvitesIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetInvitesId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/invites/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetInvitesId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/invites/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetInvitesIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetInvitesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetInvitesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetInvitesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetInvitesIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPayments invokes GetPayments operation.
//
// Retrieve a list of payments. The payments can be filtered by fields such as `id`. The payments can
// also be sorted or paginated.
//
// GET /admin/payments
func (c *Client) GetPayments(ctx context.Context, request jx.Raw) (GetPaymentsRes, error) {
	res, err := c.sendGetPayments(ctx, request)
	return res, err
}

func (c *Client) sendGetPayments(ctx context.Context, request jx.Raw) (res GetPaymentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetPayments"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/payments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPayments",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/payments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetPaymentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetPayments", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetPayments", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetPayments", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPaymentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPaymentsId invokes GetPaymentsId operation.
//
// Retrieve a payment by its ID. You can expand the payment's relations or select the fields that
// should be returned.
//
// GET /admin/payments/{id}
func (c *Client) GetPaymentsId(ctx context.Context, request jx.Raw, params GetPaymentsIdParams) (GetPaymentsIdRes, error) {
	res, err := c.sendGetPaymentsId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetPaymentsId(ctx context.Context, request jx.Raw, params GetPaymentsIdParams) (res GetPaymentsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetPaymentsId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/payments/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPaymentsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/payments/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetPaymentsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetPaymentsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetPaymentsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetPaymentsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPaymentsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPriceLists invokes GetPriceLists operation.
//
// Retrieve a list of price lists. The price lists can be filtered by fields such as `id`. The price
// lists can also be sorted or paginated.
//
// GET /admin/price-lists
func (c *Client) GetPriceLists(ctx context.Context, request jx.Raw) (GetPriceListsRes, error) {
	res, err := c.sendGetPriceLists(ctx, request)
	return res, err
}

func (c *Client) sendGetPriceLists(ctx context.Context, request jx.Raw) (res GetPriceListsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetPriceLists"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/price-lists"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPriceLists",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/price-lists"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetPriceListsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetPriceLists", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetPriceLists", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetPriceLists", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPriceListsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPriceListsId invokes GetPriceListsId operation.
//
// Retrieve a price list by its ID. You can expand the price list's relations or select the fields
// that should be returned.
//
// GET /admin/price-lists/{id}
func (c *Client) GetPriceListsId(ctx context.Context, request jx.Raw, params GetPriceListsIdParams) (GetPriceListsIdRes, error) {
	res, err := c.sendGetPriceListsId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetPriceListsId(ctx context.Context, request jx.Raw, params GetPriceListsIdParams) (res GetPriceListsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetPriceListsId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/price-lists/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPriceListsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/price-lists/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetPriceListsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetPriceListsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetPriceListsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetPriceListsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPriceListsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPricingRuleTypes invokes GetPricingRuleTypes operation.
//
// Retrieve a list of pricing. The pricing can be filtered by fields such as `id`. The pricing can
// also be sorted or paginated.
//
// GET /admin/pricing/rule-types
func (c *Client) GetPricingRuleTypes(ctx context.Context, request OptAdminGetPricingRuleTypesParams) (GetPricingRuleTypesRes, error) {
	res, err := c.sendGetPricingRuleTypes(ctx, request)
	return res, err
}

func (c *Client) sendGetPricingRuleTypes(ctx context.Context, request OptAdminGetPricingRuleTypesParams) (res GetPricingRuleTypesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetPricingRuleTypes"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/pricing/rule-types"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPricingRuleTypes",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/pricing/rule-types"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetPricingRuleTypesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetPricingRuleTypes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetPricingRuleTypes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetPricingRuleTypes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPricingRuleTypesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPricingRuleTypesId invokes GetPricingRuleTypesId operation.
//
// Retrieve a list of rule types in a pricing. The rule types can be filtered by fields like FILTER
// FIELDS. The rule types can also be paginated.
//
// GET /admin/pricing/rule-types/{id}
func (c *Client) GetPricingRuleTypesId(ctx context.Context, request OptAdminGetPricingRuleTypesRuleTypeParams, params GetPricingRuleTypesIdParams) (GetPricingRuleTypesIdRes, error) {
	res, err := c.sendGetPricingRuleTypesId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetPricingRuleTypesId(ctx context.Context, request OptAdminGetPricingRuleTypesRuleTypeParams, params GetPricingRuleTypesIdParams) (res GetPricingRuleTypesIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetPricingRuleTypesId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/pricing/rule-types/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPricingRuleTypesId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/pricing/rule-types/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetPricingRuleTypesIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetPricingRuleTypesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetPricingRuleTypesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetPricingRuleTypesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPricingRuleTypesIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProducts invokes GetProducts operation.
//
// Retrieve a list of products. The products can be filtered by fields such as `id`. The products can
// also be sorted or paginated.
//
// GET /admin/products
func (c *Client) GetProducts(ctx context.Context, request OptAdminGetProductsParams) (GetProductsRes, error) {
	res, err := c.sendGetProducts(ctx, request)
	return res, err
}

func (c *Client) sendGetProducts(ctx context.Context, request OptAdminGetProductsParams) (res GetProductsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetProducts"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/products"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetProducts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/products"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetProductsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetProducts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetProducts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetProducts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProductsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProductsId invokes GetProductsId operation.
//
// Retrieve a product by its ID. You can expand the product's relations or select the fields that
// should be returned.
//
// GET /admin/products/{id}
func (c *Client) GetProductsId(ctx context.Context, request jx.Raw, params GetProductsIdParams) (GetProductsIdRes, error) {
	res, err := c.sendGetProductsId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetProductsId(ctx context.Context, request jx.Raw, params GetProductsIdParams) (res GetProductsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetProductsId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/products/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetProductsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetProductsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetProductsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetProductsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetProductsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProductsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProductsIdOptions invokes GetProductsIdOptions operation.
//
// Retrieve a list of options in a product. The options can be filtered by fields like FILTER FIELDS.
// The options can also be paginated.
//
// GET /admin/products/{id}/options
func (c *Client) GetProductsIdOptions(ctx context.Context, request jx.Raw, params GetProductsIdOptionsParams) (GetProductsIdOptionsRes, error) {
	res, err := c.sendGetProductsIdOptions(ctx, request, params)
	return res, err
}

func (c *Client) sendGetProductsIdOptions(ctx context.Context, request jx.Raw, params GetProductsIdOptionsParams) (res GetProductsIdOptionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetProductsIdOptions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/products/{id}/options"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetProductsIdOptions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/options"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetProductsIdOptionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetProductsIdOptions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetProductsIdOptions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetProductsIdOptions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProductsIdOptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProductsIdOptionsOptionID invokes GetProductsIdOptionsOption_id operation.
//
// Retrieve a list of options in a product. The options can be filtered by fields like FILTER FIELDS.
// The options can also be paginated.
//
// GET /admin/products/{id}/options/{option_id}
func (c *Client) GetProductsIdOptionsOptionID(ctx context.Context, request jx.Raw, params GetProductsIdOptionsOptionIDParams) (GetProductsIdOptionsOptionIDRes, error) {
	res, err := c.sendGetProductsIdOptionsOptionID(ctx, request, params)
	return res, err
}

func (c *Client) sendGetProductsIdOptionsOptionID(ctx context.Context, request jx.Raw, params GetProductsIdOptionsOptionIDParams) (res GetProductsIdOptionsOptionIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetProductsIdOptionsOption_id"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/products/{id}/options/{option_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetProductsIdOptionsOptionID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/options/"
	{
		// Encode "option_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "option_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OptionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetProductsIdOptionsOptionIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetProductsIdOptionsOptionID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetProductsIdOptionsOptionID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetProductsIdOptionsOptionID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProductsIdOptionsOptionIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProductsIdVariants invokes GetProductsIdVariants operation.
//
// Retrieve a list of variants in a product. The variants can be filtered by fields like FILTER
// FIELDS. The variants can also be paginated.
//
// GET /admin/products/{id}/variants
func (c *Client) GetProductsIdVariants(ctx context.Context, request jx.Raw, params GetProductsIdVariantsParams) (GetProductsIdVariantsRes, error) {
	res, err := c.sendGetProductsIdVariants(ctx, request, params)
	return res, err
}

func (c *Client) sendGetProductsIdVariants(ctx context.Context, request jx.Raw, params GetProductsIdVariantsParams) (res GetProductsIdVariantsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetProductsIdVariants"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/products/{id}/variants"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetProductsIdVariants",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/variants"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetProductsIdVariantsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetProductsIdVariants", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetProductsIdVariants", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetProductsIdVariants", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProductsIdVariantsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProductsIdVariantsVariantID invokes GetProductsIdVariantsVariant_id operation.
//
// Retrieve a list of variants in a product. The variants can be filtered by fields like FILTER
// FIELDS. The variants can also be paginated.
//
// GET /admin/products/{id}/variants/{variant_id}
func (c *Client) GetProductsIdVariantsVariantID(ctx context.Context, request jx.Raw, params GetProductsIdVariantsVariantIDParams) (GetProductsIdVariantsVariantIDRes, error) {
	res, err := c.sendGetProductsIdVariantsVariantID(ctx, request, params)
	return res, err
}

func (c *Client) sendGetProductsIdVariantsVariantID(ctx context.Context, request jx.Raw, params GetProductsIdVariantsVariantIDParams) (res GetProductsIdVariantsVariantIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetProductsIdVariantsVariant_id"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/products/{id}/variants/{variant_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetProductsIdVariantsVariantID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/variants/"
	{
		// Encode "variant_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "variant_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VariantID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetProductsIdVariantsVariantIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetProductsIdVariantsVariantID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetProductsIdVariantsVariantID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetProductsIdVariantsVariantID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProductsIdVariantsVariantIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPromotions invokes GetPromotions operation.
//
// Retrieve a list of promotions. The promotions can be filtered by fields such as `id`. The
// promotions can also be sorted or paginated.
//
// GET /admin/promotions
func (c *Client) GetPromotions(ctx context.Context, request jx.Raw) (GetPromotionsRes, error) {
	res, err := c.sendGetPromotions(ctx, request)
	return res, err
}

func (c *Client) sendGetPromotions(ctx context.Context, request jx.Raw) (res GetPromotionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetPromotions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/promotions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPromotions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/promotions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetPromotionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetPromotions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetPromotions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetPromotions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPromotionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPromotionsId invokes GetPromotionsId operation.
//
// Retrieve a promotion by its ID. You can expand the promotion's relations or select the fields that
// should be returned.
//
// GET /admin/promotions/{id}
func (c *Client) GetPromotionsId(ctx context.Context, request OptAdminGetPromotionsParams, params GetPromotionsIdParams) (GetPromotionsIdRes, error) {
	res, err := c.sendGetPromotionsId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetPromotionsId(ctx context.Context, request OptAdminGetPromotionsParams, params GetPromotionsIdParams) (res GetPromotionsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetPromotionsId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/promotions/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPromotionsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/promotions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetPromotionsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetPromotionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetPromotionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetPromotionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPromotionsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRegions invokes GetRegions operation.
//
// Retrieve a list of regions. The regions can be filtered by fields such as `id`. The regions can
// also be sorted or paginated.
//
// GET /admin/regions
func (c *Client) GetRegions(ctx context.Context, request jx.Raw) (GetRegionsRes, error) {
	res, err := c.sendGetRegions(ctx, request)
	return res, err
}

func (c *Client) sendGetRegions(ctx context.Context, request jx.Raw) (res GetRegionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetRegions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/regions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetRegions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/regions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetRegionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetRegionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRegionsId invokes GetRegionsId operation.
//
// Retrieve a region by its ID. You can expand the region's relations or select the fields that
// should be returned.
//
// GET /admin/regions/{id}
func (c *Client) GetRegionsId(ctx context.Context, request jx.Raw, params GetRegionsIdParams) (GetRegionsIdRes, error) {
	res, err := c.sendGetRegionsId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetRegionsId(ctx context.Context, request jx.Raw, params GetRegionsIdParams) (res GetRegionsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetRegionsId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/regions/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetRegionsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/regions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetRegionsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetRegionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetRegionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetRegionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetRegionsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSalesChannels invokes GetSalesChannels operation.
//
// Retrieve a list of sales channels. The sales channels can be filtered by fields such as `id`. The
// sales channels can also be sorted or paginated.
//
// GET /admin/sales-channels
func (c *Client) GetSalesChannels(ctx context.Context, request jx.Raw) (GetSalesChannelsRes, error) {
	res, err := c.sendGetSalesChannels(ctx, request)
	return res, err
}

func (c *Client) sendGetSalesChannels(ctx context.Context, request jx.Raw) (res GetSalesChannelsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetSalesChannels"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/sales-channels"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSalesChannels",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/sales-channels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetSalesChannelsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetSalesChannels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetSalesChannels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetSalesChannels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSalesChannelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSalesChannelsId invokes GetSalesChannelsId operation.
//
// Retrieve a sales channel by its ID. You can expand the sales channel's relations or select the
// fields that should be returned.
//
// GET /admin/sales-channels/{id}
func (c *Client) GetSalesChannelsId(ctx context.Context, request jx.Raw, params GetSalesChannelsIdParams) (GetSalesChannelsIdRes, error) {
	res, err := c.sendGetSalesChannelsId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetSalesChannelsId(ctx context.Context, request jx.Raw, params GetSalesChannelsIdParams) (res GetSalesChannelsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetSalesChannelsId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/sales-channels/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSalesChannelsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/sales-channels/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetSalesChannelsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetSalesChannelsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetSalesChannelsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetSalesChannelsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSalesChannelsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStockLocationsId invokes GetStockLocationsId operation.
//
// Retrieve a stock location by its ID. You can expand the stock location's relations or select the
// fields that should be returned.
//
// GET /admin/stock-locations/{id}
func (c *Client) GetStockLocationsId(ctx context.Context, params GetStockLocationsIdParams) (GetStockLocationsIdRes, error) {
	res, err := c.sendGetStockLocationsId(ctx, params)
	return res, err
}

func (c *Client) sendGetStockLocationsId(ctx context.Context, params GetStockLocationsIdParams) (res GetStockLocationsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetStockLocationsId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/stock-locations/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStockLocationsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/stock-locations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetStockLocationsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetStockLocationsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetStockLocationsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStockLocationsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStores invokes GetStores operation.
//
// Retrieve a list of stores. The stores can be filtered by fields such as `id`. The stores can also
// be sorted or paginated.
//
// GET /admin/stores
func (c *Client) GetStores(ctx context.Context, request jx.Raw) (GetStoresRes, error) {
	res, err := c.sendGetStores(ctx, request)
	return res, err
}

func (c *Client) sendGetStores(ctx context.Context, request jx.Raw) (res GetStoresRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetStores"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/stores"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStores",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/stores"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetStoresRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetStores", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetStores", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetStores", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStoresResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStoresId invokes GetStoresId operation.
//
// Retrieve a store by its ID. You can expand the store's relations or select the fields that should
// be returned.
//
// GET /admin/stores/{id}
func (c *Client) GetStoresId(ctx context.Context, request jx.Raw, params GetStoresIdParams) (GetStoresIdRes, error) {
	res, err := c.sendGetStoresId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetStoresId(ctx context.Context, request jx.Raw, params GetStoresIdParams) (res GetStoresIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetStoresId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/stores/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStoresId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/stores/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetStoresIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetStoresId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetStoresId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetStoresId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStoresIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTaxRates invokes GetTaxRates operation.
//
// Retrieve a list of tax rates. The tax rates can be filtered by fields such as `id`. The tax rates
// can also be sorted or paginated.
//
// GET /admin/tax-rates
func (c *Client) GetTaxRates(ctx context.Context, request jx.Raw) (GetTaxRatesRes, error) {
	res, err := c.sendGetTaxRates(ctx, request)
	return res, err
}

func (c *Client) sendGetTaxRates(ctx context.Context, request jx.Raw) (res GetTaxRatesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetTaxRates"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/tax-rates"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetTaxRates",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/tax-rates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetTaxRatesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetTaxRates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetTaxRates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetTaxRates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTaxRatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTaxRatesId invokes GetTaxRatesId operation.
//
// Retrieve a tax rate by its ID. You can expand the tax rate's relations or select the fields that
// should be returned.
//
// GET /admin/tax-rates/{id}
func (c *Client) GetTaxRatesId(ctx context.Context, request jx.Raw, params GetTaxRatesIdParams) (GetTaxRatesIdRes, error) {
	res, err := c.sendGetTaxRatesId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetTaxRatesId(ctx context.Context, request jx.Raw, params GetTaxRatesIdParams) (res GetTaxRatesIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetTaxRatesId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/tax-rates/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetTaxRatesId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/tax-rates/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetTaxRatesIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetTaxRatesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetTaxRatesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetTaxRatesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTaxRatesIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUsers invokes GetUsers operation.
//
// Retrieve a list of users. The users can be filtered by fields such as `id`. The users can also be
// sorted or paginated.
//
// GET /admin/users
func (c *Client) GetUsers(ctx context.Context, request jx.Raw) (GetUsersRes, error) {
	res, err := c.sendGetUsers(ctx, request)
	return res, err
}

func (c *Client) sendGetUsers(ctx context.Context, request jx.Raw) (res GetUsersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetUsers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/users"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetUsers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetUsers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetUsers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetUsers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUsersId invokes GetUsersId operation.
//
// Retrieve a user by its ID. You can expand the user's relations or select the fields that should be
// returned.
//
// GET /admin/users/{id}
func (c *Client) GetUsersId(ctx context.Context, request jx.Raw, params GetUsersIdParams) (GetUsersIdRes, error) {
	res, err := c.sendGetUsersId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetUsersId(ctx context.Context, request jx.Raw, params GetUsersIdParams) (res GetUsersIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetUsersId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/users/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetUsersId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/users/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetUsersIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetUsersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetUsersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetUsersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetUsersIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUsersMe invokes GetUsersMe operation.
//
// Retrieve a list of users. The users can be filtered by fields such as `id`. The users can also be
// sorted or paginated.
//
// GET /admin/users/me
func (c *Client) GetUsersMe(ctx context.Context, request jx.Raw) (GetUsersMeRes, error) {
	res, err := c.sendGetUsersMe(ctx, request)
	return res, err
}

func (c *Client) sendGetUsersMe(ctx context.Context, request jx.Raw) (res GetUsersMeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetUsersMe"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/users/me"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetUsersMe",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/users/me"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetUsersMeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetUsersMe", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetUsersMe", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetUsersMe", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetUsersMeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkflowsExecutions invokes GetWorkflowsExecutions operation.
//
// Retrieve a list of workflows executions. The workflows executions can be filtered by fields such
// as `id`. The workflows executions can also be sorted or paginated.
//
// GET /admin/workflows-executions
func (c *Client) GetWorkflowsExecutions(ctx context.Context, request jx.Raw) (GetWorkflowsExecutionsRes, error) {
	res, err := c.sendGetWorkflowsExecutions(ctx, request)
	return res, err
}

func (c *Client) sendGetWorkflowsExecutions(ctx context.Context, request jx.Raw) (res GetWorkflowsExecutionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetWorkflowsExecutions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/workflows-executions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetWorkflowsExecutions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/workflows-executions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetWorkflowsExecutionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetWorkflowsExecutions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetWorkflowsExecutions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetWorkflowsExecutions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkflowsExecutionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkflowsExecutionsId invokes GetWorkflowsExecutionsId operation.
//
// Retrieve a workflows execution by its ID. You can expand the workflows execution's relations or
// select the fields that should be returned.
//
// GET /admin/workflows-executions/{id}
func (c *Client) GetWorkflowsExecutionsId(ctx context.Context, request jx.Raw, params GetWorkflowsExecutionsIdParams) (GetWorkflowsExecutionsIdRes, error) {
	res, err := c.sendGetWorkflowsExecutionsId(ctx, request, params)
	return res, err
}

func (c *Client) sendGetWorkflowsExecutionsId(ctx context.Context, request jx.Raw, params GetWorkflowsExecutionsIdParams) (res GetWorkflowsExecutionsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetWorkflowsExecutionsId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/workflows-executions/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetWorkflowsExecutionsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/workflows-executions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetWorkflowsExecutionsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetWorkflowsExecutionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetWorkflowsExecutionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetWorkflowsExecutionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkflowsExecutionsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkflowsExecutionsWorkflowIdSubscribe invokes GetWorkflowsExecutionsWorkflow_idSubscribe operation.
//
// Retrieve a list of subscribes in a workflows execution. The subscribes can be filtered by fields
// like FILTER FIELDS. The subscribes can also be paginated.
//
// GET /admin/workflows-executions/{workflow_id}/subscribe
func (c *Client) GetWorkflowsExecutionsWorkflowIdSubscribe(ctx context.Context, request jx.Raw, params GetWorkflowsExecutionsWorkflowIdSubscribeParams) (GetWorkflowsExecutionsWorkflowIdSubscribeRes, error) {
	res, err := c.sendGetWorkflowsExecutionsWorkflowIdSubscribe(ctx, request, params)
	return res, err
}

func (c *Client) sendGetWorkflowsExecutionsWorkflowIdSubscribe(ctx context.Context, request jx.Raw, params GetWorkflowsExecutionsWorkflowIdSubscribeParams) (res GetWorkflowsExecutionsWorkflowIdSubscribeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetWorkflowsExecutionsWorkflow_idSubscribe"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/workflows-executions/{workflow_id}/subscribe"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetWorkflowsExecutionsWorkflowIdSubscribe",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/workflows-executions/"
	{
		// Encode "workflow_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workflow_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WorkflowID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subscribe"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetWorkflowsExecutionsWorkflowIdSubscribeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetWorkflowsExecutionsWorkflowIdSubscribe", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetWorkflowsExecutionsWorkflowIdSubscribe", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetWorkflowsExecutionsWorkflowIdSubscribe", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkflowsExecutionsWorkflowIdSubscribeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkflowsExecutionsWorkflowIdTransactionID invokes GetWorkflowsExecutionsWorkflow_idTransaction_id operation.
//
// Retrieve a list of  in a workflows execution. The  can be filtered by fields like FILTER FIELDS.
// The  can also be paginated.
//
// GET /admin/workflows-executions/{workflow_id}/{transaction_id}
func (c *Client) GetWorkflowsExecutionsWorkflowIdTransactionID(ctx context.Context, request jx.Raw, params GetWorkflowsExecutionsWorkflowIdTransactionIDParams) (GetWorkflowsExecutionsWorkflowIdTransactionIDRes, error) {
	res, err := c.sendGetWorkflowsExecutionsWorkflowIdTransactionID(ctx, request, params)
	return res, err
}

func (c *Client) sendGetWorkflowsExecutionsWorkflowIdTransactionID(ctx context.Context, request jx.Raw, params GetWorkflowsExecutionsWorkflowIdTransactionIDParams) (res GetWorkflowsExecutionsWorkflowIdTransactionIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetWorkflowsExecutionsWorkflow_idTransaction_id"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/workflows-executions/{workflow_id}/{transaction_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetWorkflowsExecutionsWorkflowIdTransactionID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/workflows-executions/"
	{
		// Encode "workflow_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workflow_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WorkflowID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "transaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "transaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TransactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetWorkflowsExecutionsWorkflowIdTransactionIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetWorkflowsExecutionsWorkflowIdTransactionID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetWorkflowsExecutionsWorkflowIdTransactionID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetWorkflowsExecutionsWorkflowIdTransactionID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkflowsExecutionsWorkflowIdTransactionIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe invokes GetWorkflowsExecutionsWorkflow_idTransaction_idStep_idSubscribe operation.
//
// Retrieve a list of subscribes in a workflows execution. The subscribes can be filtered by fields
// like FILTER FIELDS. The subscribes can also be paginated.
//
// GET /admin/workflows-executions/{workflow_id}/{transaction_id}/{step_id}/subscribe
func (c *Client) GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe(ctx context.Context, request jx.Raw, params GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeParams) (GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeRes, error) {
	res, err := c.sendGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe(ctx, request, params)
	return res, err
}

func (c *Client) sendGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe(ctx context.Context, request jx.Raw, params GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeParams) (res GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetWorkflowsExecutionsWorkflow_idTransaction_idStep_idSubscribe"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/admin/workflows-executions/{workflow_id}/{transaction_id}/{step_id}/subscribe"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/admin/workflows-executions/"
	{
		// Encode "workflow_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workflow_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WorkflowID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "transaction_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "transaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TransactionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "step_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "step_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StepID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/subscribe"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostApiKeys invokes PostApiKeys operation.
//
// Create a api key.
//
// POST /admin/api-keys
func (c *Client) PostApiKeys(ctx context.Context, request jx.Raw) (PostApiKeysRes, error) {
	res, err := c.sendPostApiKeys(ctx, request)
	return res, err
}

func (c *Client) sendPostApiKeys(ctx context.Context, request jx.Raw) (res PostApiKeysRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostApiKeys"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/api-keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostApiKeys",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/api-keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostApiKeysRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostApiKeys", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostApiKeys", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostApiKeys", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostApiKeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostApiKeysId invokes PostApiKeysId operation.
//
// Update a api key's details.
//
// POST /admin/api-keys/{id}
func (c *Client) PostApiKeysId(ctx context.Context, request jx.Raw, params PostApiKeysIdParams) (PostApiKeysIdRes, error) {
	res, err := c.sendPostApiKeysId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostApiKeysId(ctx context.Context, request jx.Raw, params PostApiKeysIdParams) (res PostApiKeysIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostApiKeysId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/api-keys/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostApiKeysId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/api-keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostApiKeysIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostApiKeysId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostApiKeysId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostApiKeysId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostApiKeysIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostApiKeysIdRevoke invokes PostApiKeysIdRevoke operation.
//
// Add a list of revokes to a api key.
//
// POST /admin/api-keys/{id}/revoke
func (c *Client) PostApiKeysIdRevoke(ctx context.Context, request jx.Raw, params PostApiKeysIdRevokeParams) (PostApiKeysIdRevokeRes, error) {
	res, err := c.sendPostApiKeysIdRevoke(ctx, request, params)
	return res, err
}

func (c *Client) sendPostApiKeysIdRevoke(ctx context.Context, request jx.Raw, params PostApiKeysIdRevokeParams) (res PostApiKeysIdRevokeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostApiKeysIdRevoke"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/api-keys/{id}/revoke"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostApiKeysIdRevoke",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/api-keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/revoke"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostApiKeysIdRevokeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostApiKeysIdRevoke", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostApiKeysIdRevoke", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostApiKeysIdRevoke", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostApiKeysIdRevokeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostCampaigns invokes PostCampaigns operation.
//
// Create a campaign.
//
// POST /admin/campaigns
func (c *Client) PostCampaigns(ctx context.Context, request jx.Raw) (PostCampaignsRes, error) {
	res, err := c.sendPostCampaigns(ctx, request)
	return res, err
}

func (c *Client) sendPostCampaigns(ctx context.Context, request jx.Raw) (res PostCampaignsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostCampaigns"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/campaigns"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostCampaigns",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/campaigns"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostCampaignsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostCampaigns", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostCampaigns", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostCampaigns", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostCampaignsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostCampaignsId invokes PostCampaignsId operation.
//
// Update a campaign's details.
//
// POST /admin/campaigns/{id}
func (c *Client) PostCampaignsId(ctx context.Context, request OptAdminPostCampaignsReq, params PostCampaignsIdParams) (PostCampaignsIdRes, error) {
	res, err := c.sendPostCampaignsId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostCampaignsId(ctx context.Context, request OptAdminPostCampaignsReq, params PostCampaignsIdParams) (res PostCampaignsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostCampaignsId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/campaigns/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostCampaignsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/campaigns/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostCampaignsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostCampaignsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostCampaignsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostCampaignsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostCampaignsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostCollections invokes PostCollections operation.
//
// Create a collection.
//
// POST /admin/collections
func (c *Client) PostCollections(ctx context.Context, request jx.Raw) (PostCollectionsRes, error) {
	res, err := c.sendPostCollections(ctx, request)
	return res, err
}

func (c *Client) sendPostCollections(ctx context.Context, request jx.Raw) (res PostCollectionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostCollections"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/collections"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostCollections",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/collections"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostCollectionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostCollections", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostCollections", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostCollections", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostCollectionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostCollectionsId invokes PostCollectionsId operation.
//
// Update a collection's details.
//
// POST /admin/collections/{id}
func (c *Client) PostCollectionsId(ctx context.Context, request jx.Raw, params PostCollectionsIdParams) (PostCollectionsIdRes, error) {
	res, err := c.sendPostCollectionsId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostCollectionsId(ctx context.Context, request jx.Raw, params PostCollectionsIdParams) (res PostCollectionsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostCollectionsId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/collections/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostCollectionsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/collections/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostCollectionsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostCollectionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostCollectionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostCollectionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostCollectionsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostCustomerGroups invokes PostCustomerGroups operation.
//
// Create a customer group.
//
// POST /admin/customer-groups
func (c *Client) PostCustomerGroups(ctx context.Context, request jx.Raw) (PostCustomerGroupsRes, error) {
	res, err := c.sendPostCustomerGroups(ctx, request)
	return res, err
}

func (c *Client) sendPostCustomerGroups(ctx context.Context, request jx.Raw) (res PostCustomerGroupsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostCustomerGroups"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/customer-groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostCustomerGroups",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/customer-groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostCustomerGroupsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostCustomerGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostCustomerGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostCustomerGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostCustomerGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostCustomerGroupsId invokes PostCustomerGroupsId operation.
//
// Update a customer group's details.
//
// POST /admin/customer-groups/{id}
func (c *Client) PostCustomerGroupsId(ctx context.Context, request jx.Raw, params PostCustomerGroupsIdParams) (PostCustomerGroupsIdRes, error) {
	res, err := c.sendPostCustomerGroupsId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostCustomerGroupsId(ctx context.Context, request jx.Raw, params PostCustomerGroupsIdParams) (res PostCustomerGroupsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostCustomerGroupsId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/customer-groups/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostCustomerGroupsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/customer-groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostCustomerGroupsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostCustomerGroupsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostCustomerGroupsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostCustomerGroupsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostCustomerGroupsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostCustomerGroupsIdCustomersBatch invokes PostCustomerGroupsIdCustomersBatch operation.
//
// Add a list of customers to a customer group.
//
// POST /admin/customer-groups/{id}/customers/batch
func (c *Client) PostCustomerGroupsIdCustomersBatch(ctx context.Context, request OptAdminPostCustomerGroupsGroupCustomersBatchReq, params PostCustomerGroupsIdCustomersBatchParams) (PostCustomerGroupsIdCustomersBatchRes, error) {
	res, err := c.sendPostCustomerGroupsIdCustomersBatch(ctx, request, params)
	return res, err
}

func (c *Client) sendPostCustomerGroupsIdCustomersBatch(ctx context.Context, request OptAdminPostCustomerGroupsGroupCustomersBatchReq, params PostCustomerGroupsIdCustomersBatchParams) (res PostCustomerGroupsIdCustomersBatchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostCustomerGroupsIdCustomersBatch"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/customer-groups/{id}/customers/batch"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostCustomerGroupsIdCustomersBatch",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/customer-groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/customers/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostCustomerGroupsIdCustomersBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostCustomerGroupsIdCustomersBatch", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostCustomerGroupsIdCustomersBatch", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostCustomerGroupsIdCustomersBatch", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostCustomerGroupsIdCustomersBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostCustomerGroupsIdCustomersRemove invokes PostCustomerGroupsIdCustomersRemove operation.
//
// Add a list of removes to a customer group.
//
// POST /admin/customer-groups/{id}/customers/remove
func (c *Client) PostCustomerGroupsIdCustomersRemove(ctx context.Context, request OptAdminPostCustomerGroupsGroupCustomersBatchReq, params PostCustomerGroupsIdCustomersRemoveParams) (PostCustomerGroupsIdCustomersRemoveRes, error) {
	res, err := c.sendPostCustomerGroupsIdCustomersRemove(ctx, request, params)
	return res, err
}

func (c *Client) sendPostCustomerGroupsIdCustomersRemove(ctx context.Context, request OptAdminPostCustomerGroupsGroupCustomersBatchReq, params PostCustomerGroupsIdCustomersRemoveParams) (res PostCustomerGroupsIdCustomersRemoveRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostCustomerGroupsIdCustomersRemove"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/customer-groups/{id}/customers/remove"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostCustomerGroupsIdCustomersRemove",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/customer-groups/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/customers/remove"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostCustomerGroupsIdCustomersRemoveRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostCustomerGroupsIdCustomersRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostCustomerGroupsIdCustomersRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostCustomerGroupsIdCustomersRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostCustomerGroupsIdCustomersRemoveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostCustomers invokes PostCustomers operation.
//
// Create a customer.
//
// POST /admin/customers
func (c *Client) PostCustomers(ctx context.Context, request jx.Raw) (PostCustomersRes, error) {
	res, err := c.sendPostCustomers(ctx, request)
	return res, err
}

func (c *Client) sendPostCustomers(ctx context.Context, request jx.Raw) (res PostCustomersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostCustomers"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/customers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostCustomers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/customers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostCustomersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostCustomers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostCustomers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostCustomers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostCustomersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostCustomersId invokes PostCustomersId operation.
//
// Update a customer's details.
//
// POST /admin/customers/{id}
func (c *Client) PostCustomersId(ctx context.Context, request jx.Raw, params PostCustomersIdParams) (PostCustomersIdRes, error) {
	res, err := c.sendPostCustomersId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostCustomersId(ctx context.Context, request jx.Raw, params PostCustomersIdParams) (res PostCustomersIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostCustomersId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/customers/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostCustomersId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/customers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostCustomersIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostCustomersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostCustomersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostCustomersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostCustomersIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostCustomersIdAddresses invokes PostCustomersIdAddresses operation.
//
// Add a list of addresses to a customer.
//
// POST /admin/customers/{id}/addresses
func (c *Client) PostCustomersIdAddresses(ctx context.Context, request jx.Raw, params PostCustomersIdAddressesParams) (PostCustomersIdAddressesRes, error) {
	res, err := c.sendPostCustomersIdAddresses(ctx, request, params)
	return res, err
}

func (c *Client) sendPostCustomersIdAddresses(ctx context.Context, request jx.Raw, params PostCustomersIdAddressesParams) (res PostCustomersIdAddressesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostCustomersIdAddresses"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/customers/{id}/addresses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostCustomersIdAddresses",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/customers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/addresses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostCustomersIdAddressesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostCustomersIdAddresses", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostCustomersIdAddresses", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostCustomersIdAddresses", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostCustomersIdAddressesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostCustomersIdAddressesAddressID invokes PostCustomersIdAddressesAddress_id operation.
//
// Add a list of addresses to a customer.
//
// POST /admin/customers/{id}/addresses/{address_id}
func (c *Client) PostCustomersIdAddressesAddressID(ctx context.Context, request jx.Raw, params PostCustomersIdAddressesAddressIDParams) (PostCustomersIdAddressesAddressIDRes, error) {
	res, err := c.sendPostCustomersIdAddressesAddressID(ctx, request, params)
	return res, err
}

func (c *Client) sendPostCustomersIdAddressesAddressID(ctx context.Context, request jx.Raw, params PostCustomersIdAddressesAddressIDParams) (res PostCustomersIdAddressesAddressIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostCustomersIdAddressesAddress_id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/customers/{id}/addresses/{address_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostCustomersIdAddressesAddressID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/customers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/addresses/"
	{
		// Encode "address_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "address_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AddressID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostCustomersIdAddressesAddressIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostCustomersIdAddressesAddressID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostCustomersIdAddressesAddressID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostCustomersIdAddressesAddressID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostCustomersIdAddressesAddressIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostFulfillmentShippingOptionsIdRulesBatchAdd invokes PostFulfillmentShippingOptionsIdRulesBatchAdd operation.
//
// Add a list of adds to a fulfillment.
//
// POST /admin/fulfillment/shipping-options/{id}/rules/batch/add
func (c *Client) PostFulfillmentShippingOptionsIdRulesBatchAdd(ctx context.Context, request OptAdminPostFulfillmentShippingOptionsRulesBatchAddReq, params PostFulfillmentShippingOptionsIdRulesBatchAddParams) (PostFulfillmentShippingOptionsIdRulesBatchAddRes, error) {
	res, err := c.sendPostFulfillmentShippingOptionsIdRulesBatchAdd(ctx, request, params)
	return res, err
}

func (c *Client) sendPostFulfillmentShippingOptionsIdRulesBatchAdd(ctx context.Context, request OptAdminPostFulfillmentShippingOptionsRulesBatchAddReq, params PostFulfillmentShippingOptionsIdRulesBatchAddParams) (res PostFulfillmentShippingOptionsIdRulesBatchAddRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostFulfillmentShippingOptionsIdRulesBatchAdd"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/fulfillment/shipping-options/{id}/rules/batch/add"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostFulfillmentShippingOptionsIdRulesBatchAdd",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/fulfillment/shipping-options/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rules/batch/add"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostFulfillmentShippingOptionsIdRulesBatchAddRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostFulfillmentShippingOptionsIdRulesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostFulfillmentShippingOptionsIdRulesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostFulfillmentShippingOptionsIdRulesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostFulfillmentShippingOptionsIdRulesBatchAddResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostFulfillmentShippingOptionsIdRulesBatchRemove invokes PostFulfillmentShippingOptionsIdRulesBatchRemove operation.
//
// Add a list of removes to a fulfillment.
//
// POST /admin/fulfillment/shipping-options/{id}/rules/batch/remove
func (c *Client) PostFulfillmentShippingOptionsIdRulesBatchRemove(ctx context.Context, request OptAdminPostFulfillmentShippingOptionsRulesBatchRemoveReq, params PostFulfillmentShippingOptionsIdRulesBatchRemoveParams) (PostFulfillmentShippingOptionsIdRulesBatchRemoveRes, error) {
	res, err := c.sendPostFulfillmentShippingOptionsIdRulesBatchRemove(ctx, request, params)
	return res, err
}

func (c *Client) sendPostFulfillmentShippingOptionsIdRulesBatchRemove(ctx context.Context, request OptAdminPostFulfillmentShippingOptionsRulesBatchRemoveReq, params PostFulfillmentShippingOptionsIdRulesBatchRemoveParams) (res PostFulfillmentShippingOptionsIdRulesBatchRemoveRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostFulfillmentShippingOptionsIdRulesBatchRemove"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/fulfillment/shipping-options/{id}/rules/batch/remove"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostFulfillmentShippingOptionsIdRulesBatchRemove",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/fulfillment/shipping-options/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rules/batch/remove"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostFulfillmentShippingOptionsIdRulesBatchRemoveRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostFulfillmentShippingOptionsIdRulesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostFulfillmentShippingOptionsIdRulesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostFulfillmentShippingOptionsIdRulesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostFulfillmentShippingOptionsIdRulesBatchRemoveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostInventoryItems invokes PostInventoryItems operation.
//
// Create a inventory item.
//
// POST /admin/inventory-items
func (c *Client) PostInventoryItems(ctx context.Context, request OptAdminPostInventoryItemsReq) (PostInventoryItemsRes, error) {
	res, err := c.sendPostInventoryItems(ctx, request)
	return res, err
}

func (c *Client) sendPostInventoryItems(ctx context.Context, request OptAdminPostInventoryItemsReq) (res PostInventoryItemsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostInventoryItems"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/inventory-items"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostInventoryItems",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/inventory-items"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostInventoryItemsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostInventoryItems", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostInventoryItems", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostInventoryItems", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostInventoryItemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostInventoryItemsId invokes PostInventoryItemsId operation.
//
// Update a inventory item's details.
//
// POST /admin/inventory-items/{id}
func (c *Client) PostInventoryItemsId(ctx context.Context, request OptAdminPostInventoryItemsInventoryItemReq, params PostInventoryItemsIdParams) (PostInventoryItemsIdRes, error) {
	res, err := c.sendPostInventoryItemsId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostInventoryItemsId(ctx context.Context, request OptAdminPostInventoryItemsInventoryItemReq, params PostInventoryItemsIdParams) (res PostInventoryItemsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostInventoryItemsId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/inventory-items/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostInventoryItemsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/inventory-items/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostInventoryItemsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostInventoryItemsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostInventoryItemsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostInventoryItemsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostInventoryItemsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostInventoryItemsIdLocationLevels invokes PostInventoryItemsIdLocationLevels operation.
//
// Add a list of location levels to a inventory item.
//
// POST /admin/inventory-items/{id}/location-levels
func (c *Client) PostInventoryItemsIdLocationLevels(ctx context.Context, request OptAdminPostInventoryItemsItemLocationLevelsReq, params PostInventoryItemsIdLocationLevelsParams) (PostInventoryItemsIdLocationLevelsRes, error) {
	res, err := c.sendPostInventoryItemsIdLocationLevels(ctx, request, params)
	return res, err
}

func (c *Client) sendPostInventoryItemsIdLocationLevels(ctx context.Context, request OptAdminPostInventoryItemsItemLocationLevelsReq, params PostInventoryItemsIdLocationLevelsParams) (res PostInventoryItemsIdLocationLevelsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostInventoryItemsIdLocationLevels"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/inventory-items/{id}/location-levels"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostInventoryItemsIdLocationLevels",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/inventory-items/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/location-levels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostInventoryItemsIdLocationLevelsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostInventoryItemsIdLocationLevels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostInventoryItemsIdLocationLevels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostInventoryItemsIdLocationLevels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostInventoryItemsIdLocationLevelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostInventoryItemsIdLocationLevelsLocationID invokes PostInventoryItemsIdLocationLevelsLocation_id operation.
//
// Add a list of location levels to a inventory item.
//
// POST /admin/inventory-items/{id}/location-levels/{location_id}
func (c *Client) PostInventoryItemsIdLocationLevelsLocationID(ctx context.Context, request OptAdminPostInventoryItemsItemLocationLevelsLevelReq, params PostInventoryItemsIdLocationLevelsLocationIDParams) (PostInventoryItemsIdLocationLevelsLocationIDRes, error) {
	res, err := c.sendPostInventoryItemsIdLocationLevelsLocationID(ctx, request, params)
	return res, err
}

func (c *Client) sendPostInventoryItemsIdLocationLevelsLocationID(ctx context.Context, request OptAdminPostInventoryItemsItemLocationLevelsLevelReq, params PostInventoryItemsIdLocationLevelsLocationIDParams) (res PostInventoryItemsIdLocationLevelsLocationIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostInventoryItemsIdLocationLevelsLocation_id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/inventory-items/{id}/location-levels/{location_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostInventoryItemsIdLocationLevelsLocationID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/inventory-items/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/location-levels/"
	{
		// Encode "location_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "location_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LocationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostInventoryItemsIdLocationLevelsLocationIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostInventoryItemsIdLocationLevelsLocationID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostInventoryItemsIdLocationLevelsLocationID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostInventoryItemsIdLocationLevelsLocationID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostInventoryItemsIdLocationLevelsLocationIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostInvites invokes PostInvites operation.
//
// Create a invite.
//
// POST /admin/invites
func (c *Client) PostInvites(ctx context.Context, request jx.Raw) (PostInvitesRes, error) {
	res, err := c.sendPostInvites(ctx, request)
	return res, err
}

func (c *Client) sendPostInvites(ctx context.Context, request jx.Raw) (res PostInvitesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostInvites"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/invites"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostInvites",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/invites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostInvitesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostInvites", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostInvites", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostInvites", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostInvitesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostInvitesAccept invokes PostInvitesAccept operation.
//
// Create a invite.
//
// POST /admin/invites/accept
func (c *Client) PostInvitesAccept(ctx context.Context, request OptAdminPostInvitesInviteAcceptReq) (PostInvitesAcceptRes, error) {
	res, err := c.sendPostInvitesAccept(ctx, request)
	return res, err
}

func (c *Client) sendPostInvitesAccept(ctx context.Context, request OptAdminPostInvitesInviteAcceptReq) (res PostInvitesAcceptRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostInvitesAccept"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/invites/accept"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostInvitesAccept",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/invites/accept"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostInvitesAcceptRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostInvitesAccept", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostInvitesAccept", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostInvitesAccept", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostInvitesAcceptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostInvitesIdResend invokes PostInvitesIdResend operation.
//
// Add a list of resends to a invite.
//
// POST /admin/invites/{id}/resend
func (c *Client) PostInvitesIdResend(ctx context.Context, request jx.Raw, params PostInvitesIdResendParams) (PostInvitesIdResendRes, error) {
	res, err := c.sendPostInvitesIdResend(ctx, request, params)
	return res, err
}

func (c *Client) sendPostInvitesIdResend(ctx context.Context, request jx.Raw, params PostInvitesIdResendParams) (res PostInvitesIdResendRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostInvitesIdResend"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/invites/{id}/resend"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostInvitesIdResend",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/invites/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/resend"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostInvitesIdResendRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostInvitesIdResend", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostInvitesIdResend", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostInvitesIdResend", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostInvitesIdResendResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPaymentsIdCapture invokes PostPaymentsIdCapture operation.
//
// Add a list of captures to a payment.
//
// POST /admin/payments/{id}/capture
func (c *Client) PostPaymentsIdCapture(ctx context.Context, request OptAdminPostPaymentsCapturesReq, params PostPaymentsIdCaptureParams) (PostPaymentsIdCaptureRes, error) {
	res, err := c.sendPostPaymentsIdCapture(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPaymentsIdCapture(ctx context.Context, request OptAdminPostPaymentsCapturesReq, params PostPaymentsIdCaptureParams) (res PostPaymentsIdCaptureRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPaymentsIdCapture"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/payments/{id}/capture"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPaymentsIdCapture",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/payments/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/capture"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPaymentsIdCaptureRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPaymentsIdCapture", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPaymentsIdCapture", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPaymentsIdCapture", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPaymentsIdCaptureResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPaymentsIdRefund invokes PostPaymentsIdRefund operation.
//
// Add a list of refunds to a payment.
//
// POST /admin/payments/{id}/refund
func (c *Client) PostPaymentsIdRefund(ctx context.Context, request OptAdminPostPaymentsRefundsReq, params PostPaymentsIdRefundParams) (PostPaymentsIdRefundRes, error) {
	res, err := c.sendPostPaymentsIdRefund(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPaymentsIdRefund(ctx context.Context, request OptAdminPostPaymentsRefundsReq, params PostPaymentsIdRefundParams) (res PostPaymentsIdRefundRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPaymentsIdRefund"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/payments/{id}/refund"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPaymentsIdRefund",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/payments/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/refund"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPaymentsIdRefundRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPaymentsIdRefund", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPaymentsIdRefund", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPaymentsIdRefund", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPaymentsIdRefundResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPriceLists invokes PostPriceLists operation.
//
// Create a price list.
//
// POST /admin/price-lists
func (c *Client) PostPriceLists(ctx context.Context, request OptAdminPostPriceListsReq) (PostPriceListsRes, error) {
	res, err := c.sendPostPriceLists(ctx, request)
	return res, err
}

func (c *Client) sendPostPriceLists(ctx context.Context, request OptAdminPostPriceListsReq) (res PostPriceListsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPriceLists"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/price-lists"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPriceLists",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/price-lists"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPriceListsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPriceLists", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPriceLists", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPriceLists", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPriceListsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPriceListsId invokes PostPriceListsId operation.
//
// Update a price list's details.
//
// POST /admin/price-lists/{id}
func (c *Client) PostPriceListsId(ctx context.Context, request OptAdminPostPriceListsPriceListReq, params PostPriceListsIdParams) (PostPriceListsIdRes, error) {
	res, err := c.sendPostPriceListsId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPriceListsId(ctx context.Context, request OptAdminPostPriceListsPriceListReq, params PostPriceListsIdParams) (res PostPriceListsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPriceListsId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/price-lists/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPriceListsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/price-lists/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPriceListsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPriceListsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPriceListsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPriceListsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPriceListsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPriceListsIdPricesBatchAdd invokes PostPriceListsIdPricesBatchAdd operation.
//
// Add a list of adds to a price list.
//
// POST /admin/price-lists/{id}/prices/batch/add
func (c *Client) PostPriceListsIdPricesBatchAdd(ctx context.Context, request OptAdminPostPriceListsPriceListPricesBatchAddReq, params PostPriceListsIdPricesBatchAddParams) (PostPriceListsIdPricesBatchAddRes, error) {
	res, err := c.sendPostPriceListsIdPricesBatchAdd(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPriceListsIdPricesBatchAdd(ctx context.Context, request OptAdminPostPriceListsPriceListPricesBatchAddReq, params PostPriceListsIdPricesBatchAddParams) (res PostPriceListsIdPricesBatchAddRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPriceListsIdPricesBatchAdd"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/price-lists/{id}/prices/batch/add"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPriceListsIdPricesBatchAdd",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/price-lists/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/prices/batch/add"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPriceListsIdPricesBatchAddRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPriceListsIdPricesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPriceListsIdPricesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPriceListsIdPricesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPriceListsIdPricesBatchAddResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPriceListsIdPricesBatchRemove invokes PostPriceListsIdPricesBatchRemove operation.
//
// Add a list of removes to a price list.
//
// POST /admin/price-lists/{id}/prices/batch/remove
func (c *Client) PostPriceListsIdPricesBatchRemove(ctx context.Context, request OptAdminPostPriceListsPriceListPricesBatchRemoveReq, params PostPriceListsIdPricesBatchRemoveParams) (PostPriceListsIdPricesBatchRemoveRes, error) {
	res, err := c.sendPostPriceListsIdPricesBatchRemove(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPriceListsIdPricesBatchRemove(ctx context.Context, request OptAdminPostPriceListsPriceListPricesBatchRemoveReq, params PostPriceListsIdPricesBatchRemoveParams) (res PostPriceListsIdPricesBatchRemoveRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPriceListsIdPricesBatchRemove"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/price-lists/{id}/prices/batch/remove"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPriceListsIdPricesBatchRemove",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/price-lists/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/prices/batch/remove"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPriceListsIdPricesBatchRemoveRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPriceListsIdPricesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPriceListsIdPricesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPriceListsIdPricesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPriceListsIdPricesBatchRemoveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPricingRuleTypes invokes PostPricingRuleTypes operation.
//
// Create a pricing.
//
// POST /admin/pricing/rule-types
func (c *Client) PostPricingRuleTypes(ctx context.Context, request OptAdminPostPricingRuleTypesReq) (PostPricingRuleTypesRes, error) {
	res, err := c.sendPostPricingRuleTypes(ctx, request)
	return res, err
}

func (c *Client) sendPostPricingRuleTypes(ctx context.Context, request OptAdminPostPricingRuleTypesReq) (res PostPricingRuleTypesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPricingRuleTypes"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/pricing/rule-types"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPricingRuleTypes",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/pricing/rule-types"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPricingRuleTypesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPricingRuleTypes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPricingRuleTypes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPricingRuleTypes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPricingRuleTypesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPricingRuleTypesId invokes PostPricingRuleTypesId operation.
//
// Add a list of rule types to a pricing.
//
// POST /admin/pricing/rule-types/{id}
func (c *Client) PostPricingRuleTypesId(ctx context.Context, request OptAdminPostPricingRuleTypesRuleTypeReq, params PostPricingRuleTypesIdParams) (PostPricingRuleTypesIdRes, error) {
	res, err := c.sendPostPricingRuleTypesId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPricingRuleTypesId(ctx context.Context, request OptAdminPostPricingRuleTypesRuleTypeReq, params PostPricingRuleTypesIdParams) (res PostPricingRuleTypesIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPricingRuleTypesId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/pricing/rule-types/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPricingRuleTypesId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/pricing/rule-types/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPricingRuleTypesIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPricingRuleTypesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPricingRuleTypesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPricingRuleTypesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPricingRuleTypesIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostProducts invokes PostProducts operation.
//
// Create a product.
//
// POST /admin/products
func (c *Client) PostProducts(ctx context.Context, request jx.Raw) (PostProductsRes, error) {
	res, err := c.sendPostProducts(ctx, request)
	return res, err
}

func (c *Client) sendPostProducts(ctx context.Context, request jx.Raw) (res PostProductsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostProducts"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/products"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostProducts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/products"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostProductsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostProducts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostProducts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostProducts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostProductsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostProductsId invokes PostProductsId operation.
//
// Update a product's details.
//
// POST /admin/products/{id}
func (c *Client) PostProductsId(ctx context.Context, request jx.Raw, params PostProductsIdParams) (PostProductsIdRes, error) {
	res, err := c.sendPostProductsId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostProductsId(ctx context.Context, request jx.Raw, params PostProductsIdParams) (res PostProductsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostProductsId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/products/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostProductsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostProductsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostProductsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostProductsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostProductsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostProductsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostProductsIdOptions invokes PostProductsIdOptions operation.
//
// Add a list of options to a product.
//
// POST /admin/products/{id}/options
func (c *Client) PostProductsIdOptions(ctx context.Context, request jx.Raw, params PostProductsIdOptionsParams) (PostProductsIdOptionsRes, error) {
	res, err := c.sendPostProductsIdOptions(ctx, request, params)
	return res, err
}

func (c *Client) sendPostProductsIdOptions(ctx context.Context, request jx.Raw, params PostProductsIdOptionsParams) (res PostProductsIdOptionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostProductsIdOptions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/products/{id}/options"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostProductsIdOptions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/options"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostProductsIdOptionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostProductsIdOptions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostProductsIdOptions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostProductsIdOptions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostProductsIdOptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostProductsIdOptionsOptionID invokes PostProductsIdOptionsOption_id operation.
//
// Add a list of options to a product.
//
// POST /admin/products/{id}/options/{option_id}
func (c *Client) PostProductsIdOptionsOptionID(ctx context.Context, request jx.Raw, params PostProductsIdOptionsOptionIDParams) (PostProductsIdOptionsOptionIDRes, error) {
	res, err := c.sendPostProductsIdOptionsOptionID(ctx, request, params)
	return res, err
}

func (c *Client) sendPostProductsIdOptionsOptionID(ctx context.Context, request jx.Raw, params PostProductsIdOptionsOptionIDParams) (res PostProductsIdOptionsOptionIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostProductsIdOptionsOption_id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/products/{id}/options/{option_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostProductsIdOptionsOptionID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/options/"
	{
		// Encode "option_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "option_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OptionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostProductsIdOptionsOptionIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostProductsIdOptionsOptionID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostProductsIdOptionsOptionID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostProductsIdOptionsOptionID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostProductsIdOptionsOptionIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostProductsIdVariants invokes PostProductsIdVariants operation.
//
// Add a list of variants to a product.
//
// POST /admin/products/{id}/variants
func (c *Client) PostProductsIdVariants(ctx context.Context, request jx.Raw, params PostProductsIdVariantsParams) (PostProductsIdVariantsRes, error) {
	res, err := c.sendPostProductsIdVariants(ctx, request, params)
	return res, err
}

func (c *Client) sendPostProductsIdVariants(ctx context.Context, request jx.Raw, params PostProductsIdVariantsParams) (res PostProductsIdVariantsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostProductsIdVariants"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/products/{id}/variants"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostProductsIdVariants",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/variants"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostProductsIdVariantsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostProductsIdVariants", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostProductsIdVariants", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostProductsIdVariants", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostProductsIdVariantsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostProductsIdVariantsVariantID invokes PostProductsIdVariantsVariant_id operation.
//
// Add a list of variants to a product.
//
// POST /admin/products/{id}/variants/{variant_id}
func (c *Client) PostProductsIdVariantsVariantID(ctx context.Context, request jx.Raw, params PostProductsIdVariantsVariantIDParams) (PostProductsIdVariantsVariantIDRes, error) {
	res, err := c.sendPostProductsIdVariantsVariantID(ctx, request, params)
	return res, err
}

func (c *Client) sendPostProductsIdVariantsVariantID(ctx context.Context, request jx.Raw, params PostProductsIdVariantsVariantIDParams) (res PostProductsIdVariantsVariantIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostProductsIdVariantsVariant_id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/products/{id}/variants/{variant_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostProductsIdVariantsVariantID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/admin/products/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/variants/"
	{
		// Encode "variant_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "variant_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VariantID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostProductsIdVariantsVariantIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostProductsIdVariantsVariantID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostProductsIdVariantsVariantID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostProductsIdVariantsVariantID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostProductsIdVariantsVariantIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPromotions invokes PostPromotions operation.
//
// Create a promotion.
//
// POST /admin/promotions
func (c *Client) PostPromotions(ctx context.Context, request jx.Raw) (PostPromotionsRes, error) {
	res, err := c.sendPostPromotions(ctx, request)
	return res, err
}

func (c *Client) sendPostPromotions(ctx context.Context, request jx.Raw) (res PostPromotionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPromotions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/promotions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPromotions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/promotions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPromotionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPromotions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPromotions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPromotions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPromotionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPromotionsId invokes PostPromotionsId operation.
//
// Update a promotion's details.
//
// POST /admin/promotions/{id}
func (c *Client) PostPromotionsId(ctx context.Context, request OptAdminPostPromotionsPromotionReq, params PostPromotionsIdParams) (PostPromotionsIdRes, error) {
	res, err := c.sendPostPromotionsId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPromotionsId(ctx context.Context, request OptAdminPostPromotionsPromotionReq, params PostPromotionsIdParams) (res PostPromotionsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPromotionsId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/promotions/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPromotionsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/promotions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPromotionsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPromotionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPromotionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPromotionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPromotionsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPromotionsIdBuyRulesBatchAdd invokes PostPromotionsIdBuyRulesBatchAdd operation.
//
// Add a list of adds to a promotion.
//
// POST /admin/promotions/{id}/buy-rules/batch/add
func (c *Client) PostPromotionsIdBuyRulesBatchAdd(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchAddReq, params PostPromotionsIdBuyRulesBatchAddParams) (PostPromotionsIdBuyRulesBatchAddRes, error) {
	res, err := c.sendPostPromotionsIdBuyRulesBatchAdd(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPromotionsIdBuyRulesBatchAdd(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchAddReq, params PostPromotionsIdBuyRulesBatchAddParams) (res PostPromotionsIdBuyRulesBatchAddRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPromotionsIdBuyRulesBatchAdd"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/promotions/{id}/buy-rules/batch/add"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPromotionsIdBuyRulesBatchAdd",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/promotions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/buy-rules/batch/add"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPromotionsIdBuyRulesBatchAddRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPromotionsIdBuyRulesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPromotionsIdBuyRulesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPromotionsIdBuyRulesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPromotionsIdBuyRulesBatchAddResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPromotionsIdBuyRulesBatchRemove invokes PostPromotionsIdBuyRulesBatchRemove operation.
//
// Add a list of removes to a promotion.
//
// POST /admin/promotions/{id}/buy-rules/batch/remove
func (c *Client) PostPromotionsIdBuyRulesBatchRemove(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchRemoveReq, params PostPromotionsIdBuyRulesBatchRemoveParams) (PostPromotionsIdBuyRulesBatchRemoveRes, error) {
	res, err := c.sendPostPromotionsIdBuyRulesBatchRemove(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPromotionsIdBuyRulesBatchRemove(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchRemoveReq, params PostPromotionsIdBuyRulesBatchRemoveParams) (res PostPromotionsIdBuyRulesBatchRemoveRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPromotionsIdBuyRulesBatchRemove"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/promotions/{id}/buy-rules/batch/remove"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPromotionsIdBuyRulesBatchRemove",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/promotions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/buy-rules/batch/remove"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPromotionsIdBuyRulesBatchRemoveRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPromotionsIdBuyRulesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPromotionsIdBuyRulesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPromotionsIdBuyRulesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPromotionsIdBuyRulesBatchRemoveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPromotionsIdRulesBatchAdd invokes PostPromotionsIdRulesBatchAdd operation.
//
// Add a list of adds to a promotion.
//
// POST /admin/promotions/{id}/rules/batch/add
func (c *Client) PostPromotionsIdRulesBatchAdd(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchAddReq, params PostPromotionsIdRulesBatchAddParams) (PostPromotionsIdRulesBatchAddRes, error) {
	res, err := c.sendPostPromotionsIdRulesBatchAdd(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPromotionsIdRulesBatchAdd(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchAddReq, params PostPromotionsIdRulesBatchAddParams) (res PostPromotionsIdRulesBatchAddRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPromotionsIdRulesBatchAdd"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/promotions/{id}/rules/batch/add"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPromotionsIdRulesBatchAdd",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/promotions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rules/batch/add"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPromotionsIdRulesBatchAddRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPromotionsIdRulesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPromotionsIdRulesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPromotionsIdRulesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPromotionsIdRulesBatchAddResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPromotionsIdRulesBatchRemove invokes PostPromotionsIdRulesBatchRemove operation.
//
// Add a list of removes to a promotion.
//
// POST /admin/promotions/{id}/rules/batch/remove
func (c *Client) PostPromotionsIdRulesBatchRemove(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchRemoveReq, params PostPromotionsIdRulesBatchRemoveParams) (PostPromotionsIdRulesBatchRemoveRes, error) {
	res, err := c.sendPostPromotionsIdRulesBatchRemove(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPromotionsIdRulesBatchRemove(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchRemoveReq, params PostPromotionsIdRulesBatchRemoveParams) (res PostPromotionsIdRulesBatchRemoveRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPromotionsIdRulesBatchRemove"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/promotions/{id}/rules/batch/remove"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPromotionsIdRulesBatchRemove",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/promotions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rules/batch/remove"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPromotionsIdRulesBatchRemoveRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPromotionsIdRulesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPromotionsIdRulesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPromotionsIdRulesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPromotionsIdRulesBatchRemoveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPromotionsIdRulesBatchUpdate invokes PostPromotionsIdRulesBatchUpdate operation.
//
// Add a list of updates to a promotion.
//
// POST /admin/promotions/{id}/rules/batch/update
func (c *Client) PostPromotionsIdRulesBatchUpdate(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchUpdateReq, params PostPromotionsIdRulesBatchUpdateParams) (PostPromotionsIdRulesBatchUpdateRes, error) {
	res, err := c.sendPostPromotionsIdRulesBatchUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPromotionsIdRulesBatchUpdate(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchUpdateReq, params PostPromotionsIdRulesBatchUpdateParams) (res PostPromotionsIdRulesBatchUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPromotionsIdRulesBatchUpdate"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/promotions/{id}/rules/batch/update"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPromotionsIdRulesBatchUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/promotions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rules/batch/update"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPromotionsIdRulesBatchUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPromotionsIdRulesBatchUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPromotionsIdRulesBatchUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPromotionsIdRulesBatchUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPromotionsIdRulesBatchUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPromotionsIdTargetRulesBatchAdd invokes PostPromotionsIdTargetRulesBatchAdd operation.
//
// Add a list of adds to a promotion.
//
// POST /admin/promotions/{id}/target-rules/batch/add
func (c *Client) PostPromotionsIdTargetRulesBatchAdd(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchAddReq, params PostPromotionsIdTargetRulesBatchAddParams) (PostPromotionsIdTargetRulesBatchAddRes, error) {
	res, err := c.sendPostPromotionsIdTargetRulesBatchAdd(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPromotionsIdTargetRulesBatchAdd(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchAddReq, params PostPromotionsIdTargetRulesBatchAddParams) (res PostPromotionsIdTargetRulesBatchAddRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPromotionsIdTargetRulesBatchAdd"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/promotions/{id}/target-rules/batch/add"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPromotionsIdTargetRulesBatchAdd",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/promotions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/target-rules/batch/add"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPromotionsIdTargetRulesBatchAddRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPromotionsIdTargetRulesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPromotionsIdTargetRulesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPromotionsIdTargetRulesBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPromotionsIdTargetRulesBatchAddResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPromotionsIdTargetRulesBatchRemove invokes PostPromotionsIdTargetRulesBatchRemove operation.
//
// Add a list of removes to a promotion.
//
// POST /admin/promotions/{id}/target-rules/batch/remove
func (c *Client) PostPromotionsIdTargetRulesBatchRemove(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchRemoveReq, params PostPromotionsIdTargetRulesBatchRemoveParams) (PostPromotionsIdTargetRulesBatchRemoveRes, error) {
	res, err := c.sendPostPromotionsIdTargetRulesBatchRemove(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPromotionsIdTargetRulesBatchRemove(ctx context.Context, request OptAdminPostPromotionsPromotionRulesBatchRemoveReq, params PostPromotionsIdTargetRulesBatchRemoveParams) (res PostPromotionsIdTargetRulesBatchRemoveRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostPromotionsIdTargetRulesBatchRemove"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/promotions/{id}/target-rules/batch/remove"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostPromotionsIdTargetRulesBatchRemove",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/promotions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/target-rules/batch/remove"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPromotionsIdTargetRulesBatchRemoveRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostPromotionsIdTargetRulesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostPromotionsIdTargetRulesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostPromotionsIdTargetRulesBatchRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPromotionsIdTargetRulesBatchRemoveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostRegions invokes PostRegions operation.
//
// Create a region.
//
// POST /admin/regions
func (c *Client) PostRegions(ctx context.Context, request jx.Raw) (PostRegionsRes, error) {
	res, err := c.sendPostRegions(ctx, request)
	return res, err
}

func (c *Client) sendPostRegions(ctx context.Context, request jx.Raw) (res PostRegionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostRegions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/regions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostRegions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/regions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostRegionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostRegionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostRegionsId invokes PostRegionsId operation.
//
// Update a region's details.
//
// POST /admin/regions/{id}
func (c *Client) PostRegionsId(ctx context.Context, request jx.Raw, params PostRegionsIdParams) (PostRegionsIdRes, error) {
	res, err := c.sendPostRegionsId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostRegionsId(ctx context.Context, request jx.Raw, params PostRegionsIdParams) (res PostRegionsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostRegionsId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/regions/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostRegionsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/regions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostRegionsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostRegionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostRegionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostRegionsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostRegionsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostSalesChannels invokes PostSalesChannels operation.
//
// Create a sales channel.
//
// POST /admin/sales-channels
func (c *Client) PostSalesChannels(ctx context.Context, request jx.Raw) (PostSalesChannelsRes, error) {
	res, err := c.sendPostSalesChannels(ctx, request)
	return res, err
}

func (c *Client) sendPostSalesChannels(ctx context.Context, request jx.Raw) (res PostSalesChannelsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostSalesChannels"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/sales-channels"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostSalesChannels",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/sales-channels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostSalesChannelsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostSalesChannels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostSalesChannels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostSalesChannels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostSalesChannelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostSalesChannelsId invokes PostSalesChannelsId operation.
//
// Update a sales channel's details.
//
// POST /admin/sales-channels/{id}
func (c *Client) PostSalesChannelsId(ctx context.Context, request jx.Raw, params PostSalesChannelsIdParams) (PostSalesChannelsIdRes, error) {
	res, err := c.sendPostSalesChannelsId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostSalesChannelsId(ctx context.Context, request jx.Raw, params PostSalesChannelsIdParams) (res PostSalesChannelsIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostSalesChannelsId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/sales-channels/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostSalesChannelsId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/sales-channels/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostSalesChannelsIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostSalesChannelsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostSalesChannelsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostSalesChannelsId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostSalesChannelsIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostSalesChannelsIdProductsBatchAdd invokes PostSalesChannelsIdProductsBatchAdd operation.
//
// Add a list of adds to a sales channel.
//
// POST /admin/sales-channels/{id}/products/batch/add
func (c *Client) PostSalesChannelsIdProductsBatchAdd(ctx context.Context, request jx.Raw, params PostSalesChannelsIdProductsBatchAddParams) (PostSalesChannelsIdProductsBatchAddRes, error) {
	res, err := c.sendPostSalesChannelsIdProductsBatchAdd(ctx, request, params)
	return res, err
}

func (c *Client) sendPostSalesChannelsIdProductsBatchAdd(ctx context.Context, request jx.Raw, params PostSalesChannelsIdProductsBatchAddParams) (res PostSalesChannelsIdProductsBatchAddRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostSalesChannelsIdProductsBatchAdd"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/sales-channels/{id}/products/batch/add"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostSalesChannelsIdProductsBatchAdd",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/sales-channels/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/products/batch/add"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostSalesChannelsIdProductsBatchAddRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostSalesChannelsIdProductsBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostSalesChannelsIdProductsBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostSalesChannelsIdProductsBatchAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostSalesChannelsIdProductsBatchAddResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostStockLocations invokes PostStockLocations operation.
//
// Create a stock location.
//
// POST /admin/stock-locations
func (c *Client) PostStockLocations(ctx context.Context, request OptAdminPostStockLocationsReq) (PostStockLocationsRes, error) {
	res, err := c.sendPostStockLocations(ctx, request)
	return res, err
}

func (c *Client) sendPostStockLocations(ctx context.Context, request OptAdminPostStockLocationsReq) (res PostStockLocationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostStockLocations"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/stock-locations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostStockLocations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/stock-locations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostStockLocationsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostStockLocations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostStockLocations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostStockLocations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostStockLocationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostStoresId invokes PostStoresId operation.
//
// Update a store's details.
//
// POST /admin/stores/{id}
func (c *Client) PostStoresId(ctx context.Context, request jx.Raw, params PostStoresIdParams) (PostStoresIdRes, error) {
	res, err := c.sendPostStoresId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostStoresId(ctx context.Context, request jx.Raw, params PostStoresIdParams) (res PostStoresIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostStoresId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/stores/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostStoresId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/stores/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostStoresIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostStoresId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostStoresId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostStoresId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostStoresIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostTaxRates invokes PostTaxRates operation.
//
// Create a tax rate.
//
// POST /admin/tax-rates
func (c *Client) PostTaxRates(ctx context.Context, request OptAdminPostTaxRatesReq) (PostTaxRatesRes, error) {
	res, err := c.sendPostTaxRates(ctx, request)
	return res, err
}

func (c *Client) sendPostTaxRates(ctx context.Context, request OptAdminPostTaxRatesReq) (res PostTaxRatesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostTaxRates"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/tax-rates"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostTaxRates",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/tax-rates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostTaxRatesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostTaxRates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostTaxRates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostTaxRates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostTaxRatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostTaxRatesId invokes PostTaxRatesId operation.
//
// Update a tax rate's details.
//
// POST /admin/tax-rates/{id}
func (c *Client) PostTaxRatesId(ctx context.Context, request OptAdminPostTaxRatesTaxRateReq, params PostTaxRatesIdParams) (PostTaxRatesIdRes, error) {
	res, err := c.sendPostTaxRatesId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostTaxRatesId(ctx context.Context, request OptAdminPostTaxRatesTaxRateReq, params PostTaxRatesIdParams) (res PostTaxRatesIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostTaxRatesId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/tax-rates/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostTaxRatesId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/tax-rates/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostTaxRatesIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostTaxRatesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostTaxRatesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostTaxRatesId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostTaxRatesIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostTaxRatesIdRules invokes PostTaxRatesIdRules operation.
//
// Add a list of rules to a tax rate.
//
// POST /admin/tax-rates/{id}/rules
func (c *Client) PostTaxRatesIdRules(ctx context.Context, request OptAdminPostTaxRatesTaxRateRulesReq, params PostTaxRatesIdRulesParams) (PostTaxRatesIdRulesRes, error) {
	res, err := c.sendPostTaxRatesIdRules(ctx, request, params)
	return res, err
}

func (c *Client) sendPostTaxRatesIdRules(ctx context.Context, request OptAdminPostTaxRatesTaxRateRulesReq, params PostTaxRatesIdRulesParams) (res PostTaxRatesIdRulesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostTaxRatesIdRules"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/tax-rates/{id}/rules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostTaxRatesIdRules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/tax-rates/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostTaxRatesIdRulesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostTaxRatesIdRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostTaxRatesIdRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostTaxRatesIdRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostTaxRatesIdRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostTaxRegions invokes PostTaxRegions operation.
//
// Create a tax region.
//
// POST /admin/tax-regions
func (c *Client) PostTaxRegions(ctx context.Context, request OptAdminPostTaxRegionsReq) (PostTaxRegionsRes, error) {
	res, err := c.sendPostTaxRegions(ctx, request)
	return res, err
}

func (c *Client) sendPostTaxRegions(ctx context.Context, request OptAdminPostTaxRegionsReq) (res PostTaxRegionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostTaxRegions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/tax-regions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostTaxRegions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/tax-regions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostTaxRegionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostTaxRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostTaxRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostTaxRegions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostTaxRegionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostUsers invokes PostUsers operation.
//
// Create a user.
//
// POST /admin/users
func (c *Client) PostUsers(ctx context.Context, request jx.Raw) (PostUsersRes, error) {
	res, err := c.sendPostUsers(ctx, request)
	return res, err
}

func (c *Client) sendPostUsers(ctx context.Context, request jx.Raw) (res PostUsersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostUsers"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/users"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostUsers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/admin/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostUsers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostUsers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostUsers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostUsersId invokes PostUsersId operation.
//
// Update a user's details.
//
// POST /admin/users/{id}
func (c *Client) PostUsersId(ctx context.Context, request OptAdminUpdateUserRequest, params PostUsersIdParams) (PostUsersIdRes, error) {
	res, err := c.sendPostUsersId(ctx, request, params)
	return res, err
}

func (c *Client) sendPostUsersId(ctx context.Context, request OptAdminUpdateUserRequest, params PostUsersIdParams) (res PostUsersIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostUsersId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/users/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostUsersId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/admin/users/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostUsersIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostUsersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostUsersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostUsersId", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostUsersIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostWorkflowsExecutionsWorkflowIdRun invokes PostWorkflowsExecutionsWorkflow_idRun operation.
//
// Add a list of runs to a workflows execution.
//
// POST /admin/workflows-executions/{workflow_id}/run
func (c *Client) PostWorkflowsExecutionsWorkflowIdRun(ctx context.Context, request OptAdminPostWorkflowsRunReq, params PostWorkflowsExecutionsWorkflowIdRunParams) (PostWorkflowsExecutionsWorkflowIdRunRes, error) {
	res, err := c.sendPostWorkflowsExecutionsWorkflowIdRun(ctx, request, params)
	return res, err
}

func (c *Client) sendPostWorkflowsExecutionsWorkflowIdRun(ctx context.Context, request OptAdminPostWorkflowsRunReq, params PostWorkflowsExecutionsWorkflowIdRunParams) (res PostWorkflowsExecutionsWorkflowIdRunRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostWorkflowsExecutionsWorkflow_idRun"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/workflows-executions/{workflow_id}/run"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostWorkflowsExecutionsWorkflowIdRun",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/workflows-executions/"
	{
		// Encode "workflow_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workflow_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WorkflowID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/run"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostWorkflowsExecutionsWorkflowIdRunRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostWorkflowsExecutionsWorkflowIdRun", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostWorkflowsExecutionsWorkflowIdRun", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostWorkflowsExecutionsWorkflowIdRun", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostWorkflowsExecutionsWorkflowIdRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostWorkflowsExecutionsWorkflowIdStepsFailure invokes PostWorkflowsExecutionsWorkflow_idStepsFailure operation.
//
// Add a list of failures to a workflows execution.
//
// POST /admin/workflows-executions/{workflow_id}/steps/failure
func (c *Client) PostWorkflowsExecutionsWorkflowIdStepsFailure(ctx context.Context, request OptAdminPostWorkflowsAsyncResponseReq, params PostWorkflowsExecutionsWorkflowIdStepsFailureParams) (PostWorkflowsExecutionsWorkflowIdStepsFailureRes, error) {
	res, err := c.sendPostWorkflowsExecutionsWorkflowIdStepsFailure(ctx, request, params)
	return res, err
}

func (c *Client) sendPostWorkflowsExecutionsWorkflowIdStepsFailure(ctx context.Context, request OptAdminPostWorkflowsAsyncResponseReq, params PostWorkflowsExecutionsWorkflowIdStepsFailureParams) (res PostWorkflowsExecutionsWorkflowIdStepsFailureRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostWorkflowsExecutionsWorkflow_idStepsFailure"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/workflows-executions/{workflow_id}/steps/failure"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostWorkflowsExecutionsWorkflowIdStepsFailure",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/workflows-executions/"
	{
		// Encode "workflow_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workflow_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WorkflowID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/steps/failure"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostWorkflowsExecutionsWorkflowIdStepsFailureRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostWorkflowsExecutionsWorkflowIdStepsFailure", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostWorkflowsExecutionsWorkflowIdStepsFailure", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostWorkflowsExecutionsWorkflowIdStepsFailure", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostWorkflowsExecutionsWorkflowIdStepsFailureResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostWorkflowsExecutionsWorkflowIdStepsSuccess invokes PostWorkflowsExecutionsWorkflow_idStepsSuccess operation.
//
// Add a list of successes to a workflows execution.
//
// POST /admin/workflows-executions/{workflow_id}/steps/success
func (c *Client) PostWorkflowsExecutionsWorkflowIdStepsSuccess(ctx context.Context, request OptAdminPostWorkflowsAsyncResponseReq, params PostWorkflowsExecutionsWorkflowIdStepsSuccessParams) (PostWorkflowsExecutionsWorkflowIdStepsSuccessRes, error) {
	res, err := c.sendPostWorkflowsExecutionsWorkflowIdStepsSuccess(ctx, request, params)
	return res, err
}

func (c *Client) sendPostWorkflowsExecutionsWorkflowIdStepsSuccess(ctx context.Context, request OptAdminPostWorkflowsAsyncResponseReq, params PostWorkflowsExecutionsWorkflowIdStepsSuccessParams) (res PostWorkflowsExecutionsWorkflowIdStepsSuccessRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostWorkflowsExecutionsWorkflow_idStepsSuccess"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/admin/workflows-executions/{workflow_id}/steps/success"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostWorkflowsExecutionsWorkflowIdStepsSuccess",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/admin/workflows-executions/"
	{
		// Encode "workflow_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workflow_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WorkflowID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/steps/success"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostWorkflowsExecutionsWorkflowIdStepsSuccessRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIToken"
			switch err := c.securityAPIToken(ctx, "PostWorkflowsExecutionsWorkflowIdStepsSuccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIToken\"")
			}
		}
		{
			stage = "Security:CookieAuth"
			switch err := c.securityCookieAuth(ctx, "PostWorkflowsExecutionsWorkflowIdStepsSuccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}
		{
			stage = "Security:JwtToken"
			switch err := c.securityJwtToken(ctx, "PostWorkflowsExecutionsWorkflowIdStepsSuccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 2
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JwtToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{0b00000100},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostWorkflowsExecutionsWorkflowIdStepsSuccessResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
