// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAdminDeletePricingRuleTypesRuleTypeReq_EncodeDecode(t *testing.T) {
	var typ AdminDeletePricingRuleTypesRuleTypeReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminDeletePricingRuleTypesRuleTypeReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetPricingRuleTypesParams_EncodeDecode(t *testing.T) {
	var typ AdminGetPricingRuleTypesParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetPricingRuleTypesParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetPricingRuleTypesRuleTypeParams_EncodeDecode(t *testing.T) {
	var typ AdminGetPricingRuleTypesRuleTypeParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetPricingRuleTypesRuleTypeParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParams_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItemAndItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItemAndItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItemAndItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItemAndItemAndItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItemAndItemAndItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItemAndItemAndItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItemAndItemID_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItemAndItemID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItemAndItemID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItemAndItemOrItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItemAndItemOrItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItemAndItemOrItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItemAndItemVariants_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItemAndItemVariants
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItemAndItemVariants
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItemID_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItemID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItemID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItemOrItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItemOrItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItemOrItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItemOrItemAndItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItemOrItemAndItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItemOrItemAndItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItemOrItemID_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItemOrItemID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItemOrItemID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItemOrItemOrItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItemOrItemOrItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItemOrItemOrItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItemOrItemVariants_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItemOrItemVariants
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItemOrItemVariants
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsAndItemVariants_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsAndItemVariants
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsAndItemVariants
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsID_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItemAndItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItemAndItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItemAndItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItemAndItemAndItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItemAndItemAndItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItemAndItemAndItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItemAndItemID_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItemAndItemID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItemAndItemID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItemAndItemOrItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItemAndItemOrItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItemAndItemOrItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItemAndItemVariants_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItemAndItemVariants
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItemAndItemVariants
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItemID_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItemID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItemID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItemOrItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItemOrItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItemOrItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItemOrItemAndItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItemOrItemAndItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItemOrItemAndItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItemOrItemID_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItemOrItemID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItemOrItemID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItemOrItemOrItem_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItemOrItemOrItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItemOrItemOrItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItemOrItemVariants_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItemOrItemVariants
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItemOrItemVariants
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsOrItemVariants_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsOrItemVariants
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsOrItemVariants
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetProductsParamsVariants_EncodeDecode(t *testing.T) {
	var typ AdminGetProductsParamsVariants
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetProductsParamsVariants
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminGetPromotionsParams_EncodeDecode(t *testing.T) {
	var typ AdminGetPromotionsParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminGetPromotionsParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostCampaignsReq_EncodeDecode(t *testing.T) {
	var typ AdminPostCampaignsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostCampaignsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostCampaignsReqPromotionsItem_EncodeDecode(t *testing.T) {
	var typ AdminPostCampaignsReqPromotionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostCampaignsReqPromotionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostCustomerGroupsGroupCustomersBatchReq_EncodeDecode(t *testing.T) {
	var typ AdminPostCustomerGroupsGroupCustomersBatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostCustomerGroupsGroupCustomersBatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostCustomerGroupsGroupCustomersBatchReqCustomerIdsItem_EncodeDecode(t *testing.T) {
	var typ AdminPostCustomerGroupsGroupCustomersBatchReqCustomerIdsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostCustomerGroupsGroupCustomersBatchReqCustomerIdsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostFulfillmentShippingOptionsRulesBatchAddReq_EncodeDecode(t *testing.T) {
	var typ AdminPostFulfillmentShippingOptionsRulesBatchAddReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostFulfillmentShippingOptionsRulesBatchAddReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostFulfillmentShippingOptionsRulesBatchAddReqRulesItem_EncodeDecode(t *testing.T) {
	var typ AdminPostFulfillmentShippingOptionsRulesBatchAddReqRulesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostFulfillmentShippingOptionsRulesBatchAddReqRulesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostFulfillmentShippingOptionsRulesBatchAddReqRulesItemValue_EncodeDecode(t *testing.T) {
	var typ AdminPostFulfillmentShippingOptionsRulesBatchAddReqRulesItemValue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostFulfillmentShippingOptionsRulesBatchAddReqRulesItemValue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostFulfillmentShippingOptionsRulesBatchRemoveReq_EncodeDecode(t *testing.T) {
	var typ AdminPostFulfillmentShippingOptionsRulesBatchRemoveReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostFulfillmentShippingOptionsRulesBatchRemoveReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostInventoryItemsInventoryItemReq_EncodeDecode(t *testing.T) {
	var typ AdminPostInventoryItemsInventoryItemReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostInventoryItemsInventoryItemReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostInventoryItemsItemLocationLevelsLevelReq_EncodeDecode(t *testing.T) {
	var typ AdminPostInventoryItemsItemLocationLevelsLevelReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostInventoryItemsItemLocationLevelsLevelReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostInventoryItemsItemLocationLevelsReq_EncodeDecode(t *testing.T) {
	var typ AdminPostInventoryItemsItemLocationLevelsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostInventoryItemsItemLocationLevelsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostInventoryItemsReq_EncodeDecode(t *testing.T) {
	var typ AdminPostInventoryItemsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostInventoryItemsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostInventoryItemsReqMetadata_EncodeDecode(t *testing.T) {
	var typ AdminPostInventoryItemsReqMetadata
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostInventoryItemsReqMetadata
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostInvitesInviteAcceptReq_EncodeDecode(t *testing.T) {
	var typ AdminPostInvitesInviteAcceptReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostInvitesInviteAcceptReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPaymentsCapturesReq_EncodeDecode(t *testing.T) {
	var typ AdminPostPaymentsCapturesReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPaymentsCapturesReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPaymentsRefundsReq_EncodeDecode(t *testing.T) {
	var typ AdminPostPaymentsRefundsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPaymentsRefundsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPriceListsPriceListPricesBatchAddReq_EncodeDecode(t *testing.T) {
	var typ AdminPostPriceListsPriceListPricesBatchAddReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPriceListsPriceListPricesBatchAddReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPriceListsPriceListPricesBatchAddReqPricesItem_EncodeDecode(t *testing.T) {
	var typ AdminPostPriceListsPriceListPricesBatchAddReqPricesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPriceListsPriceListPricesBatchAddReqPricesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPriceListsPriceListPricesBatchAddReqPricesItemRules_EncodeDecode(t *testing.T) {
	var typ AdminPostPriceListsPriceListPricesBatchAddReqPricesItemRules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPriceListsPriceListPricesBatchAddReqPricesItemRules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPriceListsPriceListPricesBatchRemoveReq_EncodeDecode(t *testing.T) {
	var typ AdminPostPriceListsPriceListPricesBatchRemoveReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPriceListsPriceListPricesBatchRemoveReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPriceListsPriceListReq_EncodeDecode(t *testing.T) {
	var typ AdminPostPriceListsPriceListReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPriceListsPriceListReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPriceListsPriceListReqPricesItem_EncodeDecode(t *testing.T) {
	var typ AdminPostPriceListsPriceListReqPricesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPriceListsPriceListReqPricesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPriceListsPriceListReqPricesItemRules_EncodeDecode(t *testing.T) {
	var typ AdminPostPriceListsPriceListReqPricesItemRules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPriceListsPriceListReqPricesItemRules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPriceListsPriceListReqRules_EncodeDecode(t *testing.T) {
	var typ AdminPostPriceListsPriceListReqRules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPriceListsPriceListReqRules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPriceListsReq_EncodeDecode(t *testing.T) {
	var typ AdminPostPriceListsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPriceListsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPriceListsReqPricesItem_EncodeDecode(t *testing.T) {
	var typ AdminPostPriceListsReqPricesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPriceListsReqPricesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPriceListsReqPricesItemRules_EncodeDecode(t *testing.T) {
	var typ AdminPostPriceListsReqPricesItemRules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPriceListsReqPricesItemRules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPriceListsReqRules_EncodeDecode(t *testing.T) {
	var typ AdminPostPriceListsReqRules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPriceListsReqRules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPricingRuleTypesReq_EncodeDecode(t *testing.T) {
	var typ AdminPostPricingRuleTypesReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPricingRuleTypesReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPricingRuleTypesRuleTypeReq_EncodeDecode(t *testing.T) {
	var typ AdminPostPricingRuleTypesRuleTypeReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPricingRuleTypesRuleTypeReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPromotionsPromotionReq_EncodeDecode(t *testing.T) {
	var typ AdminPostPromotionsPromotionReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPromotionsPromotionReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPromotionsPromotionReqRulesItem_EncodeDecode(t *testing.T) {
	var typ AdminPostPromotionsPromotionReqRulesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPromotionsPromotionReqRulesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPromotionsPromotionRulesBatchAddReq_EncodeDecode(t *testing.T) {
	var typ AdminPostPromotionsPromotionRulesBatchAddReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPromotionsPromotionRulesBatchAddReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPromotionsPromotionRulesBatchAddReqRulesItem_EncodeDecode(t *testing.T) {
	var typ AdminPostPromotionsPromotionRulesBatchAddReqRulesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPromotionsPromotionRulesBatchAddReqRulesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPromotionsPromotionRulesBatchRemoveReq_EncodeDecode(t *testing.T) {
	var typ AdminPostPromotionsPromotionRulesBatchRemoveReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPromotionsPromotionRulesBatchRemoveReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPromotionsPromotionRulesBatchUpdateReq_EncodeDecode(t *testing.T) {
	var typ AdminPostPromotionsPromotionRulesBatchUpdateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPromotionsPromotionRulesBatchUpdateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostPromotionsPromotionRulesBatchUpdateReqRulesItem_EncodeDecode(t *testing.T) {
	var typ AdminPostPromotionsPromotionRulesBatchUpdateReqRulesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostPromotionsPromotionRulesBatchUpdateReqRulesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostStockLocationsReq_EncodeDecode(t *testing.T) {
	var typ AdminPostStockLocationsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostStockLocationsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostStockLocationsReqMetadata_EncodeDecode(t *testing.T) {
	var typ AdminPostStockLocationsReqMetadata
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostStockLocationsReqMetadata
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostTaxRatesReq_EncodeDecode(t *testing.T) {
	var typ AdminPostTaxRatesReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostTaxRatesReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostTaxRatesReqMetadata_EncodeDecode(t *testing.T) {
	var typ AdminPostTaxRatesReqMetadata
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostTaxRatesReqMetadata
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostTaxRatesReqRulesItem_EncodeDecode(t *testing.T) {
	var typ AdminPostTaxRatesReqRulesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostTaxRatesReqRulesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostTaxRatesTaxRateReq_EncodeDecode(t *testing.T) {
	var typ AdminPostTaxRatesTaxRateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostTaxRatesTaxRateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostTaxRatesTaxRateRulesReq_EncodeDecode(t *testing.T) {
	var typ AdminPostTaxRatesTaxRateRulesReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostTaxRatesTaxRateRulesReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostTaxRegionsReq_EncodeDecode(t *testing.T) {
	var typ AdminPostTaxRegionsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostTaxRegionsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostTaxRegionsReqMetadata_EncodeDecode(t *testing.T) {
	var typ AdminPostTaxRegionsReqMetadata
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostTaxRegionsReqMetadata
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostWorkflowsAsyncResponseReq_EncodeDecode(t *testing.T) {
	var typ AdminPostWorkflowsAsyncResponseReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostWorkflowsAsyncResponseReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminPostWorkflowsRunReq_EncodeDecode(t *testing.T) {
	var typ AdminPostWorkflowsRunReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminPostWorkflowsRunReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminUpdateUserRequest_EncodeDecode(t *testing.T) {
	var typ AdminUpdateUserRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminUpdateUserRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestApplicationMethodsMethodPostReq_EncodeDecode(t *testing.T) {
	var typ ApplicationMethodsMethodPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ApplicationMethodsMethodPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestApplicationMethodsMethodPostReqBuyRulesItem_EncodeDecode(t *testing.T) {
	var typ ApplicationMethodsMethodPostReqBuyRulesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ApplicationMethodsMethodPostReqBuyRulesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestApplicationMethodsMethodPostReqTargetRulesItem_EncodeDecode(t *testing.T) {
	var typ ApplicationMethodsMethodPostReqTargetRulesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ApplicationMethodsMethodPostReqTargetRulesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCampaignBudget_EncodeDecode(t *testing.T) {
	var typ CampaignBudget
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CampaignBudget
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateDefaultTaxRate_EncodeDecode(t *testing.T) {
	var typ CreateDefaultTaxRate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateDefaultTaxRate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateDefaultTaxRateMetadata_EncodeDecode(t *testing.T) {
	var typ CreateDefaultTaxRateMetadata
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateDefaultTaxRateMetadata
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteApiKeysIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteApiKeysIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteApiKeysIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteApiKeysIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteApiKeysIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteApiKeysIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteApiKeysIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteApiKeysIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteApiKeysIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteApiKeysIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteApiKeysIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteApiKeysIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCampaignsIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteCampaignsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCampaignsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCampaignsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteCampaignsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCampaignsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCampaignsIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteCampaignsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCampaignsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCampaignsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteCampaignsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCampaignsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCollectionsIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteCollectionsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCollectionsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCollectionsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteCollectionsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCollectionsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCollectionsIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteCollectionsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCollectionsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCollectionsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteCollectionsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCollectionsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCustomerGroupsIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteCustomerGroupsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCustomerGroupsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCustomerGroupsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteCustomerGroupsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCustomerGroupsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCustomerGroupsIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteCustomerGroupsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCustomerGroupsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCustomerGroupsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteCustomerGroupsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCustomerGroupsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCustomersIdAddressesAddressIDConflict_EncodeDecode(t *testing.T) {
	var typ DeleteCustomersIdAddressesAddressIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCustomersIdAddressesAddressIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCustomersIdAddressesAddressIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteCustomersIdAddressesAddressIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCustomersIdAddressesAddressIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCustomersIdAddressesAddressIDNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteCustomersIdAddressesAddressIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCustomersIdAddressesAddressIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCustomersIdAddressesAddressIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteCustomersIdAddressesAddressIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCustomersIdAddressesAddressIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCustomersIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteCustomersIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCustomersIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCustomersIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteCustomersIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCustomersIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCustomersIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteCustomersIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCustomersIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCustomersIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteCustomersIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCustomersIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteInventoryItemsIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteInventoryItemsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteInventoryItemsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteInventoryItemsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteInventoryItemsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteInventoryItemsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteInventoryItemsIdLocationLevelsLocationIDConflict_EncodeDecode(t *testing.T) {
	var typ DeleteInventoryItemsIdLocationLevelsLocationIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteInventoryItemsIdLocationLevelsLocationIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteInventoryItemsIdLocationLevelsLocationIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteInventoryItemsIdLocationLevelsLocationIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteInventoryItemsIdLocationLevelsLocationIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteInventoryItemsIdLocationLevelsLocationIDNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteInventoryItemsIdLocationLevelsLocationIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteInventoryItemsIdLocationLevelsLocationIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteInventoryItemsIdLocationLevelsLocationIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteInventoryItemsIdLocationLevelsLocationIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteInventoryItemsIdLocationLevelsLocationIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteInventoryItemsIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteInventoryItemsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteInventoryItemsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteInventoryItemsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteInventoryItemsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteInventoryItemsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteInvitesIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteInvitesIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteInvitesIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteInvitesIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteInvitesIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteInvitesIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteInvitesIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteInvitesIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteInvitesIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteInvitesIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteInvitesIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteInvitesIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePriceListsIdConflict_EncodeDecode(t *testing.T) {
	var typ DeletePriceListsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePriceListsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePriceListsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeletePriceListsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePriceListsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePriceListsIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeletePriceListsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePriceListsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePriceListsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeletePriceListsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePriceListsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePricingRuleTypesIdConflict_EncodeDecode(t *testing.T) {
	var typ DeletePricingRuleTypesIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePricingRuleTypesIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePricingRuleTypesIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeletePricingRuleTypesIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePricingRuleTypesIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePricingRuleTypesIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeletePricingRuleTypesIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePricingRuleTypesIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePricingRuleTypesIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeletePricingRuleTypesIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePricingRuleTypesIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteProductsIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteProductsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteProductsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteProductsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteProductsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteProductsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteProductsIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteProductsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteProductsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteProductsIdOptionsOptionIDConflict_EncodeDecode(t *testing.T) {
	var typ DeleteProductsIdOptionsOptionIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteProductsIdOptionsOptionIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteProductsIdOptionsOptionIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteProductsIdOptionsOptionIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteProductsIdOptionsOptionIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteProductsIdOptionsOptionIDNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteProductsIdOptionsOptionIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteProductsIdOptionsOptionIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteProductsIdOptionsOptionIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteProductsIdOptionsOptionIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteProductsIdOptionsOptionIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteProductsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteProductsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteProductsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteProductsIdVariantsVariantIDConflict_EncodeDecode(t *testing.T) {
	var typ DeleteProductsIdVariantsVariantIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteProductsIdVariantsVariantIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteProductsIdVariantsVariantIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteProductsIdVariantsVariantIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteProductsIdVariantsVariantIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteProductsIdVariantsVariantIDNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteProductsIdVariantsVariantIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteProductsIdVariantsVariantIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteProductsIdVariantsVariantIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteProductsIdVariantsVariantIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteProductsIdVariantsVariantIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePromotionsIdConflict_EncodeDecode(t *testing.T) {
	var typ DeletePromotionsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePromotionsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePromotionsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeletePromotionsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePromotionsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePromotionsIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeletePromotionsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePromotionsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePromotionsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeletePromotionsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePromotionsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteRegionsIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteRegionsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteRegionsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteRegionsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteRegionsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteRegionsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteRegionsIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteRegionsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteRegionsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteRegionsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteRegionsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteRegionsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteSalesChannelsIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteSalesChannelsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSalesChannelsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteSalesChannelsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteSalesChannelsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSalesChannelsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteSalesChannelsIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteSalesChannelsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSalesChannelsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteSalesChannelsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteSalesChannelsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSalesChannelsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteStockLocationsIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteStockLocationsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteStockLocationsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteStockLocationsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteStockLocationsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteStockLocationsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteStockLocationsIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteStockLocationsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteStockLocationsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteStockLocationsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteStockLocationsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteStockLocationsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTaxRatesIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteTaxRatesIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTaxRatesIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTaxRatesIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteTaxRatesIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTaxRatesIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTaxRatesIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteTaxRatesIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTaxRatesIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTaxRatesIdRulesRuleIDConflict_EncodeDecode(t *testing.T) {
	var typ DeleteTaxRatesIdRulesRuleIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTaxRatesIdRulesRuleIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTaxRatesIdRulesRuleIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteTaxRatesIdRulesRuleIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTaxRatesIdRulesRuleIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTaxRatesIdRulesRuleIDNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteTaxRatesIdRulesRuleIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTaxRatesIdRulesRuleIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTaxRatesIdRulesRuleIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteTaxRatesIdRulesRuleIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTaxRatesIdRulesRuleIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTaxRatesIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteTaxRatesIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTaxRatesIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTaxRegionsIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteTaxRegionsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTaxRegionsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTaxRegionsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteTaxRegionsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTaxRegionsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTaxRegionsIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteTaxRegionsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTaxRegionsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTaxRegionsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteTaxRegionsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTaxRegionsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteUsersIdConflict_EncodeDecode(t *testing.T) {
	var typ DeleteUsersIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteUsersIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteUsersIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteUsersIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteUsersIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteUsersIdNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteUsersIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteUsersIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteUsersIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteUsersIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteUsersIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"code\":\"api_error\",\"message\":\"An error occured while hashing password\",\"type\":\"database_error\"}"},
		{Input: "{\"code\":\"invalid_request_error\",\"message\":\"Discount with code TEST already exists.\",\"type\":\"duplicate_error\"}"},
		{Input: "{\"code\":\"unknown_error\",\"message\":\"An unknown error occurred.\",\"type\":\"unknown_error\"}"},
		{Input: "{\"code\":\"unknown_error\",\"message\":\"The request conflicted with another request. You may retry the request with the provided Idempotency-Key.\",\"type\":\"QueryRunnerAlreadyReleasedError\"}"},
		{Input: "{\"message\":\"Entity with id 1 was not found\",\"type\":\"not_found\"}"},
		{Input: "{\"message\":\"cart.total must be defined\",\"type\":\"unexpected_state\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Error

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Error
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestErrorCode_EncodeDecode(t *testing.T) {
	var typ ErrorCode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorCode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorType_EncodeDecode(t *testing.T) {
	var typ ErrorType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetApiKeysConflict_EncodeDecode(t *testing.T) {
	var typ GetApiKeysConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetApiKeysConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetApiKeysIdConflict_EncodeDecode(t *testing.T) {
	var typ GetApiKeysIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetApiKeysIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetApiKeysIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetApiKeysIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetApiKeysIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetApiKeysIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetApiKeysIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetApiKeysIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetApiKeysIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetApiKeysIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetApiKeysIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetApiKeysInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetApiKeysInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetApiKeysInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetApiKeysNotFound_EncodeDecode(t *testing.T) {
	var typ GetApiKeysNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetApiKeysNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetApiKeysUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetApiKeysUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetApiKeysUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCampaignsConflict_EncodeDecode(t *testing.T) {
	var typ GetCampaignsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCampaignsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCampaignsIdConflict_EncodeDecode(t *testing.T) {
	var typ GetCampaignsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCampaignsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCampaignsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCampaignsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCampaignsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCampaignsIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetCampaignsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCampaignsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCampaignsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCampaignsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCampaignsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCampaignsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCampaignsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCampaignsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCampaignsNotFound_EncodeDecode(t *testing.T) {
	var typ GetCampaignsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCampaignsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCampaignsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCampaignsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCampaignsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCollectionsConflict_EncodeDecode(t *testing.T) {
	var typ GetCollectionsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCollectionsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCollectionsIdConflict_EncodeDecode(t *testing.T) {
	var typ GetCollectionsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCollectionsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCollectionsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCollectionsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCollectionsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCollectionsIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetCollectionsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCollectionsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCollectionsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCollectionsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCollectionsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCollectionsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCollectionsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCollectionsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCollectionsNotFound_EncodeDecode(t *testing.T) {
	var typ GetCollectionsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCollectionsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCollectionsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCollectionsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCollectionsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCurrenciesCodeConflict_EncodeDecode(t *testing.T) {
	var typ GetCurrenciesCodeConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCurrenciesCodeConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCurrenciesCodeInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCurrenciesCodeInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCurrenciesCodeInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCurrenciesCodeNotFound_EncodeDecode(t *testing.T) {
	var typ GetCurrenciesCodeNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCurrenciesCodeNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCurrenciesCodeUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCurrenciesCodeUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCurrenciesCodeUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCurrenciesConflict_EncodeDecode(t *testing.T) {
	var typ GetCurrenciesConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCurrenciesConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCurrenciesInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCurrenciesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCurrenciesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCurrenciesNotFound_EncodeDecode(t *testing.T) {
	var typ GetCurrenciesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCurrenciesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCurrenciesUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCurrenciesUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCurrenciesUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomerGroupsConflict_EncodeDecode(t *testing.T) {
	var typ GetCustomerGroupsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomerGroupsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomerGroupsIdConflict_EncodeDecode(t *testing.T) {
	var typ GetCustomerGroupsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomerGroupsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomerGroupsIdCustomersConflict_EncodeDecode(t *testing.T) {
	var typ GetCustomerGroupsIdCustomersConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomerGroupsIdCustomersConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomerGroupsIdCustomersInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCustomerGroupsIdCustomersInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomerGroupsIdCustomersInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomerGroupsIdCustomersNotFound_EncodeDecode(t *testing.T) {
	var typ GetCustomerGroupsIdCustomersNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomerGroupsIdCustomersNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomerGroupsIdCustomersUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCustomerGroupsIdCustomersUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomerGroupsIdCustomersUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomerGroupsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCustomerGroupsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomerGroupsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomerGroupsIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetCustomerGroupsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomerGroupsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomerGroupsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCustomerGroupsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomerGroupsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomerGroupsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCustomerGroupsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomerGroupsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomerGroupsNotFound_EncodeDecode(t *testing.T) {
	var typ GetCustomerGroupsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomerGroupsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomerGroupsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCustomerGroupsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomerGroupsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersConflict_EncodeDecode(t *testing.T) {
	var typ GetCustomersConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersIdAddressesAddressIDConflict_EncodeDecode(t *testing.T) {
	var typ GetCustomersIdAddressesAddressIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersIdAddressesAddressIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersIdAddressesAddressIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCustomersIdAddressesAddressIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersIdAddressesAddressIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersIdAddressesAddressIDNotFound_EncodeDecode(t *testing.T) {
	var typ GetCustomersIdAddressesAddressIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersIdAddressesAddressIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersIdAddressesAddressIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCustomersIdAddressesAddressIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersIdAddressesAddressIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersIdAddressesConflict_EncodeDecode(t *testing.T) {
	var typ GetCustomersIdAddressesConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersIdAddressesConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersIdAddressesInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCustomersIdAddressesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersIdAddressesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersIdAddressesNotFound_EncodeDecode(t *testing.T) {
	var typ GetCustomersIdAddressesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersIdAddressesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersIdAddressesUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCustomersIdAddressesUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersIdAddressesUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersIdConflict_EncodeDecode(t *testing.T) {
	var typ GetCustomersIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCustomersIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetCustomersIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCustomersIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCustomersInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersNotFound_EncodeDecode(t *testing.T) {
	var typ GetCustomersNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCustomersUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetCustomersUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCustomersUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInventoryItemsConflict_EncodeDecode(t *testing.T) {
	var typ GetInventoryItemsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInventoryItemsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInventoryItemsIdConflict_EncodeDecode(t *testing.T) {
	var typ GetInventoryItemsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInventoryItemsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInventoryItemsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetInventoryItemsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInventoryItemsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInventoryItemsIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetInventoryItemsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInventoryItemsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInventoryItemsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetInventoryItemsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInventoryItemsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInventoryItemsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetInventoryItemsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInventoryItemsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInventoryItemsNotFound_EncodeDecode(t *testing.T) {
	var typ GetInventoryItemsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInventoryItemsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInventoryItemsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetInventoryItemsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInventoryItemsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInvitesConflict_EncodeDecode(t *testing.T) {
	var typ GetInvitesConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInvitesConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInvitesIdConflict_EncodeDecode(t *testing.T) {
	var typ GetInvitesIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInvitesIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInvitesIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetInvitesIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInvitesIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInvitesIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetInvitesIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInvitesIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInvitesIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetInvitesIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInvitesIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInvitesInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetInvitesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInvitesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInvitesNotFound_EncodeDecode(t *testing.T) {
	var typ GetInvitesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInvitesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInvitesUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetInvitesUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInvitesUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPaymentsConflict_EncodeDecode(t *testing.T) {
	var typ GetPaymentsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPaymentsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPaymentsIdConflict_EncodeDecode(t *testing.T) {
	var typ GetPaymentsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPaymentsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPaymentsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetPaymentsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPaymentsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPaymentsIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetPaymentsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPaymentsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPaymentsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetPaymentsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPaymentsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPaymentsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetPaymentsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPaymentsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPaymentsNotFound_EncodeDecode(t *testing.T) {
	var typ GetPaymentsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPaymentsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPaymentsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetPaymentsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPaymentsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPriceListsConflict_EncodeDecode(t *testing.T) {
	var typ GetPriceListsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPriceListsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPriceListsIdConflict_EncodeDecode(t *testing.T) {
	var typ GetPriceListsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPriceListsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPriceListsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetPriceListsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPriceListsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPriceListsIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetPriceListsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPriceListsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPriceListsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetPriceListsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPriceListsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPriceListsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetPriceListsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPriceListsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPriceListsNotFound_EncodeDecode(t *testing.T) {
	var typ GetPriceListsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPriceListsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPriceListsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetPriceListsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPriceListsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPricingRuleTypesConflict_EncodeDecode(t *testing.T) {
	var typ GetPricingRuleTypesConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPricingRuleTypesConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPricingRuleTypesIdConflict_EncodeDecode(t *testing.T) {
	var typ GetPricingRuleTypesIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPricingRuleTypesIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPricingRuleTypesIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetPricingRuleTypesIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPricingRuleTypesIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPricingRuleTypesIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetPricingRuleTypesIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPricingRuleTypesIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPricingRuleTypesIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetPricingRuleTypesIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPricingRuleTypesIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPricingRuleTypesInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetPricingRuleTypesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPricingRuleTypesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPricingRuleTypesNotFound_EncodeDecode(t *testing.T) {
	var typ GetPricingRuleTypesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPricingRuleTypesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPricingRuleTypesUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetPricingRuleTypesUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPricingRuleTypesUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsConflict_EncodeDecode(t *testing.T) {
	var typ GetProductsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdConflict_EncodeDecode(t *testing.T) {
	var typ GetProductsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetProductsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetProductsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdOptionsConflict_EncodeDecode(t *testing.T) {
	var typ GetProductsIdOptionsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdOptionsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdOptionsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetProductsIdOptionsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdOptionsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdOptionsNotFound_EncodeDecode(t *testing.T) {
	var typ GetProductsIdOptionsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdOptionsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdOptionsOptionIDConflict_EncodeDecode(t *testing.T) {
	var typ GetProductsIdOptionsOptionIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdOptionsOptionIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdOptionsOptionIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetProductsIdOptionsOptionIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdOptionsOptionIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdOptionsOptionIDNotFound_EncodeDecode(t *testing.T) {
	var typ GetProductsIdOptionsOptionIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdOptionsOptionIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdOptionsOptionIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetProductsIdOptionsOptionIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdOptionsOptionIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdOptionsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetProductsIdOptionsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdOptionsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetProductsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdVariantsConflict_EncodeDecode(t *testing.T) {
	var typ GetProductsIdVariantsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdVariantsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdVariantsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetProductsIdVariantsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdVariantsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdVariantsNotFound_EncodeDecode(t *testing.T) {
	var typ GetProductsIdVariantsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdVariantsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdVariantsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetProductsIdVariantsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdVariantsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdVariantsVariantIDConflict_EncodeDecode(t *testing.T) {
	var typ GetProductsIdVariantsVariantIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdVariantsVariantIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdVariantsVariantIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetProductsIdVariantsVariantIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdVariantsVariantIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdVariantsVariantIDNotFound_EncodeDecode(t *testing.T) {
	var typ GetProductsIdVariantsVariantIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdVariantsVariantIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsIdVariantsVariantIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetProductsIdVariantsVariantIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsIdVariantsVariantIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetProductsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsNotFound_EncodeDecode(t *testing.T) {
	var typ GetProductsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetProductsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetProductsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetProductsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPromotionsConflict_EncodeDecode(t *testing.T) {
	var typ GetPromotionsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPromotionsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPromotionsIdConflict_EncodeDecode(t *testing.T) {
	var typ GetPromotionsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPromotionsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPromotionsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetPromotionsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPromotionsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPromotionsIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetPromotionsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPromotionsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPromotionsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetPromotionsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPromotionsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPromotionsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetPromotionsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPromotionsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPromotionsNotFound_EncodeDecode(t *testing.T) {
	var typ GetPromotionsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPromotionsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPromotionsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetPromotionsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPromotionsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRegionsConflict_EncodeDecode(t *testing.T) {
	var typ GetRegionsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRegionsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRegionsIdConflict_EncodeDecode(t *testing.T) {
	var typ GetRegionsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRegionsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRegionsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetRegionsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRegionsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRegionsIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetRegionsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRegionsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRegionsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetRegionsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRegionsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRegionsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetRegionsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRegionsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRegionsNotFound_EncodeDecode(t *testing.T) {
	var typ GetRegionsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRegionsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRegionsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetRegionsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRegionsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSalesChannelsConflict_EncodeDecode(t *testing.T) {
	var typ GetSalesChannelsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSalesChannelsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSalesChannelsIdConflict_EncodeDecode(t *testing.T) {
	var typ GetSalesChannelsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSalesChannelsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSalesChannelsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetSalesChannelsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSalesChannelsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSalesChannelsIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetSalesChannelsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSalesChannelsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSalesChannelsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetSalesChannelsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSalesChannelsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSalesChannelsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetSalesChannelsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSalesChannelsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSalesChannelsNotFound_EncodeDecode(t *testing.T) {
	var typ GetSalesChannelsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSalesChannelsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSalesChannelsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetSalesChannelsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSalesChannelsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStockLocationsIdConflict_EncodeDecode(t *testing.T) {
	var typ GetStockLocationsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStockLocationsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStockLocationsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetStockLocationsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStockLocationsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStockLocationsIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetStockLocationsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStockLocationsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStockLocationsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetStockLocationsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStockLocationsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStoresConflict_EncodeDecode(t *testing.T) {
	var typ GetStoresConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStoresConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStoresIdConflict_EncodeDecode(t *testing.T) {
	var typ GetStoresIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStoresIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStoresIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetStoresIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStoresIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStoresIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetStoresIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStoresIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStoresIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetStoresIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStoresIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStoresInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetStoresInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStoresInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStoresNotFound_EncodeDecode(t *testing.T) {
	var typ GetStoresNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStoresNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStoresUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetStoresUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStoresUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTaxRatesConflict_EncodeDecode(t *testing.T) {
	var typ GetTaxRatesConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTaxRatesConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTaxRatesIdConflict_EncodeDecode(t *testing.T) {
	var typ GetTaxRatesIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTaxRatesIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTaxRatesIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetTaxRatesIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTaxRatesIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTaxRatesIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetTaxRatesIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTaxRatesIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTaxRatesIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetTaxRatesIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTaxRatesIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTaxRatesInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetTaxRatesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTaxRatesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTaxRatesNotFound_EncodeDecode(t *testing.T) {
	var typ GetTaxRatesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTaxRatesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTaxRatesUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetTaxRatesUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTaxRatesUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersConflict_EncodeDecode(t *testing.T) {
	var typ GetUsersConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersIdConflict_EncodeDecode(t *testing.T) {
	var typ GetUsersIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetUsersIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetUsersIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetUsersIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetUsersInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersMeConflict_EncodeDecode(t *testing.T) {
	var typ GetUsersMeConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersMeConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersMeInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetUsersMeInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersMeInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersMeNotFound_EncodeDecode(t *testing.T) {
	var typ GetUsersMeNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersMeNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersMeUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetUsersMeUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersMeUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersNotFound_EncodeDecode(t *testing.T) {
	var typ GetUsersNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetUsersUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsConflict_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsIdConflict_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsNotFound_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsWorkflowIdSubscribeConflict_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsWorkflowIdSubscribeConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsWorkflowIdSubscribeConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsWorkflowIdSubscribeInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsWorkflowIdSubscribeInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsWorkflowIdSubscribeInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsWorkflowIdSubscribeNotFound_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsWorkflowIdSubscribeNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsWorkflowIdSubscribeNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsWorkflowIdSubscribeUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsWorkflowIdSubscribeUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsWorkflowIdSubscribeUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsWorkflowIdTransactionIDConflict_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsWorkflowIdTransactionIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsWorkflowIdTransactionIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsWorkflowIdTransactionIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsWorkflowIdTransactionIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsWorkflowIdTransactionIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsWorkflowIdTransactionIDNotFound_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsWorkflowIdTransactionIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsWorkflowIdTransactionIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsWorkflowIdTransactionIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsWorkflowIdTransactionIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsWorkflowIdTransactionIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeConflict_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeNotFound_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMultipleErrors_EncodeDecode(t *testing.T) {
	var typ MultipleErrors
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MultipleErrors
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostApiKeysConflict_EncodeDecode(t *testing.T) {
	var typ PostApiKeysConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostApiKeysConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostApiKeysIdConflict_EncodeDecode(t *testing.T) {
	var typ PostApiKeysIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostApiKeysIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostApiKeysIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostApiKeysIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostApiKeysIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostApiKeysIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostApiKeysIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostApiKeysIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostApiKeysIdRevokeConflict_EncodeDecode(t *testing.T) {
	var typ PostApiKeysIdRevokeConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostApiKeysIdRevokeConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostApiKeysIdRevokeInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostApiKeysIdRevokeInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostApiKeysIdRevokeInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostApiKeysIdRevokeNotFound_EncodeDecode(t *testing.T) {
	var typ PostApiKeysIdRevokeNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostApiKeysIdRevokeNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostApiKeysIdRevokeUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostApiKeysIdRevokeUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostApiKeysIdRevokeUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostApiKeysIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostApiKeysIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostApiKeysIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostApiKeysInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostApiKeysInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostApiKeysInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostApiKeysNotFound_EncodeDecode(t *testing.T) {
	var typ PostApiKeysNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostApiKeysNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostApiKeysUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostApiKeysUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostApiKeysUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCampaignsConflict_EncodeDecode(t *testing.T) {
	var typ PostCampaignsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCampaignsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCampaignsIdConflict_EncodeDecode(t *testing.T) {
	var typ PostCampaignsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCampaignsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCampaignsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostCampaignsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCampaignsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCampaignsIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostCampaignsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCampaignsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCampaignsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostCampaignsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCampaignsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCampaignsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostCampaignsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCampaignsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCampaignsNotFound_EncodeDecode(t *testing.T) {
	var typ PostCampaignsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCampaignsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCampaignsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostCampaignsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCampaignsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCollectionsConflict_EncodeDecode(t *testing.T) {
	var typ PostCollectionsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCollectionsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCollectionsIdConflict_EncodeDecode(t *testing.T) {
	var typ PostCollectionsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCollectionsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCollectionsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostCollectionsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCollectionsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCollectionsIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostCollectionsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCollectionsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCollectionsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostCollectionsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCollectionsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCollectionsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostCollectionsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCollectionsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCollectionsNotFound_EncodeDecode(t *testing.T) {
	var typ PostCollectionsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCollectionsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCollectionsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostCollectionsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCollectionsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsConflict_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsIdConflict_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsIdCustomersBatchConflict_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsIdCustomersBatchConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsIdCustomersBatchConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsIdCustomersBatchInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsIdCustomersBatchInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsIdCustomersBatchInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsIdCustomersBatchNotFound_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsIdCustomersBatchNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsIdCustomersBatchNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsIdCustomersBatchUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsIdCustomersBatchUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsIdCustomersBatchUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsIdCustomersRemoveConflict_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsIdCustomersRemoveConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsIdCustomersRemoveConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsIdCustomersRemoveInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsIdCustomersRemoveInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsIdCustomersRemoveInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsIdCustomersRemoveNotFound_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsIdCustomersRemoveNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsIdCustomersRemoveNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsIdCustomersRemoveUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsIdCustomersRemoveUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsIdCustomersRemoveUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsNotFound_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomerGroupsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostCustomerGroupsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomerGroupsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersConflict_EncodeDecode(t *testing.T) {
	var typ PostCustomersConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersIdAddressesAddressIDConflict_EncodeDecode(t *testing.T) {
	var typ PostCustomersIdAddressesAddressIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersIdAddressesAddressIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersIdAddressesAddressIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostCustomersIdAddressesAddressIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersIdAddressesAddressIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersIdAddressesAddressIDNotFound_EncodeDecode(t *testing.T) {
	var typ PostCustomersIdAddressesAddressIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersIdAddressesAddressIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersIdAddressesAddressIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostCustomersIdAddressesAddressIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersIdAddressesAddressIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersIdAddressesConflict_EncodeDecode(t *testing.T) {
	var typ PostCustomersIdAddressesConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersIdAddressesConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersIdAddressesInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostCustomersIdAddressesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersIdAddressesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersIdAddressesNotFound_EncodeDecode(t *testing.T) {
	var typ PostCustomersIdAddressesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersIdAddressesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersIdAddressesUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostCustomersIdAddressesUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersIdAddressesUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersIdConflict_EncodeDecode(t *testing.T) {
	var typ PostCustomersIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostCustomersIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostCustomersIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostCustomersIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostCustomersInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersNotFound_EncodeDecode(t *testing.T) {
	var typ PostCustomersNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostCustomersUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostCustomersUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostCustomersUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostFulfillmentShippingOptionsIdRulesBatchAddConflict_EncodeDecode(t *testing.T) {
	var typ PostFulfillmentShippingOptionsIdRulesBatchAddConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostFulfillmentShippingOptionsIdRulesBatchAddConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostFulfillmentShippingOptionsIdRulesBatchAddInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostFulfillmentShippingOptionsIdRulesBatchAddInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostFulfillmentShippingOptionsIdRulesBatchAddInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostFulfillmentShippingOptionsIdRulesBatchAddNotFound_EncodeDecode(t *testing.T) {
	var typ PostFulfillmentShippingOptionsIdRulesBatchAddNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostFulfillmentShippingOptionsIdRulesBatchAddNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostFulfillmentShippingOptionsIdRulesBatchAddUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostFulfillmentShippingOptionsIdRulesBatchAddUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostFulfillmentShippingOptionsIdRulesBatchAddUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostFulfillmentShippingOptionsIdRulesBatchRemoveConflict_EncodeDecode(t *testing.T) {
	var typ PostFulfillmentShippingOptionsIdRulesBatchRemoveConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostFulfillmentShippingOptionsIdRulesBatchRemoveConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostFulfillmentShippingOptionsIdRulesBatchRemoveInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostFulfillmentShippingOptionsIdRulesBatchRemoveInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostFulfillmentShippingOptionsIdRulesBatchRemoveInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostFulfillmentShippingOptionsIdRulesBatchRemoveNotFound_EncodeDecode(t *testing.T) {
	var typ PostFulfillmentShippingOptionsIdRulesBatchRemoveNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostFulfillmentShippingOptionsIdRulesBatchRemoveNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostFulfillmentShippingOptionsIdRulesBatchRemoveUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostFulfillmentShippingOptionsIdRulesBatchRemoveUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostFulfillmentShippingOptionsIdRulesBatchRemoveUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsConflict_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsIdConflict_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsIdLocationLevelsConflict_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsIdLocationLevelsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsIdLocationLevelsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsIdLocationLevelsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsIdLocationLevelsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsIdLocationLevelsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsIdLocationLevelsLocationIDConflict_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsIdLocationLevelsLocationIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsIdLocationLevelsLocationIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsIdLocationLevelsLocationIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsIdLocationLevelsLocationIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsIdLocationLevelsLocationIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsIdLocationLevelsLocationIDNotFound_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsIdLocationLevelsLocationIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsIdLocationLevelsLocationIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsIdLocationLevelsLocationIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsIdLocationLevelsLocationIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsIdLocationLevelsLocationIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsIdLocationLevelsNotFound_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsIdLocationLevelsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsIdLocationLevelsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsIdLocationLevelsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsIdLocationLevelsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsIdLocationLevelsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsNotFound_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInventoryItemsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostInventoryItemsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInventoryItemsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInvitesAcceptConflict_EncodeDecode(t *testing.T) {
	var typ PostInvitesAcceptConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInvitesAcceptConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInvitesAcceptInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostInvitesAcceptInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInvitesAcceptInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInvitesAcceptNotFound_EncodeDecode(t *testing.T) {
	var typ PostInvitesAcceptNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInvitesAcceptNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInvitesAcceptUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostInvitesAcceptUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInvitesAcceptUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInvitesConflict_EncodeDecode(t *testing.T) {
	var typ PostInvitesConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInvitesConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInvitesIdResendConflict_EncodeDecode(t *testing.T) {
	var typ PostInvitesIdResendConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInvitesIdResendConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInvitesIdResendInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostInvitesIdResendInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInvitesIdResendInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInvitesIdResendNotFound_EncodeDecode(t *testing.T) {
	var typ PostInvitesIdResendNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInvitesIdResendNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInvitesIdResendUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostInvitesIdResendUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInvitesIdResendUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInvitesInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostInvitesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInvitesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInvitesNotFound_EncodeDecode(t *testing.T) {
	var typ PostInvitesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInvitesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostInvitesUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostInvitesUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostInvitesUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPaymentsIdCaptureConflict_EncodeDecode(t *testing.T) {
	var typ PostPaymentsIdCaptureConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPaymentsIdCaptureConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPaymentsIdCaptureInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPaymentsIdCaptureInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPaymentsIdCaptureInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPaymentsIdCaptureNotFound_EncodeDecode(t *testing.T) {
	var typ PostPaymentsIdCaptureNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPaymentsIdCaptureNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPaymentsIdCaptureUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPaymentsIdCaptureUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPaymentsIdCaptureUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPaymentsIdRefundConflict_EncodeDecode(t *testing.T) {
	var typ PostPaymentsIdRefundConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPaymentsIdRefundConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPaymentsIdRefundInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPaymentsIdRefundInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPaymentsIdRefundInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPaymentsIdRefundNotFound_EncodeDecode(t *testing.T) {
	var typ PostPaymentsIdRefundNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPaymentsIdRefundNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPaymentsIdRefundUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPaymentsIdRefundUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPaymentsIdRefundUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsConflict_EncodeDecode(t *testing.T) {
	var typ PostPriceListsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsIdConflict_EncodeDecode(t *testing.T) {
	var typ PostPriceListsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPriceListsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostPriceListsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsIdPricesBatchAddConflict_EncodeDecode(t *testing.T) {
	var typ PostPriceListsIdPricesBatchAddConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsIdPricesBatchAddConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsIdPricesBatchAddInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPriceListsIdPricesBatchAddInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsIdPricesBatchAddInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsIdPricesBatchAddNotFound_EncodeDecode(t *testing.T) {
	var typ PostPriceListsIdPricesBatchAddNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsIdPricesBatchAddNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsIdPricesBatchAddUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPriceListsIdPricesBatchAddUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsIdPricesBatchAddUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsIdPricesBatchRemoveConflict_EncodeDecode(t *testing.T) {
	var typ PostPriceListsIdPricesBatchRemoveConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsIdPricesBatchRemoveConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsIdPricesBatchRemoveInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPriceListsIdPricesBatchRemoveInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsIdPricesBatchRemoveInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsIdPricesBatchRemoveNotFound_EncodeDecode(t *testing.T) {
	var typ PostPriceListsIdPricesBatchRemoveNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsIdPricesBatchRemoveNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsIdPricesBatchRemoveUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPriceListsIdPricesBatchRemoveUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsIdPricesBatchRemoveUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPriceListsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPriceListsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsNotFound_EncodeDecode(t *testing.T) {
	var typ PostPriceListsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPriceListsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPriceListsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPriceListsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPricingRuleTypesConflict_EncodeDecode(t *testing.T) {
	var typ PostPricingRuleTypesConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPricingRuleTypesConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPricingRuleTypesIdConflict_EncodeDecode(t *testing.T) {
	var typ PostPricingRuleTypesIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPricingRuleTypesIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPricingRuleTypesIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPricingRuleTypesIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPricingRuleTypesIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPricingRuleTypesIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostPricingRuleTypesIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPricingRuleTypesIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPricingRuleTypesIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPricingRuleTypesIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPricingRuleTypesIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPricingRuleTypesInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPricingRuleTypesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPricingRuleTypesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPricingRuleTypesNotFound_EncodeDecode(t *testing.T) {
	var typ PostPricingRuleTypesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPricingRuleTypesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPricingRuleTypesUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPricingRuleTypesUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPricingRuleTypesUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsConflict_EncodeDecode(t *testing.T) {
	var typ PostProductsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdConflict_EncodeDecode(t *testing.T) {
	var typ PostProductsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostProductsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostProductsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdOptionsConflict_EncodeDecode(t *testing.T) {
	var typ PostProductsIdOptionsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdOptionsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdOptionsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostProductsIdOptionsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdOptionsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdOptionsNotFound_EncodeDecode(t *testing.T) {
	var typ PostProductsIdOptionsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdOptionsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdOptionsOptionIDConflict_EncodeDecode(t *testing.T) {
	var typ PostProductsIdOptionsOptionIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdOptionsOptionIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdOptionsOptionIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostProductsIdOptionsOptionIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdOptionsOptionIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdOptionsOptionIDNotFound_EncodeDecode(t *testing.T) {
	var typ PostProductsIdOptionsOptionIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdOptionsOptionIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdOptionsOptionIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostProductsIdOptionsOptionIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdOptionsOptionIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdOptionsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostProductsIdOptionsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdOptionsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostProductsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdVariantsConflict_EncodeDecode(t *testing.T) {
	var typ PostProductsIdVariantsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdVariantsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdVariantsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostProductsIdVariantsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdVariantsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdVariantsNotFound_EncodeDecode(t *testing.T) {
	var typ PostProductsIdVariantsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdVariantsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdVariantsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostProductsIdVariantsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdVariantsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdVariantsVariantIDConflict_EncodeDecode(t *testing.T) {
	var typ PostProductsIdVariantsVariantIDConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdVariantsVariantIDConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdVariantsVariantIDInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostProductsIdVariantsVariantIDInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdVariantsVariantIDInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdVariantsVariantIDNotFound_EncodeDecode(t *testing.T) {
	var typ PostProductsIdVariantsVariantIDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdVariantsVariantIDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsIdVariantsVariantIDUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostProductsIdVariantsVariantIDUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsIdVariantsVariantIDUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostProductsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsNotFound_EncodeDecode(t *testing.T) {
	var typ PostProductsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostProductsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostProductsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostProductsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsConflict_EncodeDecode(t *testing.T) {
	var typ PostPromotionsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdBuyRulesBatchAddConflict_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdBuyRulesBatchAddConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdBuyRulesBatchAddConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdBuyRulesBatchAddInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdBuyRulesBatchAddInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdBuyRulesBatchAddInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdBuyRulesBatchAddNotFound_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdBuyRulesBatchAddNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdBuyRulesBatchAddNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdBuyRulesBatchAddUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdBuyRulesBatchAddUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdBuyRulesBatchAddUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdBuyRulesBatchRemoveConflict_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdBuyRulesBatchRemoveConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdBuyRulesBatchRemoveConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdBuyRulesBatchRemoveInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdBuyRulesBatchRemoveInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdBuyRulesBatchRemoveInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdBuyRulesBatchRemoveNotFound_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdBuyRulesBatchRemoveNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdBuyRulesBatchRemoveNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdBuyRulesBatchRemoveUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdBuyRulesBatchRemoveUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdBuyRulesBatchRemoveUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdConflict_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdRulesBatchAddConflict_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdRulesBatchAddConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdRulesBatchAddConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdRulesBatchAddInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdRulesBatchAddInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdRulesBatchAddInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdRulesBatchAddNotFound_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdRulesBatchAddNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdRulesBatchAddNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdRulesBatchAddUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdRulesBatchAddUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdRulesBatchAddUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdRulesBatchRemoveConflict_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdRulesBatchRemoveConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdRulesBatchRemoveConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdRulesBatchRemoveInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdRulesBatchRemoveInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdRulesBatchRemoveInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdRulesBatchRemoveNotFound_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdRulesBatchRemoveNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdRulesBatchRemoveNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdRulesBatchRemoveUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdRulesBatchRemoveUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdRulesBatchRemoveUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdRulesBatchUpdateConflict_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdRulesBatchUpdateConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdRulesBatchUpdateConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdRulesBatchUpdateInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdRulesBatchUpdateInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdRulesBatchUpdateInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdRulesBatchUpdateNotFound_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdRulesBatchUpdateNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdRulesBatchUpdateNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdRulesBatchUpdateUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdRulesBatchUpdateUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdRulesBatchUpdateUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdTargetRulesBatchAddConflict_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdTargetRulesBatchAddConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdTargetRulesBatchAddConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdTargetRulesBatchAddInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdTargetRulesBatchAddInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdTargetRulesBatchAddInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdTargetRulesBatchAddNotFound_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdTargetRulesBatchAddNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdTargetRulesBatchAddNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdTargetRulesBatchAddUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdTargetRulesBatchAddUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdTargetRulesBatchAddUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdTargetRulesBatchRemoveConflict_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdTargetRulesBatchRemoveConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdTargetRulesBatchRemoveConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdTargetRulesBatchRemoveInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdTargetRulesBatchRemoveInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdTargetRulesBatchRemoveInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdTargetRulesBatchRemoveNotFound_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdTargetRulesBatchRemoveNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdTargetRulesBatchRemoveNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdTargetRulesBatchRemoveUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdTargetRulesBatchRemoveUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdTargetRulesBatchRemoveUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPromotionsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostPromotionsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsNotFound_EncodeDecode(t *testing.T) {
	var typ PostPromotionsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostPromotionsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostPromotionsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostPromotionsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostRegionsConflict_EncodeDecode(t *testing.T) {
	var typ PostRegionsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostRegionsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostRegionsIdConflict_EncodeDecode(t *testing.T) {
	var typ PostRegionsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostRegionsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostRegionsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostRegionsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostRegionsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostRegionsIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostRegionsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostRegionsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostRegionsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostRegionsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostRegionsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostRegionsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostRegionsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostRegionsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostRegionsNotFound_EncodeDecode(t *testing.T) {
	var typ PostRegionsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostRegionsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostRegionsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostRegionsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostRegionsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSalesChannelsConflict_EncodeDecode(t *testing.T) {
	var typ PostSalesChannelsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSalesChannelsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSalesChannelsIdConflict_EncodeDecode(t *testing.T) {
	var typ PostSalesChannelsIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSalesChannelsIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSalesChannelsIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostSalesChannelsIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSalesChannelsIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSalesChannelsIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostSalesChannelsIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSalesChannelsIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSalesChannelsIdProductsBatchAddConflict_EncodeDecode(t *testing.T) {
	var typ PostSalesChannelsIdProductsBatchAddConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSalesChannelsIdProductsBatchAddConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSalesChannelsIdProductsBatchAddInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostSalesChannelsIdProductsBatchAddInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSalesChannelsIdProductsBatchAddInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSalesChannelsIdProductsBatchAddNotFound_EncodeDecode(t *testing.T) {
	var typ PostSalesChannelsIdProductsBatchAddNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSalesChannelsIdProductsBatchAddNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSalesChannelsIdProductsBatchAddUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostSalesChannelsIdProductsBatchAddUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSalesChannelsIdProductsBatchAddUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSalesChannelsIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostSalesChannelsIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSalesChannelsIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSalesChannelsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostSalesChannelsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSalesChannelsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSalesChannelsNotFound_EncodeDecode(t *testing.T) {
	var typ PostSalesChannelsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSalesChannelsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSalesChannelsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostSalesChannelsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSalesChannelsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostStockLocationsConflict_EncodeDecode(t *testing.T) {
	var typ PostStockLocationsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostStockLocationsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostStockLocationsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostStockLocationsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostStockLocationsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostStockLocationsNotFound_EncodeDecode(t *testing.T) {
	var typ PostStockLocationsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostStockLocationsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostStockLocationsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostStockLocationsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostStockLocationsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostStoresIdConflict_EncodeDecode(t *testing.T) {
	var typ PostStoresIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostStoresIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostStoresIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostStoresIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostStoresIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostStoresIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostStoresIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostStoresIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostStoresIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostStoresIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostStoresIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRatesConflict_EncodeDecode(t *testing.T) {
	var typ PostTaxRatesConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRatesConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRatesIdConflict_EncodeDecode(t *testing.T) {
	var typ PostTaxRatesIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRatesIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRatesIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostTaxRatesIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRatesIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRatesIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostTaxRatesIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRatesIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRatesIdRulesConflict_EncodeDecode(t *testing.T) {
	var typ PostTaxRatesIdRulesConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRatesIdRulesConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRatesIdRulesInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostTaxRatesIdRulesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRatesIdRulesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRatesIdRulesNotFound_EncodeDecode(t *testing.T) {
	var typ PostTaxRatesIdRulesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRatesIdRulesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRatesIdRulesUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostTaxRatesIdRulesUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRatesIdRulesUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRatesIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostTaxRatesIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRatesIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRatesInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostTaxRatesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRatesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRatesNotFound_EncodeDecode(t *testing.T) {
	var typ PostTaxRatesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRatesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRatesUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostTaxRatesUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRatesUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRegionsConflict_EncodeDecode(t *testing.T) {
	var typ PostTaxRegionsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRegionsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRegionsInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostTaxRegionsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRegionsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRegionsNotFound_EncodeDecode(t *testing.T) {
	var typ PostTaxRegionsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRegionsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostTaxRegionsUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostTaxRegionsUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostTaxRegionsUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostUsersConflict_EncodeDecode(t *testing.T) {
	var typ PostUsersConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostUsersConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostUsersIdConflict_EncodeDecode(t *testing.T) {
	var typ PostUsersIdConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostUsersIdConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostUsersIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostUsersIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostUsersIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostUsersIdNotFound_EncodeDecode(t *testing.T) {
	var typ PostUsersIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostUsersIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostUsersIdUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostUsersIdUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostUsersIdUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostUsersInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostUsersInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostUsersInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostUsersNotFound_EncodeDecode(t *testing.T) {
	var typ PostUsersNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostUsersNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostUsersUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostUsersUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostUsersUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostWorkflowsExecutionsWorkflowIdRunConflict_EncodeDecode(t *testing.T) {
	var typ PostWorkflowsExecutionsWorkflowIdRunConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostWorkflowsExecutionsWorkflowIdRunConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostWorkflowsExecutionsWorkflowIdRunInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostWorkflowsExecutionsWorkflowIdRunInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostWorkflowsExecutionsWorkflowIdRunInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostWorkflowsExecutionsWorkflowIdRunNotFound_EncodeDecode(t *testing.T) {
	var typ PostWorkflowsExecutionsWorkflowIdRunNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostWorkflowsExecutionsWorkflowIdRunNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostWorkflowsExecutionsWorkflowIdRunUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostWorkflowsExecutionsWorkflowIdRunUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostWorkflowsExecutionsWorkflowIdRunUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostWorkflowsExecutionsWorkflowIdStepsFailureConflict_EncodeDecode(t *testing.T) {
	var typ PostWorkflowsExecutionsWorkflowIdStepsFailureConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostWorkflowsExecutionsWorkflowIdStepsFailureConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostWorkflowsExecutionsWorkflowIdStepsFailureInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostWorkflowsExecutionsWorkflowIdStepsFailureInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostWorkflowsExecutionsWorkflowIdStepsFailureInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostWorkflowsExecutionsWorkflowIdStepsFailureNotFound_EncodeDecode(t *testing.T) {
	var typ PostWorkflowsExecutionsWorkflowIdStepsFailureNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostWorkflowsExecutionsWorkflowIdStepsFailureNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostWorkflowsExecutionsWorkflowIdStepsFailureUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostWorkflowsExecutionsWorkflowIdStepsFailureUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostWorkflowsExecutionsWorkflowIdStepsFailureUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostWorkflowsExecutionsWorkflowIdStepsSuccessConflict_EncodeDecode(t *testing.T) {
	var typ PostWorkflowsExecutionsWorkflowIdStepsSuccessConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostWorkflowsExecutionsWorkflowIdStepsSuccessConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostWorkflowsExecutionsWorkflowIdStepsSuccessInternalServerError_EncodeDecode(t *testing.T) {
	var typ PostWorkflowsExecutionsWorkflowIdStepsSuccessInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostWorkflowsExecutionsWorkflowIdStepsSuccessInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostWorkflowsExecutionsWorkflowIdStepsSuccessNotFound_EncodeDecode(t *testing.T) {
	var typ PostWorkflowsExecutionsWorkflowIdStepsSuccessNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostWorkflowsExecutionsWorkflowIdStepsSuccessNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostWorkflowsExecutionsWorkflowIdStepsSuccessUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ PostWorkflowsExecutionsWorkflowIdStepsSuccessUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostWorkflowsExecutionsWorkflowIdStepsSuccessUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestR400Error_EncodeDecode(t *testing.T) {
	var typ R400Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 R400Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestR400Error_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"errors\":[{\"message\":\"first_name must be a string\",\"type\":\"invalid_data\"},{\"message\":\"Discount must be set to dynamic\",\"type\":\"not_allowed\"}],\"message\":\"Provided request body contains errors. Please check the data and retry the request\"}"},
		{Input: "{\"message\":\"Discount must be set to dynamic\",\"type\":\"not_allowed\"}"},
		{Input: "{\"message\":\"first_name must be a string\",\"type\":\"invalid_data\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ R400Error

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 R400Error
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestStockLocationAddress_EncodeDecode(t *testing.T) {
	var typ StockLocationAddress
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StockLocationAddress
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
