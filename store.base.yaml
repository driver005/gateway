openapi: 3.0.0
info:
  version: 1.0.0
  title: Medusa Storefront API
  description: ""
servers:
- url: http://localhost:9000
- url: https://api.medusa-commerce.com
paths:
  /store/auth:
    delete:
      operationId: DeleteAuth
      summary: Customer Log out
      description: Delete the current session for the logged in customer.
      x-authenticated: true
      x-codegen:
        method: deleteSession
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.auth.deleteSession()
          .then(() => {
          // customer logged out successfully
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '{backend_url}/store/auth' \
          -H 'Authorization: Bearer {access_token}'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Auth
      responses:
        "200":
          content: {}
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
    get:
      operationId: GetAuth
      summary: Get Current Customer
      description: Retrieve the currently logged in Customer's details.
      x-authenticated: true
      x-codegen:
        method: getSession
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged
          medusa.auth.getSession()
          .then(({ customer }) => {
          console.log(customer.id);
          })
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/auth' \
          -H 'Authorization: Bearer {access_token}'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Auth
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreAuthRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
    post:
      operationId: PostAuth
      summary: Customer Login
      description: Log a customer in and includes the Cookie session in the response
        header. The cookie session can be used in subsequent requests to authenticate
        the customer. When using Medusa's JS or Medusa React clients, the cookie is
        automatically attached to subsequent requests.
      x-codegen:
        method: authenticate
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.auth.authenticate({
          email: "user@example.com",
          password: "user@example.com"
          })
          .then(({ customer }) => {
          console.log(customer.id);
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/auth' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com",
          "password": "supersecret"
          }'
      tags:
      - Auth
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreAuthRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PostAuthReq'
  /store/auth/{email}:
    get:
      operationId: GetAuthEmail
      summary: Check if Email Exists
      description: Check if there's a customer already registered with the provided
        email.
      x-codegen:
        method: exists
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.auth.exists("user@example.com")
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/auth/user@example.com'
      tags:
      - Auth
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreGetAuthEmailRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - description: The email to check.
        format: email
        in: path
        name: email
        required: true
        schema: null
        type: string
  /store/auth/token:
    post:
      operationId: PostToken
      summary: Customer Login (JWT)
      description: After a successful login, a JWT token is returned, which can be
        used to send authenticated requests.
      x-codegen:
        method: getToken
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.auth.getToken({
          email: 'user@example.com',
          password: 'supersecret'
          })
          .then(({ access_token }) => {
          console.log(access_token);
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/auth/token' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com",
          "password": "supersecret"
          }'
      tags:
      - Auth
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreBearerAuthRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostAuthReq'
  /store/carts:
    post:
      operationId: PostCart
      summary: Create a Cart
      description: |
        Create a Cart. Although optional, specifying the cart's region and sales channel can affect the cart's pricing and
        the products that can be added to the cart respectively. So, make sure to set those early on and change them if necessary, such as when the customer changes their region.
        If a customer is logged in, make sure to pass its ID or email within the cart's details so that the cart is attached to the customer.
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.create()
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCreateCart } from "medusa-react"
          type Props = {
          regionId: string
          }
          const Cart = ({ regionId }: Props) => {
          const createCart = useCreateCart()
          const handleCreate = () => {
          createCart.mutate({
          region_id: regionId
          // creates an empty cart
          }, {
          onSuccess: ({ cart }) => {
          console.log(cart.items)
          }
          })
          }
          // ...
          }
          export default Cart
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/carts'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: Successfully created a new Cart
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostCartReq'
  /store/carts/{id}:
    get:
      operationId: GetCartsCart
      summary: Get a Cart
      description: Retrieve a Cart's details. This includes recalculating its totals.
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.retrieve(cartId)
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useGetCart } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Cart = ({ cartId }: Props) => {
          const { cart, isLoading } = useGetCart(cartId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {cart && cart.items.length === 0 && (
          <span>Cart is empty</span>
          )}
          {cart && cart.items.length > 0 && (
          <ul>
          {cart.items.map((item) => (
          <li key={item.id}>{item.title}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Cart
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/carts/{id}'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Cart.
    post:
      operationId: PostCartsCart
      summary: Update a Cart
      description: Update a Cart's details. If the cart has payment sessions and the
        region was not changed, the payment sessions are updated. The cart's totals
        are also recalculated.
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.update(cartId, {
          email: "user@example.com"
          })
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useUpdateCart } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Cart = ({ cartId }: Props) => {
          const updateCart = useUpdateCart(cartId)
          const handleUpdate = (
          email: string
          ) => {
          updateCart.mutate({
          email
          }, {
          onSuccess: ({ cart }) => {
          console.log(cart.email)
          }
          })
          }
          // ...
          }
          export default Cart
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/carts/{id}' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com"
          }'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Cart.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostCartsCartReq'
  /store/carts/{id}/complete:
    post:
      operationId: PostCartsCartComplete
      summary: Complete a Cart
      description: |
        Complete a cart and place an order or create a swap, based on the cart's type. This includes attempting to authorize the cart's payment.
        If authorizing the payment requires more action, the cart will not be completed and the order will not be placed or the swap will not be created.
        An idempotency key will be generated if none is provided in the header `Idempotency-Key` and added to
        the response. If an error occurs during cart completion or the request is interrupted for any reason, the cart completion can be retried by passing the idempotency
        key in the `Idempotency-Key` header.
      x-codegen:
        method: complete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.complete(cartId)
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCompleteCart } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Cart = ({ cartId }: Props) => {
          const completeCart = useCompleteCart(cartId)
          const handleComplete = () => {
          completeCart.mutate(void 0, {
          onSuccess: ({ data, type }) => {
          console.log(data.id, type)
          }
          })
          }
          // ...
          }
          export default Cart
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/carts/{id}/complete'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCompleteCartRes'
          description: If the payment of the cart was successfully authorized, but
            requires further action from the customer, the response body will contain
            the cart with an updated payment session. Otherwise, if the payment was
            authorized and the cart was successfully completed, the response body
            will contain either the newly created order or swap, depending on what
            the cart was created for.
      parameters:
      - (path) id=* {String} The Cart ID.
      externalDocs:
        description: Cart completion overview
        url: https://docs.medusajs.com/modules/carts-and-checkout/cart#cart-completion
  /store/carts/{id}/discounts/{code}:
    delete:
      operationId: DeleteCartsCartDiscountsDiscount
      summary: Remove Discount
      description: Remove a Discount from a Cart. This only removes the application
        of the discount, and not completely deletes it. The totals will be re-calculated
        and the payment sessions will be refreshed after the removal.
      x-codegen:
        method: deleteDiscount
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.deleteDiscount(cartId, code)
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '{backend_url}/store/carts/{id}/discounts/{code}'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Cart.
      - (path) code=* {string} The unique discount code.
  /store/carts/{id}/line-items/{line_id}:
    delete:
      operationId: DeleteCartsCartLineItemsItem
      summary: Delete a Line Item
      description: Delete a Line Item from a Cart. The payment sessions will be updated
        and the totals will be recalculated.
      x-codegen:
        method: deleteLineItem
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.lineItems.delete(cartId, lineId)
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useDeleteLineItem } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Cart = ({ cartId }: Props) => {
          const deleteLineItem = useDeleteLineItem(cartId)
          const handleDeleteItem = (
          lineItemId: string
          ) => {
          deleteLineItem.mutate({
          lineId: lineItemId,
          }, {
          onSuccess: ({ cart }) => {
          console.log(cart.items)
          }
          })
          }
          // ...
          }
          export default Cart
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '{backend_url}/store/carts/{id}/line-items/{line_id}'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Cart.
      - (path) line_id=* {string} The ID of the Line Item.
    post:
      operationId: PostCartsCartLineItemsItem
      summary: Update a Line Item
      description: Update a line item's quantity.
      x-codegen:
        method: updateLineItem
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.lineItems.update(cartId, lineId, {
          quantity: 1
          })
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useUpdateLineItem } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Cart = ({ cartId }: Props) => {
          const updateLineItem = useUpdateLineItem(cartId)
          const handleUpdateItem = (
          lineItemId: string,
          quantity: number
          ) => {
          updateLineItem.mutate({
          lineId: lineItemId,
          quantity,
          }, {
          onSuccess: ({ cart }) => {
          console.log(cart.items)
          }
          })
          }
          // ...
          }
          export default Cart
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/carts/{id}/line-items/{line_id}' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "quantity": 1
          }'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Cart.
      - (path) line_id=* {string} The ID of the Line Item.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostCartsCartLineItemsItemReq'
  /store/carts/{id}/payment-session:
    post:
      operationId: PostCartsCartPaymentSession
      summary: Select a Payment Session
      description: Select the Payment Session that will be used to complete the cart.
        This is typically used when the customer chooses their preferred payment method
        during checkout. The totals of the cart will be recalculated.
      x-codegen:
        method: setPaymentSession
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.setPaymentSession(cartId, {
          provider_id: "manual"
          })
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useSetPaymentSession } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Cart = ({ cartId }: Props) => {
          const setPaymentSession = useSetPaymentSession(cartId)
          const handleSetPaymentSession = (
          providerId: string
          ) => {
          setPaymentSession.mutate({
          provider_id: providerId,
          }, {
          onSuccess: ({ cart }) => {
          console.log(cart.payment_session)
          }
          })
          }
          // ...
          }
          export default Cart
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/carts/{id}/payment-sessions' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "provider_id": "manual"
          }'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Cart.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostCartsCartPaymentSessionReq'
  /store/carts/{id}/payment-sessions:
    post:
      operationId: PostCartsCartPaymentSessions
      summary: Create Payment Sessions
      description: Create Payment Sessions for each of the available Payment Providers
        in the Cart's Region. If there's only one payment session created, it will
        be selected by default. The creation of the payment session uses the payment
        provider and may require sending requests to third-party services.
      x-codegen:
        method: createPaymentSessions
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.createPaymentSessions(cartId)
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCreatePaymentSession } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Cart = ({ cartId }: Props) => {
          const createPaymentSession = useCreatePaymentSession(cartId)
          const handleComplete = () => {
          createPaymentSession.mutate(void 0, {
          onSuccess: ({ cart }) => {
          console.log(cart.payment_sessions)
          }
          })
          }
          // ...
          }
          export default Cart
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/carts/{id}/payment-sessions'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Cart.
  /store/carts/{id}/payment-sessions/{provider_id}:
    delete:
      operationId: DeleteCartsCartPaymentSessionsSession
      summary: Delete a Payment Session
      description: Delete a Payment Session in a Cart. May be useful if a payment
        has failed. The totals will be recalculated.
      x-codegen:
        method: deletePaymentSession
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.deletePaymentSession(cartId, "manual")
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useDeletePaymentSession } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Cart = ({ cartId }: Props) => {
          const deletePaymentSession = useDeletePaymentSession(cartId)
          const handleDeletePaymentSession = (
          providerId: string
          ) => {
          deletePaymentSession.mutate({
          provider_id: providerId,
          }, {
          onSuccess: ({ cart }) => {
          console.log(cart.payment_sessions)
          }
          })
          }
          // ...
          }
          export default Cart
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '{backend_url}/store/carts/{id}/payment-sessions/{provider_id}'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Cart.
      - (path) provider_id=* {string} The ID of the Payment Provider used to create
        the Payment Session to be deleted.
    post:
      operationId: PostCartsCartPaymentSessionUpdate
      summary: Update a Payment Session
      description: Update a Payment Session with additional data. This can be useful
        depending on the payment provider used. All payment sessions are updated and
        cart totals are recalculated afterwards.
      x-codegen:
        method: updatePaymentSession
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.updatePaymentSession(cartId, "manual", {
          data: {
          }
          })
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useUpdatePaymentSession } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Cart = ({ cartId }: Props) => {
          const updatePaymentSession = useUpdatePaymentSession(cartId)
          const handleUpdate = (
          providerId: string,
          data: Record<string, unknown>
          ) => {
          updatePaymentSession.mutate({
          provider_id: providerId,
          data
          }, {
          onSuccess: ({ cart }) => {
          console.log(cart.payment_session)
          }
          })
          }
          // ...
          }
          export default Cart
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/carts/{id}/payment-sessions/manual' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "data": {}
          }'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Cart.
      - (path) provider_id=* {string} The ID of the payment provider.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostCartsCartPaymentSessionUpdateReq'
  /store/carts/{id}/payment-sessions/{provider_id}/refresh:
    post:
      operationId: PostCartsCartPaymentSessionsSession
      summary: Refresh a Payment Session
      description: Refresh a Payment Session to ensure that it is in sync with the
        Cart. This is usually not necessary, but is provided for edge cases.
      x-codegen:
        method: refreshPaymentSession
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.refreshPaymentSession(cartId, "manual")
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useRefreshPaymentSession } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Cart = ({ cartId }: Props) => {
          const refreshPaymentSession = useRefreshPaymentSession(cartId)
          const handleRefresh = (
          providerId: string
          ) => {
          refreshPaymentSession.mutate({
          provider_id: providerId,
          }, {
          onSuccess: ({ cart }) => {
          console.log(cart.payment_sessions)
          }
          })
          }
          // ...
          }
          export default Cart
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/carts/{id}/payment-sessions/{provider_id}/refresh'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Cart.
      - (path) provider_id=* {string} The ID of the Payment Provider that created
        the Payment Session to be refreshed.
  /store/carts/{id}/shipping-methods:
    post:
      operationId: PostCartsCartShippingMethod
      summary: Add Shipping Method
      description: Add a Shipping Method to the Cart. The validation of the `data`
        field is handled by the fulfillment provider of the chosen shipping option.
      x-codegen:
        method: addShippingMethod
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.carts.addShippingMethod(cartId, {
          option_id
          })
          .then(({ cart }) => {
          console.log(cart.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAddShippingMethodToCart } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Cart = ({ cartId }: Props) => {
          const addShippingMethod = useAddShippingMethodToCart(cartId)
          const handleAddShippingMethod = (
          optionId: string
          ) => {
          addShippingMethod.mutate({
          option_id: optionId,
          }, {
          onSuccess: ({ cart }) => {
          console.log(cart.shipping_methods)
          }
          })
          }
          // ...
          }
          export default Cart
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/carts/{id}/shipping-methods' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "option_id": "{option_id}",
          }'
      tags:
      - Carts
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The cart ID.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostCartsCartShippingMethodReq'
  /store/carts/{id}/taxes:
    post:
      operationId: PostCartsCartTaxes
      summary: Calculate Cart Taxes
      description: Calculate the taxes for a cart. This is useful if the `automatic_taxes`
        field of the cart's region is set to `false`. If the cart's region uses a
        tax provider other than Medusa's system provider, this may lead to sending
        requests to third-party services.
      x-codegen:
        method: calculateTaxes
      x-codeSamples:
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/carts/{id}/taxes'
      tags:
      - Carts
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartsRes'
          description: OK
      parameters:
      - (path) id=* {String} The Cart ID.
      externalDocs:
        description: How to calculate taxes manually during checkout
        url: https://docs.medusajs.com/modules/taxes/storefront/manual-calculation
  /store/collections:
    get:
      operationId: GetCollections
      summary: List Collections
      description: Retrieve a list of product collections. The product collections
        can be filtered by fields such as `handle` or `created_at`. The product collections
        can also be paginated.
      x-codegen:
        method: list
        queryParams: StoreGetCollectionsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.collections.list()
          .then(({ collections, limit, offset, count }) => {
          console.log(collections.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCollections } from "medusa-react"
          const ProductCollections = () => {
          const { collections, isLoading } = useCollections()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {collections && collections.length === 0 && (
          <span>No Product Collections</span>
          )}
          {collections && collections.length > 0 && (
          <ul>
          {collections.map((collection) => (
          <li key={collection.id}>{collection.title}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default ProductCollections
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/collections'
      tags:
      - Product Collections
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCollectionsListRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (query) offset=0 {integer} The number of product collections to skip when
        retrieving the product collections.
      - (query) limit=10 {integer} Limit the number of product collections returned.
      - description: Filter by handles
        explode: false
        in: query
        items: null
        name: handle
        schema: null
        style: form
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
  /store/collections/{id}:
    get:
      operationId: GetCollectionsCollection
      summary: Get a Collection
      description: Retrieve a Product Collection's details.
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.collections.retrieve(collectionId)
          .then(({ collection }) => {
          console.log(collection.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCollection } from "medusa-react"
          type Props = {
          collectionId: string
          }
          const ProductCollection = ({ collectionId }: Props) => {
          const { collection, isLoading } = useCollection(collectionId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {collection && <span>{collection.title}</span>}
          </div>
          )
          }
          export default ProductCollection
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/collections/{id}'
      tags:
      - Product Collections
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCollectionsRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The id of the Product Collection
  /store/customers:
    post:
      operationId: PostCustomers
      summary: Create a Customer
      description: Register a new customer. This will also automatically authenticate
        the customer and set their login session in the response Cookie header. The
        cookie session can be used in subsequent requests to authenticate the customer.
        When using Medusa's JS or Medusa React clients, the cookie is automatically
        attached to subsequent requests.
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.customers.create({
          first_name: "Alec",
          last_name: "Reynolds",
          email: "user@example.com",
          password: "supersecret"
          })
          .then(({ customer }) => {
          console.log(customer.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCreateCustomer } from "medusa-react"
          const RegisterCustomer = () => {
          const createCustomer = useCreateCustomer()
          // ...
          const handleCreate = (
          customerData: {
          first_name: string
          last_name: string
          email: string
          password: string
          }
          ) => {
          // ...
          createCustomer.mutate(customerData, {
          onSuccess: ({ customer }) => {
          console.log(customer.id)
          }
          })
          }
          // ...
          }
          export default RegisterCustomer
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/customers' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "first_name": "Alec",
          "last_name": "Reynolds",
          "email": "user@example.com",
          "password": "supersecret"
          }'
      tags:
      - Customers
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCustomersRes'
          description: OK
        Ʀ:
          content:
            application/json:
              schema:
                type: object
                properties:
                  code:
                    description: The error code
                    type: string
                  message:
                    description: Human-readable message with details about the error
                    type: string
                  type:
                    description: The type of error
                    type: string
          description: A customer with the same email exists
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PostCustomersReq'
  /store/customers/me:
    get:
      operationId: GetCustomersCustomer
      summary: Get a Customer
      description: Retrieve the logged-in Customer's details.
      x-authenticated: true
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged
          medusa.customers.retrieve()
          .then(({ customer }) => {
          console.log(customer.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useMeCustomer } from "medusa-react"
          const Customer = () => {
          const { customer, isLoading } = useMeCustomer()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {customer && (
          <span>{customer.first_name} {customer.last_name}</span>
          )}
          </div>
          )
          }
          export default Customer
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/customers/me' \
          -H 'Authorization: Bearer {access_token}'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customers
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCustomersRes'
          description: OK
    post:
      operationId: PostCustomersCustomer
      summary: Update Customer
      description: Update the logged-in customer's details.
      x-authenticated: true
      x-codegen:
        method: update
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged
          medusa.customers.update({
          first_name: "Laury"
          })
          .then(({ customer }) => {
          console.log(customer.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useUpdateMe } from "medusa-react"
          type Props = {
          customerId: string
          }
          const Customer = ({ customerId }: Props) => {
          const updateCustomer = useUpdateMe()
          // ...
          const handleUpdate = (
          firstName: string
          ) => {
          // ...
          updateCustomer.mutate({
          id: customerId,
          first_name: firstName,
          }, {
          onSuccess: ({ customer }) => {
          console.log(customer.first_name)
          }
          })
          }
          // ...
          }
          export default Customer
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/customers/me' \
          -H 'Authorization: Bearer {access_token}' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "first_name": "Laury"
          }'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customers
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCustomersRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PostCustomersCustomerReq'
  /store/customers/me/addresses:
    post:
      operationId: PostCustomersCustomerAddresses
      summary: Add a Shipping Address
      description: Add a Shipping Address to a Customer's saved addresses.
      x-authenticated: true
      x-codegen:
        method: addAddress
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged
          medusa.customers.addresses.addAddress({
          address: {
          first_name: "Celia",
          last_name: "Schumm",
          address_1: "225 Bednar Curve",
          city: "Danielville",
          country_code: "US",
          postal_code: "85137",
          phone: "981-596-6748 x90188",
          company: "Wyman LLC",
          province: "Georgia",
          }
          })
          .then(({ customer }) => {
          console.log(customer.id);
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/customers/me/addresses' \
          -H 'Authorization: Bearer {access_token}' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "address": {
          "first_name": "Celia",
          "last_name": "Schumm",
          "address_1": "225 Bednar Curve",
          "city": "Danielville",
          "country_code": "US",
          "postal_code": "85137"
          }
          }'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customers
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCustomersRes'
          description: A successful response
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostCustomersCustomerAddressesReq'
  /store/customers/me/addresses/{address_id}:
    delete:
      operationId: DeleteCustomersCustomerAddressesAddress
      summary: Delete an Address
      description: Delete an Address from the Customer's saved addresses.
      x-authenticated: true
      x-codegen:
        method: deleteAddress
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged
          medusa.customers.addresses.deleteAddress(addressId)
          .then(({ customer }) => {
          console.log(customer.id);
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X DELETE '{backend_url}/store/customers/me/addresses/{address_id}' \
          -H 'Authorization: Bearer {access_token}'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customers
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCustomersRes'
          description: OK
      parameters:
      - (path) address_id=* {string} The id of the Address to remove.
    post:
      operationId: PostCustomersCustomerAddressesAddress
      summary: Update a Shipping Address
      description: Update the logged-in customer's saved Shipping Address's details.
      x-authenticated: true
      x-codegen:
        method: updateAddress
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged
          medusa.customers.addresses.updateAddress(addressId, {
          first_name: "Gina"
          })
          .then(({ customer }) => {
          console.log(customer.id);
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/customers/me/addresses/{address_id}' \
          -H 'Authorization: Bearer {access_token}' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "first_name": "Gina"
          }'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customers
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCustomersRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) address_id=* {String} The ID of the Address.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostCustomersCustomerAddressesAddressReq'
  /store/customers/me/orders:
    get:
      operationId: GetCustomersCustomerOrders
      summary: List Orders
      description: Retrieve a list of the logged-in Customer's Orders. The orders
        can be filtered by fields such as `status` or `fulfillment_status`. The orders
        can also be paginated.
      x-authenticated: true
      x-codegen:
        method: listOrders
        queryParams: StoreGetCustomersCustomerOrdersParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged
          medusa.customers.listOrders()
          .then(({ orders, limit, offset, count }) => {
          console.log(orders);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCustomerOrders } from "medusa-react"
          const Orders = () => {
          // refetch a function that can be used to
          // re-retrieve orders after the customer logs in
          const { orders, isLoading } = useCustomerOrders()
          return (
          <div>
          {isLoading && <span>Loading orders...</span>}
          {orders?.length && (
          <ul>
          {orders.map((order) => (
          <li key={order.id}>{order.display_id}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Orders
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/customers/me/orders' \
          -H 'Authorization: Bearer {access_token}'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customers
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCustomersListOrdersRes'
          description: OK
      parameters:
      - (query) q {string} term to search orders' display ID, email, shipping address's
        first name, customer's first name, customer's last name, and customer's phone
        number.
      - (query) id {string} Filter by ID.
      - description: Filter by status.
        enum:
        - pending
        - completed
        - archived
        - canceled
        - requires_action
        explode: false
        in: query
        items: null
        name: status
        schema: null
        style: form
        type: string
      - description: Fulfillment status to search for.
        enum:
        - not_fulfilled
        - partially_fulfilled
        - fulfilled
        - partially_shipped
        - shipped
        - partially_returned
        - returned
        - canceled
        - requires_action
        explode: false
        in: query
        items: null
        name: fulfillment_status
        schema: null
        style: form
        type: string
      - description: Payment status to search for.
        enum:
        - not_paid
        - awaiting
        - captured
        - partially_refunded
        - refunded
        - canceled
        - requires_action
        explode: false
        in: query
        items: null
        name: payment_status
        schema: null
        style: form
        type: string
      - (query) display_id {string} Filter by display ID.
      - (query) cart_id {string} Filter by cart ID.
      - (query) email {string} Filter by email.
      - (query) region_id {string} Filter by region ID.
      - description: See a list of codes.
        explode: false
        externalDocs: null
        in: query
        name: currency_code
        schema: null
        style: form
        type: string
        url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
      - (query) tax_rate {string} Filter by tax rate.
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: canceled_at
        properties: null
        schema: null
        type: string
      - (query) limit=10 {integer} Limit the number of orders returned.
      - (query) offset=0 {integer} The number of orders to skip when retrieving the
        orders.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned orders.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned orders.
  /store/customers/me/payment-methods:
    get:
      operationId: GetCustomersCustomerPaymentMethods
      summary: Get Saved Payment Methods
      description: Retrieve the logged-in customer's saved payment methods. This API
        Route only works with payment providers created with the deprecated Payment
        Service interface. The payment methods are saved using the Payment Service's
        third-party service, and not on the Medusa backend. So, they're retrieved
        from the third-party service.
      x-authenticated: true
      x-codegen:
        method: listPaymentMethods
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged
          medusa.customers.paymentMethods.list()
          .then(({ payment_methods }) => {
          console.log(payment_methods.length);
          })
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/customers/me/payment-methods' \
          -H 'Authorization: Bearer {access_token}'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Customers
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCustomersListPaymentMethodsRes'
          description: OK
      deprecated: true
  /store/customers/password-reset:
    post:
      operationId: PostCustomersResetPassword
      summary: Reset Password
      description: Reset a Customer's password using a password token created by a
        previous request to the Request Password Reset API Route. If the password
        token expired, you must create a new one.
      x-codegen:
        method: resetPassword
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.customers.resetPassword({
          email: "user@example.com",
          password: "supersecret",
          token: "supersecrettoken"
          })
          .then(({ customer }) => {
          console.log(customer.id);
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/customers/password-reset' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com",
          "password": "supersecret",
          "token": "supersecrettoken"
          }'
      tags:
      - Customers
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCustomersResetPasswordRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ResetPasswordRequest'
      externalDocs:
        description: How to reset password
        url: https://docs.medusajs.com/modules/customers/storefront/implement-customer-profiles#reset-password
  /store/customers/password-token:
    post:
      operationId: PostCustomersCustomerPasswordToken
      summary: Request Password Reset
      description: Create a reset password token to be used in a subsequent Reset
        Password API Route. This emits the event `customer.password_reset`. If a notification
        provider is installed in the Medusa backend and is configured to handle this
        event, a notification to the customer, such as an email, may be sent with
        reset instructions.
      x-codegen:
        method: generatePasswordToken
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.customers.generatePasswordToken({
          email: "user@example.com"
          })
          .then(() => {
          // successful
          })
          .catch(() => {
          // failed
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/customers/password-token' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "email": "user@example.com"
          }'
      tags:
      - Customers
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        Ì:
          content: {}
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ResetPasswordTokenRequest'
      externalDocs:
        description: How to reset password
        url: https://docs.medusajs.com/modules/customers/storefront/implement-customer-profiles#reset-password
  /store/gift-cards/{code}:
    get:
      operationId: GetGiftCardsCode
      summary: Get Gift Card by Code
      description: Retrieve a Gift Card's details by its associated unique code.
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.giftCards.retrieve(code)
          .then(({ gift_card }) => {
          console.log(gift_card.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useGiftCard } from "medusa-react"
          type Props = {
          giftCardCode: string
          }
          const GiftCard = ({ giftCardCode }: Props) => {
          const { gift_card, isLoading, isError } = useGiftCard(
          giftCardCode
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {gift_card && <span>{gift_card.value}</span>}
          {isError && <span>Gift Card does not exist</span>}
          </div>
          )
          }
          export default GiftCard
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/gift-cards/{code}'
      tags:
      - Gift Cards
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreGiftCardsRes'
          description: OK
      parameters:
      - (path) code=* {string} The unique Gift Card code.
  /store/order-edits/{id}:
    get:
      operationId: GetOrderEditsOrderEdit
      summary: Retrieve an Order Edit
      description: Retrieve an Order Edit's details.
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.orderEdits.retrieve(orderEditId)
          .then(({ order_edit }) => {
          console.log(order_edit.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useOrderEdit } from "medusa-react"
          type Props = {
          orderEditId: string
          }
          const OrderEdit = ({ orderEditId }: Props) => {
          const { order_edit, isLoading } = useOrderEdit(orderEditId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {order_edit && (
          <ul>
          {order_edit.changes.map((change) => (
          <li key={change.id}>{change.type}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default OrderEdit
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/order-edits/{id}'
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreOrderEditsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the OrderEdit.
  /store/order-edits/{id}/complete:
    post:
      operationId: PostOrderEditsOrderEditComplete
      summary: Complete an Order Edit
      description: Complete an Order Edit and reflect its changes on the original
        order. Any additional payment required must be authorized first using the
        Payment Collection API Routes.
      x-codegen:
        method: complete
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.orderEdits.complete(orderEditId)
          .then(({ order_edit }) => {
          console.log(order_edit.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCompleteOrderEdit } from "medusa-react"
          type Props = {
          orderEditId: string
          }
          const OrderEdit = ({ orderEditId }: Props) => {
          const completeOrderEdit = useCompleteOrderEdit(
          orderEditId
          )
          // ...
          const handleCompleteOrderEdit = () => {
          completeOrderEdit.mutate(void 0, {
          onSuccess: ({ order_edit }) => {
          console.log(order_edit.confirmed_at)
          }
          })
          }
          // ...
          }
          export default OrderEdit
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/order-edits/{id}/complete'
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreOrderEditsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order Edit.
      externalDocs:
        description: How to handle order edits in a storefront
        url: https://docs.medusajs.com/modules/orders/storefront/handle-order-edits
  /store/order-edits/{id}/decline:
    post:
      operationId: PostOrderEditsOrderEditDecline
      summary: Decline an Order Edit
      description: Decline an Order Edit. The changes are not reflected on the original
        order.
      x-codegen:
        method: decline
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.orderEdits.decline(orderEditId)
          .then(({ order_edit }) => {
          console.log(order_edit.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useDeclineOrderEdit } from "medusa-react"
          type Props = {
          orderEditId: string
          }
          const OrderEdit = ({ orderEditId }: Props) => {
          const declineOrderEdit = useDeclineOrderEdit(orderEditId)
          // ...
          const handleDeclineOrderEdit = (
          declinedReason: string
          ) => {
          declineOrderEdit.mutate({
          declined_reason: declinedReason,
          }, {
          onSuccess: ({ order_edit }) => {
          console.log(order_edit.declined_at)
          }
          })
          }
          // ...
          }
          export default OrderEdit
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/order-edits/{id}/decline'
      tags:
      - Order Edits
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreOrderEditsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the OrderEdit.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostOrderEditsOrderEditDecline'
  /store/orders:
    get:
      operationId: GetOrders
      summary: Look Up an Order
      description: Look up an order using filters. If the filters don't narrow down
        the results to a single order, a 404 response is returned with no orders.
      x-codegen:
        method: lookupOrder
        queryParams: StoreGetOrdersParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.orders.lookupOrder({
          display_id: 1,
          email: "user@example.com"
          })
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useOrders } from "medusa-react"
          type Props = {
          displayId: number
          email: string
          }
          const Order = ({
          displayId,
          email
          }: Props) => {
          const {
          order,
          isLoading,
          } = useOrders({
          display_id: displayId,
          email,
          })
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {order && <span>{order.display_id}</span>}
          </div>
          )
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/orders?display_id=1&email=user@example.com'
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreOrdersRes'
          description: OK
      parameters:
      - (query) display_id=* {number} Filter by ID.
      - (query) fields {string} Comma-separated fields that should be expanded in
        the returned order.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned order.
      - description: Filter by email.
        explode: false
        format: email
        in: query
        name: email
        required: true
        schema: null
        style: form
        type: string
      - description: The postal code of the shipping address
        explode: false
        in: query
        name: shipping_address
        postal_code: null
        properties: null
        schema: null
        style: form
        type: string
  /store/orders/{id}:
    get:
      operationId: GetOrdersOrder
      summary: Get an Order
      description: Retrieve an Order's details.
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.orders.retrieve(orderId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useOrder } from "medusa-react"
          type Props = {
          orderId: string
          }
          const Order = ({ orderId }: Props) => {
          const {
          order,
          isLoading,
          } = useOrder(orderId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {order && <span>{order.display_id}</span>}
          </div>
          )
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/orders/{id}'
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreOrdersRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Order.
      - (query) fields {string} Comma-separated fields that should be expanded in
        the returned order.
      - (query) expand {string} Comma-separated relations that should be included
        in the returned order.
  /store/orders/batch/customer/token:
    post:
      operationId: PostOrdersCustomerOrderClaim
      summary: Claim Order
      description: Allow the logged-in customer to claim ownership of one or more
        orders. This generates a token that can be used later on to verify the claim
        using the Verify Order Claim API Route. This also emits the event `order-update-token.created`.
        So, if you have a notification provider installed that handles this event
        and sends the customer a notification, such as an email, the customer should
        receive instructions on how to finalize their claim ownership.
      x-authenticated: true
      x-codegen:
        method: requestCustomerOrders
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.orders.requestCustomerOrders({
          order_ids,
          })
          .then(() => {
          // successful
          })
          .catch(() => {
          // an error occurred
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useRequestOrderAccess } from "medusa-react"
          const ClaimOrder = () => {
          const claimOrder = useRequestOrderAccess()
          const handleClaimOrder = (
          orderIds: string[]
          ) => {
          claimOrder.mutate({
          order_ids: orderIds
          }, {
          onSuccess: () => {
          // successful
          },
          onError: () => {
          // an error occurred.
          }
          })
          }
          // ...
          }
          export default ClaimOrder
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/batch/customer/token' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "order_ids": ["id"],
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content: {}
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostCustomersCustomerOrderClaimReq'
      externalDocs:
        description: How to implement claim-order flow in a storefront
        url: https://docs.medusajs.com/modules/orders/storefront/implement-claim-order
  /store/orders/cart/{cart_id}:
    get:
      operationId: GetOrdersOrderCartId
      summary: Get by Cart ID
      description: Retrieve an Order's details by the ID of the Cart that was used
        to create the Order.
      x-codegen:
        method: retrieveByCartId
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.orders.retrieveByCartId(cartId)
          .then(({ order }) => {
          console.log(order.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCartOrder } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Order = ({ cartId }: Props) => {
          const {
          order,
          isLoading,
          } = useCartOrder(cartId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {order && <span>{order.display_id}</span>}
          </div>
          )
          }
          export default Order
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/orders/cart/{cart_id}'
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreOrdersRes'
          description: OK
      parameters:
      - (path) cart_id=* {string} The ID of Cart.
  /store/orders/customer/confirm:
    post:
      operationId: PostOrdersCustomerOrderClaimsCustomerOrderClaimAccept
      summary: Verify Order Claim
      description: Verify the claim order token provided to the customer when they
        request ownership of an order.
      x-codegen:
        method: confirmRequest
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.orders.confirmRequest(
          token,
          )
          .then(() => {
          // successful
          })
          .catch(() => {
          // an error occurred
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useGrantOrderAccess } from "medusa-react"
          const ClaimOrder = () => {
          const confirmOrderRequest = useGrantOrderAccess()
          const handleOrderRequestConfirmation = (
          token: string
          ) => {
          confirmOrderRequest.mutate({
          token
          }, {
          onSuccess: () => {
          // successful
          },
          onError: () => {
          // an error occurred.
          }
          })
          }
          // ...
          }
          export default ClaimOrder
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/orders/customer/confirm' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "token": "{token}",
          }'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Orders
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content: {}
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostCustomersCustomerAcceptClaimReq'
      externalDocs:
        description: How to implement claim-order flow in a storefront
        url: https://docs.medusajs.com/modules/orders/storefront/implement-claim-order
  /store/payment-collections/{id}:
    get:
      operationId: GetPaymentCollectionsPaymentCollection
      summary: Get a PaymentCollection
      description: Retrieve a Payment Collection's details.
      x-codegen:
        method: retrieve
        queryParams: StoreGetPaymentCollectionsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.paymentCollections.retrieve(paymentCollectionId)
          .then(({ payment_collection }) => {
          console.log(payment_collection.id)
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { usePaymentCollection } from "medusa-react"
          type Props = {
          paymentCollectionId: string
          }
          const PaymentCollection = ({
          paymentCollectionId
          }: Props) => {
          const {
          payment_collection,
          isLoading
          } = usePaymentCollection(
          paymentCollectionId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {payment_collection && (
          <span>{payment_collection.status}</span>
          )}
          </div>
          )
          }
          export default PaymentCollection
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/payment-collections/{id}'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payment Collections
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StorePaymentCollectionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the PaymentCollection.
      - (query) fields {string} Comma-separated fields that should be expanded in
        the returned payment collection.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned payment collection.
  /store/payment-collections/{id}/sessions:
    post:
      operationId: PostPaymentCollectionsSessions
      summary: Create a Payment Session
      description: Create a Payment Session for a payment provider in a Payment Collection.
      x-codegen:
        method: managePaymentSession
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.paymentCollections.managePaymentSession(payment_id, { provider_id: "stripe" })
          .then(({ payment_collection }) => {
          console.log(payment_collection.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useManagePaymentSession } from "medusa-react"
          type Props = {
          paymentCollectionId: string
          }
          const PaymentCollection = ({
          paymentCollectionId
          }: Props) => {
          const managePaymentSession = useManagePaymentSession(
          paymentCollectionId
          )
          const handleManagePaymentSession = (
          providerId: string
          ) => {
          managePaymentSession.mutate({
          provider_id: providerId
          }, {
          onSuccess: ({ payment_collection }) => {
          console.log(payment_collection.payment_sessions)
          }
          })
          }
          // ...
          }
          export default PaymentCollection
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/payment-collections/{id}/sessions' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "provider_id": "stripe"
          }'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payment Collections
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StorePaymentCollectionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Payment Collection.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostCartsCartPaymentSessionReq'
  /store/payment-collections/{id}/sessions/{session_id}:
    post:
      operationId: PostPaymentCollectionsPaymentCollectionPaymentSessionsSession
      summary: Refresh a Payment Session
      description: Refresh a Payment Session's data to ensure that it is in sync with
        the Payment Collection.
      x-codegen:
        method: refreshPaymentSession
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.paymentCollections.refreshPaymentSession(paymentCollectionId, sessionId)
          .then(({ payment_session }) => {
          console.log(payment_session.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { usePaymentCollectionRefreshPaymentSession } from "medusa-react"
          type Props = {
          paymentCollectionId: string
          }
          const PaymentCollection = ({
          paymentCollectionId
          }: Props) => {
          const refreshPaymentSession = usePaymentCollectionRefreshPaymentSession(
          paymentCollectionId
          )
          // ...
          const handleRefreshPaymentSession = (paymentSessionId: string) => {
          refreshPaymentSession.mutate(paymentSessionId, {
          onSuccess: ({ payment_session }) => {
          console.log(payment_session.status)
          }
          })
          }
          // ...
          }
          export default PaymentCollection
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/payment-collections/{id}/sessions/{session_id}'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payment Collections
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StorePaymentCollectionsSessionRes'
          description: OK
      parameters:
      - (path) id=* {string} The id of the PaymentCollection.
      - (path) session_id=* {string} The id of the Payment Session to be refreshed.
  /store/payment-collections/{id}/sessions/{session_id}/authorize:
    post:
      operationId: PostPaymentCollectionsSessionsSessionAuthorize
      summary: Authorize Payment Session
      description: Authorize a Payment Session of a Payment Collection.
      x-codegen:
        method: authorizePaymentSession
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.paymentCollections.authorize(paymentId, sessionId)
          .then(({ payment_collection }) => {
          console.log(payment_collection.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAuthorizePaymentSession } from "medusa-react"
          type Props = {
          paymentCollectionId: string
          }
          const PaymentCollection = ({
          paymentCollectionId
          }: Props) => {
          const authorizePaymentSession = useAuthorizePaymentSession(
          paymentCollectionId
          )
          // ...
          const handleAuthorizePayment = (paymentSessionId: string) => {
          authorizePaymentSession.mutate(paymentSessionId, {
          onSuccess: ({ payment_collection }) => {
          console.log(payment_collection.payment_sessions)
          }
          })
          }
          // ...
          }
          export default PaymentCollection
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/payment-collections/{id}/sessions/{session_id}/authorize'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payment Collections
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StorePaymentCollectionsSessionRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Payment Collection.
      - (path) session_id=* {string} The ID of the Payment Session.
  /store/payment-collections/{id}/sessions/batch:
    post:
      operationId: PostPaymentCollectionsPaymentCollectionSessionsBatch
      summary: Manage Payment Sessions
      description: Create, update, or delete a list of payment sessions of a Payment
        Collections. If a payment session is not provided in the `sessions` array,
        it's deleted.
      x-codegen:
        method: managePaymentSessionsBatch
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          // Total amount = 10000
          // Example 1: Adding two new sessions
          medusa.paymentCollections.managePaymentSessionsBatch(paymentId, {
          sessions: [
          {
          provider_id: "stripe",
          amount: 5000,
          },
          {
          provider_id: "manual",
          amount: 5000,
          },
          ]
          })
          .then(({ payment_collection }) => {
          console.log(payment_collection.id);
          })
          // Example 2: Updating one session and removing the other
          medusa.paymentCollections.managePaymentSessionsBatch(paymentId, {
          sessions: [
          {
          provider_id: "stripe",
          amount: 10000,
          session_id: "ps_123456"
          },
          ]
          })
          .then(({ payment_collection }) => {
          console.log(payment_collection.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useManageMultiplePaymentSessions } from "medusa-react"
          type Props = {
          paymentCollectionId: string
          }
          const PaymentCollection = ({
          paymentCollectionId
          }: Props) => {
          const managePaymentSessions = useManageMultiplePaymentSessions(
          paymentCollectionId
          )
          const handleManagePaymentSessions = () => {
          // Total amount = 10000
          // Example 1: Adding two new sessions
          managePaymentSessions.mutate({
          sessions: [
          {
          provider_id: "stripe",
          amount: 5000,
          },
          {
          provider_id: "manual",
          amount: 5000,
          },
          ]
          }, {
          onSuccess: ({ payment_collection }) => {
          console.log(payment_collection.payment_sessions)
          }
          })
          // Example 2: Updating one session and removing the other
          managePaymentSessions.mutate({
          sessions: [
          {
          provider_id: "stripe",
          amount: 10000,
          session_id: "ps_123456"
          },
          ]
          }, {
          onSuccess: ({ payment_collection }) => {
          console.log(payment_collection.payment_sessions)
          }
          })
          }
          // ...
          }
          export default PaymentCollection
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/payment-collections/{id}/sessions/batch' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "sessions": [
          {
          "provider_id": "stripe",
          "amount": 5000
          },
          {
          "provider_id": "manual",
          "amount": 5000
          }
          ]
          }'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payment Collections
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StorePaymentCollectionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Payment Collection.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostPaymentCollectionsBatchSessionsReq'
  /store/payment-collections/{id}/sessions/batch/authorize:
    post:
      operationId: PostPaymentCollectionsSessionsBatchAuthorize
      summary: Authorize Payment Sessions
      description: Authorize the Payment Sessions of a Payment Collection.
      x-codegen:
        method: authorizePaymentSessionsBatch
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.paymentCollections.authorize(paymentId)
          .then(({ payment_collection }) => {
          console.log(payment_collection.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useAuthorizePaymentSessionsBatch } from "medusa-react"
          type Props = {
          paymentCollectionId: string
          }
          const PaymentCollection = ({
          paymentCollectionId
          }: Props) => {
          const authorizePaymentSessions = useAuthorizePaymentSessionsBatch(
          paymentCollectionId
          )
          // ...
          const handleAuthorizePayments = (paymentSessionIds: string[]) => {
          authorizePaymentSessions.mutate({
          session_ids: paymentSessionIds
          }, {
          onSuccess: ({ payment_collection }) => {
          console.log(payment_collection.payment_sessions)
          }
          })
          }
          // ...
          }
          export default PaymentCollection
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/payment-collections/{id}/sessions/batch/authorize'
      security:
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Payment Collections
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StorePaymentCollectionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Payment Collections.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostPaymentCollectionsBatchSessionsAuthorizeReq'
  /store/product-categories:
    get:
      operationId: GetProductCategories
      summary: List Product Categories
      description: Retrieve a list of product categories. The product categories can
        be filtered by fields such as `handle` or `q`. The product categories can
        also be paginated. This API Route can also be used to retrieve a product category
        by its handle.
      x-codegen:
        method: list
        queryParams: StoreGetProductCategoriesParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.productCategories.list()
          .then(({ product_categories, limit, offset, count }) => {
          console.log(product_categories.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useProductCategories } from "medusa-react"
          function Categories() {
          const {
          product_categories,
          isLoading,
          } = useProductCategories()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {product_categories && !product_categories.length && (
          <span>No Categories</span>
          )}
          {product_categories && product_categories.length > 0 && (
          <ul>
          {product_categories.map(
          (category) => (
          <li key={category.id}>{category.name}</li>
          )
          )}
          </ul>
          )}
          </div>
          )
          }
          export default Categories
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/product-categories' \
          -H 'x-medusa-access-token: {api_token}'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Categories
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreGetProductCategoriesRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (query) q {string} term used to search product category's names and handles.
      - (query) handle {string} Filter by handle.
      - (query) parent_category_id {string} Filter by the ID of a parent category.
        Only children of the provided parent category are retrieved.
      - (query) include_descendants_tree {boolean} Whether all nested categories inside
        a category should be retrieved.
      - (query) offset=0 {integer} The number of product categories to skip when retrieving
        the product categories.
      - (query) limit=100 {integer} Limit the number of product categories returned.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned product categories.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned product categories.
      externalDocs:
        description: How to retrieve a product category by its handle
        url: https://docs.medusajs.com/modules/products/storefront/use-categories#get-a-category-by-its-handle
  /store/product-categories/{id}:
    get:
      operationId: GetProductCategoriesCategory
      summary: Get a Product Category
      description: Retrieve a Product Category's details.
      x-codegen:
        method: retrieve
        queryParams: StoreGetProductCategoriesCategoryParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.productCategories.retrieve(productCategoryId)
          .then(({ product_category }) => {
          console.log(product_category.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useProductCategory } from "medusa-react"
          type Props = {
          categoryId: string
          }
          const Category = ({ categoryId }: Props) => {
          const { product_category, isLoading } = useProductCategory(
          categoryId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {product_category && <span>{product_category.name}</span>}
          </div>
          )
          }
          export default Category
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/product-categories/{id}' \
          -H 'x-medusa-access-token: {api_token}'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Categories
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreGetProductCategoriesCategoryRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (path) id=* {string} The ID of the Product Category
      - (query) fields {string} Comma-separated fields that should be expanded in
        the returned product category.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned product category.
  /store/product-tags:
    get:
      operationId: GetProductTags
      summary: List Product Tags
      description: Retrieve a list of product tags. The product tags can be filtered
        by fields such as `id` or `q`. The product tags can also be sorted or paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: StoreGetProductTagsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.productTags.list()
          .then(({ product_tags }) => {
          console.log(product_tags.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useProductTags } from "medusa-react"
          function Tags() {
          const {
          product_tags,
          isLoading,
          } = useProductTags()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {product_tags && !product_tags.length && (
          <span>No Product Tags</span>
          )}
          {product_tags && product_tags.length > 0 && (
          <ul>
          {product_tags.map(
          (tag) => (
          <li key={tag.id}>{tag.value}</li>
          )
          )}
          </ul>
          )}
          </div>
          )
          }
          export default Tags
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/product-tags'
      tags:
      - Product Tags
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreProductTagsListRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (query) limit=20 {integer} Limit the number of product tags returned.
      - (query) offset=0 {integer} The number of product tags to skip when retrieving
        the product tags.
      - (query) order {string} A product-tag field to sort-order the retrieved product
        tags by.
      - (query) discount_condition_id {string} Filter by the ID of a discount condition.
        When provided, only tags that the discount condition applies for will be retrieved.
      - description: Filter by tag values.
        explode: false
        in: query
        items: null
        name: value
        schema: null
        style: form
        type: string
      - description: Filter by IDs.
        explode: false
        in: query
        items: null
        name: id
        schema: null
        style: form
        type: string
      - (query) q {string} term to search product tag's value.
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
  /store/product-types:
    get:
      operationId: GetProductTypes
      summary: List Product Types
      description: Retrieve a list of product types. The product types can be filtered
        by fields such as `value` or `q`. The product types can also be sorted or
        paginated.
      x-authenticated: true
      x-codegen:
        method: list
        queryParams: StoreGetProductTypesParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.productTypes.list()
          .then(({ product_types }) => {
          console.log(product_types.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useProductTypes } from "medusa-react"
          function Types() {
          const {
          product_types,
          isLoading,
          } = useProductTypes()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {product_types && !product_types.length && (
          <span>No Product Types</span>
          )}
          {product_types && product_types.length > 0 && (
          <ul>
          {product_types.map(
          (type) => (
          <li key={type.id}>{type.value}</li>
          )
          )}
          </ul>
          )}
          </div>
          )
          }
          export default Types
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/product-types'
      security:
      - api_token: []
      - cookie_auth: []
      - jwt_token: []
      tags:
      - Product Types
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreProductTypesListRes'
          description: OK
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "401":
          content: {}
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
      parameters:
      - (query) limit=20 {integer} Limit the number of product types returned.
      - (query) offset=0 {integer} The number of product types to skip when retrieving
        the product types.
      - (query) order {string} A product-type field to sort-order the retrieved product
        types by.
      - (query) discount_condition_id {string} Filter by the ID of a discount condition.
        When provided, only types that the discount condition applies for will be
        retrieved.
      - description: Filter by type values.
        explode: false
        in: query
        items: null
        name: value
        schema: null
        style: form
        type: string
      - description: Filter by IDs.
        explode: false
        in: query
        items: null
        name: id
        schema: null
        style: form
        type: string
      - (query) q {string} term to search product type's value.
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
  /store/products:
    get:
      operationId: GetProducts
      summary: List Products
      description: |
        Retrieves a list of products. The products can be filtered by fields such as `id` or `q`. The products can also be sorted or paginated.
        This API Route can also be used to retrieve a product by its handle.
        For accurate and correct pricing of the products based on the customer's context, it's highly recommended to pass fields such as
        `region_id`, `currency_code`, and `cart_id` when available.
        Passing `sales_channel_id` ensures retrieving only products available in the specified sales channel.
        You can alternatively use a publishable API key in the request header instead of passing a `sales_channel_id`.
      x-codegen:
        method: list
        queryParams: StoreGetProductsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.products.list()
          .then(({ products, limit, offset, count }) => {
          console.log(products.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useProducts } from "medusa-react"
          const Products = () => {
          const { products, isLoading } = useProducts()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {products && !products.length && <span>No Products</span>}
          {products && products.length > 0 && (
          <ul>
          {products.map((product) => (
          <li key={product.id}>{product.title}</li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Products
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/products'
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreProductsListRes'
          description: OK
      parameters:
      - (query) q {string} term used to search products' title, description, variant's
        title, variant's sku, and collection's title.
      - description: Filter by IDs.
        explode: false
        in: query
        name: id
        oneOf: null
        schema: null
        style: form
      - type: string
      - items: null
        type: string
      - description: Filter by sales channel IDs. When provided, only products available
          in the selected sales channels are retrieved. Alternatively, you can pass
          a publishable API key in the request header and this will have the same
          effect.
        explode: false
        in: query
        items: null
        name: sales_channel_id
        schema: null
        style: form
        type: string
      - description: Filter by product collection IDs. When provided, only products
          that belong to the specified product collections are retrieved.
        explode: false
        in: query
        items: null
        name: collection_id
        schema: null
        style: form
        type: string
      - description: Filter by product type IDs. When provided, only products that
          belong to the specified product types are retrieved.
        explode: false
        in: query
        items: null
        name: type_id
        schema: null
        style: form
        type: string
      - description: Filter by product tag IDs. When provided, only products that
          belong to the specified product tags are retrieved.
        explode: false
        in: query
        items: null
        name: tags
        schema: null
        style: form
        type: string
      - (query) title {string} Filter by title.
      - (query) description {string} Filter by description
      - (query) handle {string} Filter by handle.
      - (query) is_giftcard {boolean} Whether to retrieve regular products or gift-card
        products.
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      - description: Filter by product category IDs. When provided, only products
          that belong to the specified product categories are retrieved.
        explode: false
        in: query
        items: null
        name: category_id
        schema: null
        style: form
        type: string
        x-featureFlag: product_categories
      - description: Whether to include child product categories when filtering using
          the `category_id` field.
        explode: false
        in: query
        name: include_category_children
        schema: null
        style: form
        type: boolean
        x-featureFlag: product_categories
      - (query) offset=0 {integer} The number of products to skip when retrieving
        the products.
      - (query) limit=100 {integer} Limit the number of products returned.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned products.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned products.
      - (query) order {string} A product field to sort-order the retrieved products
        by.
      - (query) cart_id {string} The ID of the cart. This is useful for accurate pricing
        based on the cart's context.
      - (query) region_id {string} The ID of the region. This is useful for accurate
        pricing based on the selected region.
      - description: See a list of codes.
        explode: false
        externalDocs: null
        in: query
        name: currency_code
        schema: null
        style: form
        type: string
        url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
      externalDocs:
        description: How to retrieve a product by its handle
        url: https://docs.medusajs.com/modules/products/storefront/show-products#retrieve-product-by-handle
  /store/products/{id}:
    get:
      operationId: GetProductsProduct
      summary: Get a Product
      description: |
        Retrieve a Product's details. For accurate and correct pricing of the product based on the customer's context, it's highly recommended to pass fields such as
        `region_id`, `currency_code`, and `cart_id` when available.
        Passing `sales_channel_id` ensures retrieving only products available in the current sales channel.
        You can alternatively use a publishable API key in the request header instead of passing a `sales_channel_id`.
      x-codegen:
        method: retrieve
        queryParams: StoreGetProductsProductParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.products.retrieve(productId)
          .then(({ product }) => {
          console.log(product.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useProduct } from "medusa-react"
          type Props = {
          productId: string
          }
          const Product = ({ productId }: Props) => {
          const { product, isLoading } = useProduct(productId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {product && <span>{product.title}</span>}
          </div>
          )
          }
          export default Product
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/products/{id}'
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreProductsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product.
      - (query) sales_channel_id {string} The ID of the sales channel the customer
        is viewing the product from.
      - (query) cart_id {string} The ID of the cart. This is useful for accurate pricing
        based on the cart's context.
      - (query) region_id {string} The ID of the region. This is useful for accurate
        pricing based on the selected region.
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned product.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned product.
      - description: See a list of codes.
        explode: false
        externalDocs: null
        in: query
        name: currency_code
        schema: null
        style: form
        type: string
        url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
      externalDocs:
        description: How to pass product pricing parameters
        url: https://docs.medusajs.com/modules/products/storefront/show-products#product-pricing-parameters
  /store/products/search:
    post:
      operationId: PostProductsSearch
      summary: Search Products
      description: Run a search query on products using the search service installed
        on the Medusa backend. The searching is handled through the search service,
        so the returned data's format depends on the search service you're using.
      x-codegen:
        method: search
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.products.search({
          q: "Shirt"
          })
          .then(({ hits }) => {
          console.log(hits.length);
          })
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/products/search' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "q": "Shirt"
          }'
      tags:
      - Products
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StorePostSearchRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostSearchReq'
  /store/regions:
    get:
      operationId: GetRegions
      summary: List Regions
      description: Retrieve a list of regions. The regions can be filtered by fields
        such as `created_at`. The regions can also be paginated. This API Route is
        useful to show the customer all available regions to choose from.
      x-codegen:
        method: list
        queryParams: StoreGetRegionsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.regions.list()
          .then(({ regions, count, limit, offset }) => {
          console.log(regions.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useRegions } from "medusa-react"
          const Regions = () => {
          const { regions, isLoading } = useRegions()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {regions?.length && (
          <ul>
          {regions.map((region) => (
          <li key={region.id}>
          {region.name}
          </li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default Regions
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/regions'
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreRegionsListRes'
          description: OK
      parameters:
      - (query) offset=0 {integer} The number of regions to skip when retrieving the
        regions.
      - (query) limit=100 {integer} Limit the number of regions returned.
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: created_at
        properties: null
        schema: null
        type: string
      - description: filter by dates greater than or equal to this date
        format: date
        gt: null
        gte: null
        in: query
        lt: null
        lte: null
        name: updated_at
        properties: null
        schema: null
        type: string
      externalDocs:
        description: How to use regions in a storefront
        url: https://docs.medusajs.com/modules/regions-and-currencies/storefront/use-regions
  /store/regions/{id}:
    get:
      operationId: GetRegionsRegion
      summary: Get a Region
      description: Retrieve a Region's details.
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.regions.retrieve(regionId)
          .then(({ region }) => {
          console.log(region.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useRegion } from "medusa-react"
          type Props = {
          regionId: string
          }
          const Region = ({ regionId }: Props) => {
          const { region, isLoading } = useRegion(
          regionId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {region && <span>{region.name}</span>}
          </div>
          )
          }
          export default Region
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/regions/{id}'
      tags:
      - Regions
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreRegionsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Region.
  /store/return-reasons:
    get:
      operationId: GetReturnReasons
      summary: List Return Reasons
      description: Retrieve a list of Return Reasons. This is useful when implementing
        a Create Return flow in the storefront.
      x-codegen:
        method: list
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.returnReasons.list()
          .then(({ return_reasons }) => {
          console.log(return_reasons.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useReturnReasons } from "medusa-react"
          const ReturnReasons = () => {
          const {
          return_reasons,
          isLoading
          } = useReturnReasons()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {return_reasons?.length && (
          <ul>
          {return_reasons.map((returnReason) => (
          <li key={returnReason.id}>
          {returnReason.label}
          </li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default ReturnReasons
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/return-reasons'
      tags:
      - Return Reasons
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreReturnReasonsListRes'
          description: OK
  /store/return-reasons/{id}:
    get:
      operationId: GetReturnReasonsReason
      summary: Get a Return Reason
      description: Retrieve a Return Reason's details.
      x-codegen:
        method: retrieve
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.returnReasons.retrieve(reasonId)
          .then(({ return_reason }) => {
          console.log(return_reason.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useReturnReason } from "medusa-react"
          type Props = {
          returnReasonId: string
          }
          const ReturnReason = ({ returnReasonId }: Props) => {
          const {
          return_reason,
          isLoading
          } = useReturnReason(
          returnReasonId
          )
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {return_reason && <span>{return_reason.label}</span>}
          </div>
          )
          }
          export default ReturnReason
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/return-reasons/{id}'
      tags:
      - Return Reasons
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreReturnReasonsRes'
          description: OK
      parameters:
      - (path) id=* {string} The id of the Return Reason.
  /store/returns:
    post:
      operationId: PostReturns
      summary: Create Return
      description: Create a Return for an Order. If a return shipping method is specified,
        the return is automatically fulfilled.
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.returns.create({
          order_id,
          items: [
          {
          item_id,
          quantity: 1
          }
          ]
          })
          .then((data) => {
          console.log(data.return.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCreateReturn } from "medusa-react"
          type CreateReturnData = {
          items: {
          item_id: string,
          quantity: number
          }[]
          return_shipping: {
          option_id: string
          }
          }
          type Props = {
          orderId: string
          }
          const CreateReturn = ({ orderId }: Props) => {
          const createReturn = useCreateReturn()
          // ...
          const handleCreate = (data: CreateReturnData) => {
          createReturn.mutate({
          ...data,
          order_id: orderId
          }, {
          onSuccess: ({ return: returnData }) => {
          console.log(returnData.id)
          }
          })
          }
          // ...
          }
          export default CreateReturn
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/returns' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "order_id": "asfasf",
          "items": [
          {
          "item_id": "assfasf",
          "quantity": 1
          }
          ]
          }'
      tags:
      - Returns
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreReturnsRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostReturnsReq'
      externalDocs:
        description: How to create a return in a storefront
        url: https://docs.medusajs.com/modules/orders/storefront/create-return
  /store/shipping-options:
    get:
      operationId: GetShippingOptions
      summary: Get Shipping Options
      description: Retrieve a list of Shipping Options.
      x-codegen:
        method: list
        queryParams: StoreGetShippingOptionsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.shippingOptions.list()
          .then(({ shipping_options }) => {
          console.log(shipping_options.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useShippingOptions } from "medusa-react"
          const ShippingOptions = () => {
          const {
          shipping_options,
          isLoading,
          } = useShippingOptions()
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {shipping_options?.length &&
          shipping_options?.length > 0 && (
          <ul>
          {shipping_options?.map((shipping_option) => (
          <li key={shipping_option.id}>
          {shipping_option.id}
          </li>
          ))}
          </ul>
          )}
          </div>
          )
          }
          export default ShippingOptions
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/shipping-options'
      tags:
      - Shipping Options
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreShippingOptionsListRes'
          description: OK
      parameters:
      - (query) is_return {boolean} Whether return shipping options should be included.
        By default, all shipping options are returned.
      - (query) product_ids {string} "Comma-separated list of Product IDs to filter
        Shipping Options by. If provided, only shipping options that can be used with
        the provided products are retrieved."
      - (query) region_id {string} "The ID of the region that the shipping options
        belong to. If not provided, all shipping options are retrieved."
  /store/shipping-options/{cart_id}:
    get:
      operationId: GetShippingOptionsCartId
      summary: List for Cart
      description: Retrieve a list of Shipping Options available for a cart.
      x-codegen:
        method: listCartOptions
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.shippingOptions.listCartOptions(cartId)
          .then(({ shipping_options }) => {
          console.log(shipping_options.length);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCartShippingOptions } from "medusa-react"
          type Props = {
          cartId: string
          }
          const ShippingOptions = ({ cartId }: Props) => {
          const { shipping_options, isLoading } =
          useCartShippingOptions(cartId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {shipping_options && !shipping_options.length && (
          <span>No shipping options</span>
          )}
          {shipping_options && (
          <ul>
          {shipping_options.map(
          (shipping_option) => (
          <li key={shipping_option.id}>
          {shipping_option.name}
          </li>
          )
          )}
          </ul>
          )}
          </div>
          )
          }
          export default ShippingOptions
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/shipping-options/{cart_id}'
      tags:
      - Shipping Options
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreCartShippingOptionsListRes'
          description: OK
      parameters:
      - (path) cart_id {string} The ID of the Cart.
      externalDocs:
        description: How to implement shipping step in checkout
        url: https://docs.medusajs.com/modules/carts-and-checkout/storefront/implement-checkout-flow#shipping-step
  /store/swaps:
    post:
      operationId: PostSwaps
      summary: Create a Swap
      description: |
        Create a Swap for an Order. This will also create a return and associate it with the swap. If a return shipping option is specified, the return will automatically be fulfilled.
        To complete the swap, you must use the Complete Cart API Route passing it the ID of the swap's cart.
        An idempotency key will be generated if none is provided in the header `Idempotency-Key` and added to
        the response. If an error occurs during swap creation or the request is interrupted for any reason, the swap creation can be retried by passing the idempotency
        key in the `Idempotency-Key` header.
      x-codegen:
        method: create
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.swaps.create({
          order_id,
          return_items: [
          {
          item_id,
          quantity: 1
          }
          ],
          additional_items: [
          {
          variant_id,
          quantity: 1
          }
          ]
          })
          .then(({ swap }) => {
          console.log(swap.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCreateSwap } from "medusa-react"
          type Props = {
          orderId: string
          }
          type CreateData = {
          return_items: {
          item_id: string
          quantity: number
          }[]
          additional_items: {
          variant_id: string
          quantity: number
          }[]
          return_shipping_option: string
          }
          const CreateSwap = ({
          orderId
          }: Props) => {
          const createSwap = useCreateSwap()
          // ...
          const handleCreate = (
          data: CreateData
          ) => {
          createSwap.mutate({
          ...data,
          order_id: orderId
          }, {
          onSuccess: ({ swap }) => {
          console.log(swap.id)
          }
          })
          }
          // ...
          }
          export default CreateSwap
      - lang: Shell
        label: cURL
        source: |
          curl -X POST '{backend_url}/store/swaps' \
          -H 'Content-Type: application/json' \
          --data-raw '{
          "order_id": "{order_id}",
          "return_items": [
          {
          "item_id": "{item_id}",
          "quantity": 1
          }
          ],
          "additional_items": [
          {
          "variant_id": "{variant_id}",
          "quantity": 1
          }
          ]
          }'
      tags:
      - Swaps
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreSwapsRes'
          description: OK
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StorePostSwapsReq'
      externalDocs:
        description: How to create a swap
        url: https://docs.medusajs.com/modules/orders/storefront/create-swap
  /store/swaps/{cart_id}:
    get:
      operationId: GetSwapsSwapCartId
      summary: Get by Cart ID
      description: Retrieve a Swap's details by the ID of its cart.
      x-codegen:
        method: retrieveByCartId
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          medusa.swaps.retrieveByCartId(cartId)
          .then(({ swap }) => {
          console.log(swap.id);
          })
      - lang: tsx
        label: Medusa React
        source: |
          import React from "react"
          import { useCartSwap } from "medusa-react"
          type Props = {
          cartId: string
          }
          const Swap = ({ cartId }: Props) => {
          const {
          swap,
          isLoading,
          } = useCartSwap(cartId)
          return (
          <div>
          {isLoading && <span>Loading...</span>}
          {swap && <span>{swap.id}</span>}
          </div>
          )
          }
          export default Swap
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/swaps/{cart_id}'
      tags:
      - Swaps
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreSwapsRes'
          description: OK
      parameters:
      - (path) cart_id {string} The id of the Cart
  /store/variants:
    get:
      operationId: GetVariants
      summary: Get Product Variants
      description: |
        Retrieves a list of product variants. The product variants can be filtered by fields such as `id` or `title`. The product variants can also be paginated.
        For accurate and correct pricing of the product variants based on the customer's context, it's highly recommended to pass fields such as
        `region_id`, `currency_code`, and `cart_id` when available.
        Passing `sales_channel_id` ensures retrieving only variants of products available in the specified sales channel.
        You can alternatively use a publishable API key in the request header instead of passing a `sales_channel_id`.
      x-codegen:
        method: list
        queryParams: StoreGetVariantsParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.product.variants.list()
          .then(({ variants }) => {
          console.log(variants.length);
          })
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/variants'
      tags:
      - Product Variants
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreVariantsListRes'
          description: OK
      parameters:
      - (query) ids {string} Filter by a comma-separated list of IDs. If supplied,
        it overrides the `id` parameter.
      - description: Filter by one or more IDs. If `ids` is supplied, it's overrides
          the value of this parameter.
        explode: false
        in: query
        name: id
        oneOf: null
        schema: null
        style: form
      - description: Filter by an ID.
        type: string
      - description: Filter by IDs.
        items: null
        type: string
      - (query) sales_channel_id {string} "Filter by sales channel IDs. When provided,
        only products available in the selected sales channels are retrieved. Alternatively,
        you can pass a publishable API key in the request header and this will have
        the same effect."
      - (query) expand {string} Comma-separated relations that should be expanded
        in the returned product variants.
      - (query) fields {string} Comma-separated fields that should be included in
        the returned product variants.
      - (query) offset=0 {number} The number of products to skip when retrieving the
        product variants.
      - (query) limit=100 {number} Limit the number of product variants returned.
      - (query) cart_id {string} The ID of the cart. This is useful for accurate pricing
        based on the cart's context.
      - (query) region_id {string} The ID of the region. This is useful for accurate
        pricing based on the selected region.
      - description: See a list of codes.
        explode: false
        externalDocs: null
        in: query
        name: currency_code
        schema: null
        style: form
        type: string
        url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
      - description: Filter by title
        explode: false
        in: query
        name: title
        oneOf: null
        schema: null
        style: form
      - description: a single title to filter by
        type: string
      - description: multiple titles to filter by
        items: null
        type: string
      - description: Filter by available inventory quantity
        in: query
        name: inventory_quantity
        oneOf: null
        schema: null
      - description: A specific number to filter by.
        type: number
      - description: Filter by inventory quantity greater than or equal to this number
        gt: null
        gte: null
        lt: null
        lte: null
        properties: null
        type: number
      externalDocs:
        description: How to pass product pricing parameters
        url: https://docs.medusajs.com/modules/products/storefront/show-products#product-pricing-parameters
  /store/variants/{id}:
    get:
      operationId: GetVariantsVariant
      summary: Get a Product Variant
      description: |
        Retrieve a Product Variant's details. For accurate and correct pricing of the product variant based on the customer's context, it's highly recommended to pass fields such as
        `region_id`, `currency_code`, and `cart_id` when available.
        Passing `sales_channel_id` ensures retrieving only variants of products available in the current sales channel.
        You can alternatively use a publishable API key in the request header instead of passing a `sales_channel_id`.
      x-codegen:
        method: retrieve
        queryParams: StoreGetVariantsVariantParams
      x-codeSamples:
      - lang: JavaScript
        label: JS Client
        source: |
          import Medusa from "@medusajs/medusa-js"
          const medusa = new Medusa({ baseUrl: MEDUSA_BACKEND_URL, maxRetries: 3 })
          // must be previously logged in or use api token
          medusa.product.variants.retrieve(productVariantId)
          .then(({ variant }) => {
          console.log(variant.id);
          })
      - lang: Shell
        label: cURL
        source: |
          curl '{backend_url}/store/variants/{id}'
      tags:
      - Product Variants
      responses:
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/400_error'
          description: Bad Request
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/not_found_error'
          description: Not Found
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_state_error'
          description: Invalid State
        "422":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/invalid_request_error'
          description: Invalid Request
        "500":
          content:
            application/json:
              schema:
                $ref: '#/components/responses/500_error'
          description: Internal Server
        È:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StoreVariantsRes'
          description: OK
      parameters:
      - (path) id=* {string} The ID of the Product Variant.
      - (query) sales_channel_id {string} The ID of the sales channel the customer
        is viewing the product variant from.
      - (query) cart_id {string} The ID of the cart. This is useful for accurate pricing
        based on the cart's context.
      - (query) region_id {string} The ID of the region. This is useful for accurate
        pricing based on the selected region.
      - description: See a list of codes.
        explode: false
        externalDocs: null
        in: query
        name: currency_code
        schema: null
        style: form
        type: string
        url: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
      externalDocs:
        description: How to pass product pricing parameters
        url: https://docs.medusajs.com/modules/products/storefront/show-products#product-pricing-parameters
tags:
- name: Auth
  description: |
    Authentication API Routes allow you to manage a customer's session, such as login or log out.
    You can send authenticated requests for a customer either using the Cookie header or using the JWT Token.
- name: Carts
  description: |
    A cart is a virtual shopping bag that customers can use to add items they want to purchase.
    A cart is then used to checkout and place an order.
- name: Customers
  description: |
    A customer can register and manage their information such as addresses, orders, payment methods, and more.
- name: Gift Cards
  description: |
    Customers can use gift cards during checkout to deduct the gift card's balance from the checkout total.
    The Gift Card API Routes allow retrieving a gift card's details by its code. A gift card can be applied to a cart using the Carts API Routes.
- name: Orders
  description: |
    Orders are purchases made by customers, typically through a storefront.
    Orders are placed and created using the Carts API Routes. The Orders API Routes allow retrieving and claiming orders.
- name: Order Edits
  description: |
    Order edits are changes made to items in an order such as adding, updating their quantity, or deleting them. Order edits are created by the admin.
    A customer can review order edit requests created by an admin and confirm or decline them.
- name: Payment Collections
  description: |
    A payment collection is useful for managing additional payments, such as for Order Edits, or installment payments.
- name: Products
  description: |
    Products are saleable items in a store. This also includes [saleable gift cards](https://docs.medusajs.com/modules/gift-cards/storefront/use-gift-cards) in a store.
    Using these API Routes, you can filter products by categories, collections, sales channels, and more.
- name: Product Variants
  description: |
    Product variants are the actual salable item in your store. Each variant is a combination of the different option values available on the product.
- name: Product Categories
  description: |
    Products can be categoriezed into categories. A product can be associated more than one category.
    Using these API Routes, you can list or retrieve a category's details and products.
- name: Product Collections
  description: |
    A product collection is used to organize products for different purposes such as marketing or discount purposes. For example, you can create a Summer Collection.
    Using these API Routes, you can list or retrieve a collection's details and products.
- name: Product Tags
  description: |
    Product tags are string values that can be used to filter products by.
    Products can have more than one tag, and products can share tags.
- name: Product Types
  description: |
    Product types are string values that can be used to filter products by.
    Products can have more than one tag, and products can share types.
- name: Regions
  description: |
    Regions are different countries or geographical regions that the commerce store serves customers in.
    Customers can choose what region they're in, which can be used to change the prices shown based on the region and its currency.
- name: Returns
  description: |
    A return can be created by a customer to return items in an order.
- name: Return Reasons
  description: |
    Return reasons are key-value pairs that are used to specify why an order return is being created.
- name: Shipping Options
  description: |
    A shipping option is used to define the available shipping methods during checkout or when creating a return.
- name: Swaps
  description: |
    A swap is created by a customer or an admin to exchange an item with a new one.
    Creating a swap implicitely includes creating a return for the item being exchanged.
components:
  Address:
    description: An address is used across the Medusa backend within other schemas
      and object types. For example, a customer's billing and shipping addresses both
      use the Address entity.
    required:
    - address_1
    - address_2
    - city
    - company
    - country_code
    - created_at
    - customer_id
    - deleted_at
    - first_name
    - id
    - last_name
    - metadata
    - phone
    - postal_code
    - province
    - updated_at
    type: object
    properties:
      address_1:
        description: Address line 1
        nullable: true
        type: string
        example: 14433 Kemmer Court
      address_2:
        description: Address line 2
        nullable: true
        type: string
        example: Suite 369
      city:
        description: City
        nullable: true
        type: string
        example: South Geoffreyview
      company:
        description: Company name
        nullable: true
        type: string
        example: Acme
      country:
        description: A country object.
        nullable: true
        $ref: '#/components/schemas/Country'
      country_code:
        description: The 2 character ISO code of the country in lower case
        nullable: true
        type: string
        example: st
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      customer:
        description: Available if the relation `customer` is expanded.
        nullable: true
        $ref: '#/components/schemas/Customer'
      customer_id:
        description: ID of the customer this address belongs to
        nullable: true
        type: string
        example: cus_01G2SG30J8C85S4A5CHM2S1NS2
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      first_name:
        description: First name
        nullable: true
        type: string
        example: Arno
      id:
        description: ID of the address
        type: string
        example: addr_01G8ZC9VS1XVE149MGH2J7QSSH
      last_name:
        description: Last name
        nullable: true
        type: string
        example: Willms
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      phone:
        description: Phone Number
        nullable: true
        type: string
        example: 16128234334802
      postal_code:
        description: Postal Code
        nullable: true
        type: string
        example: 72093
      province:
        description: Province
        nullable: true
        type: string
        example: Kentucky
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  AnyValue:
    description: 'Can be anything: string, number, array, object, etc., including
      `null`'
  Cart:
    description: A cart represents a virtual shopping bag. It can be used to complete
      an order, a swap, or a claim.
    required:
    - billing_address_id
    - completed_at
    - context
    - created_at
    - customer_id
    - deleted_at
    - email
    - id
    - idempotency_key
    - metadata
    - payment_authorized_at
    - payment_id
    - payment_session
    - region_id
    - shipping_address_id
    - type
    - updated_at
    type: object
    properties:
      billing_address:
        description: The details of the billing address associated with the cart.
        nullable: true
        $ref: '#/components/schemas/Address'
      billing_address_id:
        description: The billing address's ID
        nullable: true
        type: string
        example: addr_01G8ZH853YPY9B94857DY91YGW
      completed_at:
        description: The date with timezone at which the cart was completed.
        nullable: true
        type: string
        format: date-time
      context:
        description: The context of the cart which can include info like IP or user
          agent.
        nullable: true
        type: object
        example:
          ip: ::1
          user_agent: PostmanRuntime/7.29.2
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      customer:
        description: The details of the customer the cart belongs to.
        nullable: true
        $ref: '#/components/schemas/Customer'
      customer_id:
        description: The customer's ID
        nullable: true
        type: string
        example: cus_01G2SG30J8C85S4A5CHM2S1NS2
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      discount_total:
        description: The total of discount rounded
        type: integer
        example: 800
      discounts:
        description: An array of details of all discounts applied to the cart.
        type: array
        items:
          $ref: '#/components/schemas/Discount'
      email:
        description: The email associated with the cart
        nullable: true
        type: string
        format: email
      gift_card_tax_total:
        description: The total of gift cards with taxes
        type: integer
        example: 0
      gift_card_total:
        description: The total of gift cards
        type: integer
        example: 0
      gift_cards:
        description: An array of details of all gift cards applied to the cart.
        type: array
        items:
          $ref: '#/components/schemas/GiftCard'
      id:
        description: The cart's ID
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      idempotency_key:
        description: Randomly generated key used to continue the completion of a cart
          in case of failure.
        nullable: true
        type: string
      item_tax_total:
        description: The total of items with taxes
        type: integer
        example: 8000
      items:
        description: The line items added to the cart.
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      payment:
        description: The details of the payment associated with the cart.
        nullable: true
        $ref: '#/components/schemas/Payment'
      payment_authorized_at:
        description: The date with timezone at which the payment was authorized.
        nullable: true
        type: string
        format: date-time
      payment_id:
        description: The payment's ID if available
        nullable: true
        type: string
        example: pay_01G8ZCC5W42ZNY842124G7P5R9
      payment_session:
        description: The details of the selected payment session in the cart.
        nullable: true
        $ref: '#/components/schemas/PaymentSession'
      payment_sessions:
        description: The details of all payment sessions created on the cart.
        type: array
        items:
          $ref: '#/components/schemas/PaymentSession'
      raw_discount_total:
        description: The total of discount
        type: integer
        example: 800
      refundable_amount:
        description: The amount that can be refunded
        type: integer
        example: 8200
      refunded_total:
        description: The total amount refunded if the order associated with this cart
          is returned.
        type: integer
        example: 0
      region:
        description: The details of the region associated with the cart.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The region's ID
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      sales_channel:
        description: The details of the sales channel associated with the cart.
        nullable: true
        $ref: '#/components/schemas/SalesChannel'
      sales_channel_id:
        description: The sales channel ID the cart is associated with.
        nullable: true
        type: string
      sales_channels:
        description: The associated sales channels.
        nullable: true
        type: array
        items:
          $ref: '#/components/schemas/SalesChannel'
      shipping_address:
        description: The details of the shipping address associated with the cart.
        nullable: true
        $ref: '#/components/schemas/Address'
      shipping_address_id:
        description: The shipping address's ID
        nullable: true
        type: string
        example: addr_01G8ZH853YPY9B94857DY91YGW
      shipping_methods:
        description: The details of the shipping methods added to the cart.
        type: array
        items:
          $ref: '#/components/schemas/ShippingMethod'
      shipping_tax_total:
        description: The total of shipping with taxes
        type: integer
        example: 1000
      shipping_total:
        description: The total of shipping
        type: integer
        example: 1000
      subtotal:
        description: The subtotal of the cart
        type: integer
        example: 8000
      tax_total:
        description: The total of tax
        type: integer
        example: 0
      total:
        description: The total amount of the cart
        type: integer
        example: 8200
      type:
        description: The cart's type.
        type: string
        enum:
        - default
        - swap
        - draft_order
        - payment_link
        - claim
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ClaimItem:
    description: A claim item is an item created as part of a claim. It references
      an item in the order that should be exchanged or refunded.
    required:
    - claim_order_id
    - created_at
    - deleted_at
    - id
    - item_id
    - metadata
    - note
    - quantity
    - reason
    - updated_at
    - variant_id
    type: object
    properties:
      claim_order:
        description: The details of the claim this item belongs to.
        nullable: true
        $ref: '#/components/schemas/ClaimOrder'
      claim_order_id:
        description: The ID of the claim this item is associated with.
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The claim item's ID
        type: string
        example: citm_01G8ZH853Y6TFXWPG5EYE81X63
      images:
        description: The claim images that are attached to the claim item.
        type: array
        items:
          $ref: '#/components/schemas/ClaimImage'
      item:
        description: The details of the line item in the original order that this
          claim item refers to.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      item_id:
        description: The ID of the line item that the claim item refers to.
        type: string
        example: item_01G8ZM25TN49YV9EQBE2NC27KC
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      note:
        description: An optional note about the claim, for additional information
        nullable: true
        type: string
        example: I don't like it.
      quantity:
        description: The quantity of the item that is being claimed; must be less
          than or equal to the amount purchased in the original order.
        type: integer
        example: 1
      reason:
        description: The reason for the claim
        type: string
        enum:
        - missing_item
        - wrong_item
        - production_failure
        - other
      tags:
        description: User defined tags for easy filtering and grouping.
        type: array
        items:
          $ref: '#/components/schemas/ClaimTag'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      variant:
        description: The details of the product variant to potentially replace the
          item in the original order.
        nullable: true
        $ref: '#/components/schemas/ProductVariant'
      variant_id:
        description: The ID of the product variant that is claimed.
        type: string
        example: variant_01G1G5V2MRX2V3PVSR2WXYPFB6
  ClaimOrder:
    description: A Claim represents a group of faulty or missing items. It consists
      of claim items that refer to items in the original order that should be replaced
      or refunded. It also includes details related to shipping and fulfillment.
    required:
    - canceled_at
    - created_at
    - deleted_at
    - fulfillment_status
    - id
    - idempotency_key
    - metadata
    - no_notification
    - order_id
    - payment_status
    - refund_amount
    - shipping_address_id
    - type
    - updated_at
    type: object
    properties:
      additional_items:
        description: The details of the new items to be shipped when the claim's type
          is `replace`
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      canceled_at:
        description: The date with timezone at which the claim was canceled.
        nullable: true
        type: string
        format: date-time
      claim_items:
        description: The details of the items that should be replaced or refunded.
        type: array
        items:
          $ref: '#/components/schemas/ClaimItem'
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      fulfillment_status:
        description: The claim's fulfillment status
        type: string
        enum:
        - not_fulfilled
        - partially_fulfilled
        - fulfilled
        - partially_shipped
        - shipped
        - partially_returned
        - returned
        - canceled
        - requires_action
      fulfillments:
        description: The fulfillments of the new items to be shipped
        type: array
        items:
          $ref: '#/components/schemas/Fulfillment'
      id:
        description: The claim's ID
        type: string
        example: claim_01G8ZH853Y6TFXWPG5EYE81X63
      idempotency_key:
        description: Randomly generated key used to continue the completion of the
          cart associated with the claim in case of failure.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      no_notification:
        description: Flag for describing whether or not notifications related to this
          should be send.
        nullable: true
        type: boolean
        example: false
      order:
        description: The details of the order that this claim was created for.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the claim comes from.
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      payment_status:
        description: The status of the claim's payment
        type: string
        enum:
        - na
        - not_refunded
        - refunded
      refund_amount:
        description: The amount that will be refunded in conjunction with the claim
        nullable: true
        type: integer
        example: 1000
      return_order:
        description: The details of the return associated with the claim if the claim's
          type is `replace`.
        nullable: true
        $ref: '#/components/schemas/Return'
      shipping_address:
        description: The details of the address that new items should be shipped to.
        nullable: true
        $ref: '#/components/schemas/Address'
      shipping_address_id:
        description: The ID of the address that the new items should be shipped to
        nullable: true
        type: string
        example: addr_01G8ZH853YPY9B94857DY91YGW
      shipping_methods:
        description: The details of the shipping methods that the claim order will
          be shipped with.
        type: array
        items:
          $ref: '#/components/schemas/ShippingMethod'
      type:
        description: The claim's type
        type: string
        enum:
        - refund
        - replace
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ClaimTag:
    description: Claim Tags are user defined tags that can be assigned to claim items
      for easy filtering and grouping.
    required:
    - created_at
    - deleted_at
    - id
    - metadata
    - updated_at
    - value
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The claim tag's ID
        type: string
        example: ctag_01G8ZCC5Y63B95V6B5SHBZ91S4
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value that the claim tag holds
        type: string
        example: Damaged
  CustomShippingOption:
    description: Custom Shipping Options are overridden Shipping Options. Admins can
      attach a Custom Shipping Option to a cart in order to set a custom price for
      a particular Shipping Option.
    required:
    - cart_id
    - created_at
    - deleted_at
    - id
    - metadata
    - price
    - shipping_option_id
    - updated_at
    type: object
    properties:
      cart:
        description: The details of the cart this shipping option belongs to.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the Cart that the custom shipping option is attached
          to
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The custom shipping option's ID
        type: string
        example: cso_01G8X99XNB77DMFBJFWX6DN9V9
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      price:
        description: The custom price set that will override the shipping option's
          original price
        type: integer
        example: 1000
      shipping_option:
        description: The details of the overridden shipping options.
        nullable: true
        $ref: '#/components/schemas/ShippingOption'
      shipping_option_id:
        description: The ID of the Shipping Option that the custom shipping option
          overrides
        type: string
        example: so_01G1G5V27GYX4QXNARRQCW1N8T
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  Discount:
    description: A discount can be applied to a cart for promotional purposes.
    required:
    - code
    - created_at
    - deleted_at
    - ends_at
    - id
    - is_disabled
    - is_dynamic
    - metadata
    - parent_discount_id
    - rule_id
    - starts_at
    - updated_at
    - usage_count
    - usage_limit
    - valid_duration
    type: object
    properties:
      code:
        description: A unique code for the discount - this will be used by the customer
          to apply the discount
        type: string
        example: 10DISC
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      ends_at:
        description: The time at which the discount can no longer be used.
        nullable: true
        type: string
        format: date-time
      id:
        description: The discount's ID
        type: string
        example: disc_01F0YESMW10MGHWJKZSDDMN0VN
      is_disabled:
        description: Whether the Discount has been disabled. Disabled discounts cannot
          be applied to carts
        type: boolean
        example: false
      is_dynamic:
        description: A flag to indicate if multiple instances of the discount can
          be generated. I.e. for newsletter discounts
        type: boolean
        example: false
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      parent_discount:
        description: The details of the parent discount that this discount was created
          from.
        nullable: true
        $ref: '#/components/schemas/Discount'
      parent_discount_id:
        description: The Discount that the discount was created from. This will always
          be a dynamic discount
        nullable: true
        type: string
        example: disc_01G8ZH853YPY9B94857DY91YGW
      regions:
        description: The details of the regions in which the Discount can be used.
        type: array
        items:
          $ref: '#/components/schemas/Region'
      rule:
        description: The details of the discount rule that defines how the discount
          will be applied to a cart..
        nullable: true
        $ref: '#/components/schemas/DiscountRule'
      rule_id:
        description: The ID of the discount rule that defines how the discount will
          be applied to a cart.
        nullable: true
        type: string
        example: dru_01F0YESMVK96HVX7N419E3CJ7C
      starts_at:
        description: The time at which the discount can be used.
        type: string
        format: date-time
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      usage_count:
        description: The number of times a discount has been used.
        type: integer
        example: 50
      usage_limit:
        description: The maximum number of times that a discount can be used.
        nullable: true
        type: integer
        example: 100
      valid_duration:
        description: Duration the discount runs between
        nullable: true
        type: string
        example: P3Y6M4DT12H30M5S
  DiscountCondition:
    description: Holds rule conditions for when a discount is applicable
    required:
    - created_at
    - deleted_at
    - discount_rule_id
    - id
    - metadata
    - operator
    - type
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      customer_groups:
        description: Customer groups associated with this condition if `type` is `customer_groups`.
        type: array
        items:
          $ref: '#/components/schemas/CustomerGroup'
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      discount_rule:
        description: The details of the discount rule associated with the condition.
        nullable: true
        $ref: '#/components/schemas/DiscountRule'
      discount_rule_id:
        description: The ID of the discount rule associated with the condition
        type: string
        example: dru_01F0YESMVK96HVX7N419E3CJ7C
      id:
        description: The discount condition's ID
        type: string
        example: discon_01G8X9A7ESKAJXG2H0E6F1MW7A
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      operator:
        description: The operator of the condition. `in` indicates that discountable
          resources are within the specified resources. `not_in` indicates that discountable
          resources are everything but the specified resources.
        type: string
        enum:
        - in
        - not_in
      product_collections:
        description: Product collections associated with this condition if `type`
          is `product_collections`.
        type: array
        items:
          $ref: '#/components/schemas/ProductCollection'
      product_tags:
        description: Product tags associated with this condition if `type` is `product_tags`.
        type: array
        items:
          $ref: '#/components/schemas/ProductTag'
      product_types:
        description: Product types associated with this condition if `type` is `product_types`.
        type: array
        items:
          $ref: '#/components/schemas/ProductType'
      products:
        description: products associated with this condition if `type` is `products`.
        type: array
        items:
          $ref: '#/components/schemas/Product'
      type:
        description: The type of the condition. The type affects the available resources
          associated with the condition. For example, if the type is `products`, that
          means the `products` relation will hold the products associated with this
          condition and other relations will be empty.
        type: string
        enum:
        - products
        - product_types
        - product_collections
        - product_tags
        - customer_groups
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  DiscountConditionCustomerGroup:
    description: Associates a discount condition with a customer group
    required:
    - condition_id
    - created_at
    - customer_group_id
    - metadata
    - updated_at
    type: object
    properties:
      condition_id:
        description: The ID of the Discount Condition
        type: string
        example: discon_01G8X9A7ESKAJXG2H0E6F1MW7A
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      customer_group:
        description: Available if the relation `customer_group` is expanded.
        nullable: true
        $ref: '#/components/schemas/CustomerGroup'
      customer_group_id:
        description: The ID of the Product Tag
        type: string
        example: cgrp_01G8ZH853Y6TFXWPG5EYE81X63
      discount_condition:
        description: Available if the relation `discount_condition` is expanded.
        nullable: true
        $ref: '#/components/schemas/DiscountCondition'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  DiscountConditionProduct:
    description: This represents the association between a discount condition and
      a product
    required:
    - condition_id
    - created_at
    - metadata
    - product_id
    - updated_at
    type: object
    properties:
      condition_id:
        description: The ID of the Discount Condition
        type: string
        example: discon_01G8X9A7ESKAJXG2H0E6F1MW7A
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      discount_condition:
        description: The details of the discount condition.
        nullable: true
        $ref: '#/components/schemas/DiscountCondition'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product:
        description: The details of the product.
        nullable: true
        $ref: '#/components/schemas/Product'
      product_id:
        description: The ID of the Product Tag
        type: string
        example: prod_01G1G5V2MBA328390B5AXJ610F
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  DiscountConditionProductCollection:
    description: This represents the association between a discount condition and
      a product collection
    required:
    - condition_id
    - created_at
    - metadata
    - product_collection_id
    - updated_at
    type: object
    properties:
      condition_id:
        description: The ID of the Discount Condition
        type: string
        example: discon_01G8X9A7ESKAJXG2H0E6F1MW7A
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      discount_condition:
        description: The details of the discount condition.
        nullable: true
        $ref: '#/components/schemas/DiscountCondition'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product_collection:
        description: The details of the product collection.
        nullable: true
        $ref: '#/components/schemas/ProductCollection'
      product_collection_id:
        description: The ID of the Product Collection
        type: string
        example: pcol_01F0YESBFAZ0DV6V831JXWH0BG
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  DiscountConditionProductTag:
    description: This represents the association between a discount condition and
      a product tag
    required:
    - condition_id
    - created_at
    - metadata
    - product_tag_id
    - updated_at
    type: object
    properties:
      condition_id:
        description: The ID of the Discount Condition
        type: string
        example: discon_01G8X9A7ESKAJXG2H0E6F1MW7A
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      discount_condition:
        description: The details of the discount condition.
        nullable: true
        $ref: '#/components/schemas/DiscountCondition'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product_tag:
        description: The details of the product tag.
        nullable: true
        $ref: '#/components/schemas/ProductTag'
      product_tag_id:
        description: The ID of the Product Tag
        type: string
        example: ptag_01F0YESHPZYY3H4SJ3A5918SBN
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  DiscountConditionProductType:
    description: This represents the association between a discount condition and
      a product type
    required:
    - condition_id
    - created_at
    - metadata
    - product_type_id
    - updated_at
    type: object
    properties:
      condition_id:
        description: The ID of the Discount Condition
        type: string
        example: discon_01G8X9A7ESKAJXG2H0E6F1MW7A
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      discount_condition:
        description: The details of the discount condition.
        nullable: true
        $ref: '#/components/schemas/DiscountCondition'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product_type:
        description: The details of the product type.
        nullable: true
        $ref: '#/components/schemas/ProductType'
      product_type_id:
        description: The ID of the Product Tag
        type: string
        example: ptyp_01G8X9A7ESKAJXG2H0E6F1MW7A
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  DiscountRule:
    description: A discount rule defines how a Discount is calculated when applied
      to a Cart.
    required:
    - allocation
    - created_at
    - deleted_at
    - description
    - id
    - metadata
    - type
    - updated_at
    - value
    type: object
    properties:
      allocation:
        description: The scope that the discount should apply to.
        nullable: true
        type: string
        enum:
        - total
        - item
        example: total
      conditions:
        description: The details of the discount conditions associated with the rule.
          They can be used to limit when the discount can be used.
        type: array
        items:
          $ref: '#/components/schemas/DiscountCondition'
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      description:
        description: A short description of the discount
        nullable: true
        type: string
        example: 10 Percent
      id:
        description: The discount rule's ID
        type: string
        example: dru_01F0YESMVK96HVX7N419E3CJ7C
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      type:
        description: The type of the Discount, can be `fixed` for discounts that reduce
          the price by a fixed amount, `percentage` for percentage reductions or `free_shipping`
          for shipping vouchers.
        type: string
        enum:
        - fixed
        - percentage
        - free_shipping
        example: percentage
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value that the discount represents; this will depend on the
          type of the discount
        type: integer
        example: 10
  DraftOrder:
    description: A draft order is created by an admin without direct involvement of
      the customer. Once its payment is marked as captured, it is transformed into
      an order.
    required:
    - canceled_at
    - cart_id
    - completed_at
    - created_at
    - display_id
    - id
    - idempotency_key
    - metadata
    - no_notification_order
    - order_id
    - status
    - updated_at
    type: object
    properties:
      canceled_at:
        description: The date the draft order was canceled at.
        nullable: true
        type: string
        format: date-time
      cart:
        description: The details of the cart associated with the draft order.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart associated with the draft order.
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      completed_at:
        description: The date the draft order was completed at.
        nullable: true
        type: string
        format: date-time
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      display_id:
        description: The draft order's display ID
        type: string
        example: 2
      id:
        description: The draft order's ID
        type: string
        example: dorder_01G8TJFKBG38YYFQ035MSVG03C
      idempotency_key:
        description: Randomly generated key used to continue the completion of the
          cart associated with the draft order in case of failure.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      no_notification_order:
        description: Whether to send the customer notifications regarding order updates.
        nullable: true
        type: boolean
        example: false
      order:
        description: The details of the order created from the draft order when its
          payment is captured.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order created from the draft order when its payment
          is captured.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      status:
        description: The status of the draft order. It's changed to `completed` when
          it's transformed to an order.
        type: string
        enum:
        - open
        - completed
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  Error:
    type: object
    properties:
      code:
        description: A slug code to indicate the type of the error.
        type: string
        enum:
        - invalid_state_error
        - invalid_request_error
        - api_error
        - unknown_error
      message:
        description: Description of the error that occurred.
        type: string
        example: first_name must be a string
      type:
        description: A slug indicating the type of the error.
        type: string
        enum:
        - QueryRunnerAlreadyReleasedError
        - TransactionAlreadyStartedError
        - TransactionNotStartedError
        - conflict
        - unauthorized
        - payment_authorization_error
        - duplicate_error
        - not_allowed
        - invalid_data
        - not_found
        - database_error
        - unexpected_state
        - invalid_argument
        - unknown_error
  Fulfillment:
    description: A Fulfillment is created once an admin can prepare the purchased
      goods. Fulfillments will eventually be shipped and hold information about how
      to track shipments. Fulfillments are created through a fulfillment provider,
      which typically integrates a third-party shipping service. Fulfillments can
      be associated with orders, claims, swaps, and returns.
    required:
    - canceled_at
    - claim_order_id
    - created_at
    - data
    - id
    - idempotency_key
    - location_id
    - metadata
    - no_notification
    - order_id
    - provider_id
    - shipped_at
    - swap_id
    - tracking_numbers
    - updated_at
    type: object
    properties:
      canceled_at:
        description: The date with timezone at which the Fulfillment was canceled.
        nullable: true
        type: string
        format: date-time
      claim_order:
        description: The details of the claim that the fulfillment may belong to.
        nullable: true
        $ref: '#/components/schemas/ClaimOrder'
      claim_order_id:
        description: The ID of the Claim that the Fulfillment belongs to.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      data:
        description: This contains all the data necessary for the Fulfillment provider
          to handle the fulfillment.
        type: object
        example: {}
      id:
        description: The fulfillment's ID
        type: string
        example: ful_01G8ZRTMQCA76TXNAT81KPJZRF
      idempotency_key:
        description: Randomly generated key used to continue the completion of the
          fulfillment in case of failure.
        nullable: true
        type: string
      items:
        description: The Fulfillment Items in the Fulfillment. These hold information
          about how many of each Line Item has been fulfilled.
        type: array
        items:
          $ref: '#/components/schemas/FulfillmentItem'
      location_id:
        description: The ID of the stock location the fulfillment will be shipped
          from
        nullable: true
        type: string
        example: sloc_01G8TJSYT9M6AVS5N4EMNFS1EK
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      no_notification:
        description: Flag for describing whether or not notifications related to this
          should be sent.
        nullable: true
        type: boolean
        example: false
      order:
        description: The details of the order that the fulfillment may belong to.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the Order that the Fulfillment belongs to.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      provider:
        description: The details of the fulfillment provider responsible for handling
          the fulfillment.
        nullable: true
        $ref: '#/components/schemas/FulfillmentProvider'
      provider_id:
        description: The ID of the Fulfillment Provider responsible for handling the
          fulfillment.
        type: string
        example: manual
      shipped_at:
        description: The date with timezone at which the Fulfillment was shipped.
        nullable: true
        type: string
        format: date-time
      swap:
        description: The details of the swap that the fulfillment may belong to.
        nullable: true
        $ref: '#/components/schemas/Swap'
      swap_id:
        description: The ID of the Swap that the Fulfillment belongs to.
        nullable: true
        type: string
      tracking_links:
        description: The Tracking Links that can be used to track the status of the
          Fulfillment. These will usually be provided by the Fulfillment Provider.
        type: array
        items:
          $ref: '#/components/schemas/TrackingLink'
      tracking_numbers:
        description: The tracking numbers that can be used to track the status of
          the fulfillment.
        type: array
        items:
          type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  FulfillmentItem:
    description: This represents the association between a Line Item and a Fulfillment.
    required:
    - fulfillment_id
    - item_id
    - quantity
    type: object
    properties:
      fulfillment:
        description: The details of the fulfillment.
        nullable: true
        $ref: '#/components/schemas/Fulfillment'
      fulfillment_id:
        description: The ID of the Fulfillment that the Fulfillment Item belongs to.
        type: string
        example: ful_01G8ZRTMQCA76TXNAT81KPJZRF
      item:
        description: The details of the line item.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      item_id:
        description: The ID of the Line Item that the Fulfillment Item references.
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      quantity:
        description: The quantity of the Line Item that is included in the Fulfillment.
        type: integer
        example: 1
  FulfillmentProvider:
    description: A fulfillment provider represents a fulfillment service installed
      in the Medusa backend, either through a plugin or backend customizations. It
      holds the fulfillment service's installation status.
    required:
    - id
    - is_installed
    type: object
    properties:
      id:
        description: The ID of the fulfillment provider as given by the fulfillment
          service.
        type: string
        example: manual
      is_installed:
        description: Whether the fulfillment service is installed in the current version.
          If a fulfillment service is no longer installed, the `is_installed` attribute
          is set to `false`.
        type: boolean
  GiftCard:
    description: Gift Cards are redeemable and represent a value that can be used
      towards the payment of an Order.
    required:
    - balance
    - code
    - created_at
    - deleted_at
    - ends_at
    - id
    - is_disabled
    - metadata
    - order_id
    - region_id
    - tax_rate
    - updated_at
    - value
    type: object
    properties:
      balance:
        description: The remaining value on the Gift Card.
        type: integer
        example: 10
      code:
        description: The unique code that identifies the Gift Card. This is used by
          the Customer to redeem the value of the Gift Card.
        type: string
        example: 3RFT-MH2C-Y4YZ-XMN4
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      ends_at:
        description: The time at which the Gift Card can no longer be used.
        nullable: true
        type: string
        format: date-time
      id:
        description: The gift card's ID
        type: string
        example: gift_01G8XKBPBQY2R7RBET4J7E0XQZ
      is_disabled:
        description: Whether the Gift Card has been disabled. Disabled Gift Cards
          cannot be applied to carts.
        type: boolean
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      order:
        description: The details of the order that the gift card was purchased in.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the gift card was purchased in.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      region:
        description: The details of the region this gift card is available in.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The ID of the region this gift card is available in.
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      tax_rate:
        description: The gift card's tax rate that will be applied on calculating
          totals
        nullable: true
        type: number
        example: 0
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value that the Gift Card represents.
        type: integer
        example: 10
  GiftCardTransaction:
    description: Gift Card Transactions are created once a Customer uses a Gift Card
      to pay for their Order.
    required:
    - amount
    - created_at
    - gift_card_id
    - id
    - is_taxable
    - order_id
    - tax_rate
    type: object
    properties:
      amount:
        description: The amount that was used from the Gift Card.
        type: integer
        example: 10
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      gift_card:
        description: The details of the gift card associated used in this transaction.
        nullable: true
        $ref: '#/components/schemas/GiftCard'
      gift_card_id:
        description: The ID of the Gift Card that was used in the transaction.
        type: string
        example: gift_01G8XKBPBQY2R7RBET4J7E0XQZ
      id:
        description: The gift card transaction's ID
        type: string
        example: gct_01G8X9A7ESKAJXG2H0E6F1MW7A
      is_taxable:
        description: Whether the transaction is taxable or not.
        nullable: true
        type: boolean
        example: false
      order:
        description: The details of the order that the gift card was used for payment.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the gift card was used for payment.
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      tax_rate:
        description: The tax rate of the transaction
        nullable: true
        type: number
        example: 0
  IdempotencyKey:
    description: Idempotency Key is used to continue a process in case of any failure
      that might occur.
    required:
    - created_at
    - id
    - idempotency_key
    - locked_at
    - recovery_point
    - response_code
    - response_body
    - request_method
    - request_params
    - request_path
    type: object
    properties:
      created_at:
        description: Date which the idempotency key was locked.
        type: string
        format: date-time
      id:
        description: The idempotency key's ID
        type: string
        example: ikey_01G8X9A7ESKAJXG2H0E6F1MW7A
      idempotency_key:
        description: The unique randomly generated key used to determine the state
          of a process.
        type: string
      locked_at:
        description: Date which the idempotency key was locked.
        nullable: true
        type: string
        format: date-time
      recovery_point:
        description: Where to continue from.
        type: string
      request_method:
        description: The method of the request
        nullable: true
        type: string
        example: POST
      request_params:
        description: The parameters passed to the request
        nullable: true
        type: object
        example:
          id: cart_01G8ZH853Y6TFXWPG5EYE81X63
      request_path:
        description: The request's path
        nullable: true
        type: string
        example: /store/carts/cart_01G8ZH853Y6TFXWPG5EYE81X63/complete
      response_body:
        description: The response's body
        nullable: true
        type: object
        example:
          id: cart_01G8ZH853Y6TFXWPG5EYE81X63
      response_code:
        description: The response's code.
        nullable: true
        type: string
        example: 200
  Invite:
    description: An invite is created when an admin user invites a new user to join
      the store's team. Once the invite is accepted, it's deleted.
    required:
    - accepted
    - created_at
    - deleted_at
    - expires_at
    - id
    - metadata
    - role
    - token
    - updated_at
    - user_email
    type: object
    properties:
      accepted:
        description: Whether the invite was accepted or not.
        type: boolean
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      expires_at:
        description: The date the invite expires at.
        type: string
        format: date-time
      id:
        description: The invite's ID
        type: string
        example: invite_01G8TKE4XYCTHSCK2GDEP47RE1
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      role:
        description: The user's role. These roles don't change the privileges of the
          user.
        nullable: true
        type: string
        enum:
        - admin
        - member
        - developer
      token:
        description: The token used to accept the invite.
        type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      user_email:
        description: The email of the user being invited.
        type: string
        format: email
  LineItem:
    description: Line Items are created when a product is added to a Cart. When Line
      Items are purchased they will get copied to the resulting order, swap, or claim,
      and can eventually be referenced in Fulfillments and Returns. Line items may
      also be used for order edits.
    required:
    - allow_discounts
    - cart_id
    - claim_order_id
    - created_at
    - description
    - fulfilled_quantity
    - has_shipping
    - id
    - is_giftcard
    - is_return
    - metadata
    - order_edit_id
    - order_id
    - original_item_id
    - quantity
    - returned_quantity
    - shipped_quantity
    - should_merge
    - swap_id
    - thumbnail
    - title
    - unit_price
    - updated_at
    - variant_id
    type: object
    properties:
      adjustments:
        description: The details of the item's adjustments, which are available when
          a discount is applied on the item.
        type: array
        items:
          $ref: '#/components/schemas/LineItemAdjustment'
      allow_discounts:
        description: Flag to indicate if the Line Item should be included when doing
          discount calculations.
        type: boolean
      cart:
        description: The details of the cart that the line item may belongs to.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart that the line item may belongs to.
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      claim_order:
        description: The details of the claim that the line item may belong to.
        nullable: true
        $ref: '#/components/schemas/ClaimOrder'
      claim_order_id:
        description: The ID of the claim that the line item may belong to.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      description:
        description: A more detailed description of the contents of the Line Item.
        nullable: true
        type: string
        example: One Size
      discount_total:
        description: The total of discount of the line item rounded
        type: integer
        example: 0
      fulfilled_quantity:
        description: The quantity of the Line Item that has been fulfilled.
        nullable: true
        type: integer
        example: 0
      gift_card_total:
        description: The total of the gift card of the line item
        type: integer
        example: 0
      has_shipping:
        description: Flag to indicate if the Line Item has fulfillment associated
          with it.
        nullable: true
        type: boolean
        example: false
      id:
        description: The line item's ID
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      includes_tax:
        description: Indicates if the line item unit_price include tax
        type: boolean
      is_giftcard:
        description: Flag to indicate if the Line Item is a Gift Card.
        type: boolean
      is_return:
        description: Is the item being returned
        type: boolean
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      order:
        description: The details of the order that the line item may belongs to.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_edit:
        description: The details of the order edit.
        nullable: true
        $ref: '#/components/schemas/OrderEdit'
      order_edit_id:
        description: The ID of the order edit that the item may belong to.
        nullable: true
        type: string
      order_id:
        description: The ID of the order that the line item may belongs to.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      original_item_id:
        description: The ID of the original line item. This is useful if the line
          item belongs to a resource that references an order, such as a return or
          an order edit.
        nullable: true
        type: string
      original_tax_total:
        description: The original tax total amount of the line item
        type: integer
        example: 0
      original_total:
        description: The original total amount of the line item
        type: integer
        example: 8000
      quantity:
        description: The quantity of the content in the Line Item.
        type: integer
        example: 1
      raw_discount_total:
        description: The total of discount of the line item
        type: integer
        example: 0
      refundable:
        description: The amount that can be refunded from the given Line Item. Takes
          taxes and discounts into consideration.
        type: integer
        example: 0
      returned_quantity:
        description: The quantity of the Line Item that has been returned.
        nullable: true
        type: integer
        example: 0
      shipped_quantity:
        description: The quantity of the Line Item that has been shipped.
        nullable: true
        type: integer
        example: 0
      should_merge:
        description: Flag to indicate if new Line Items with the same variant should
          be merged or added as an additional Line Item.
        type: boolean
      subtotal:
        description: The subtotal of the line item
        type: integer
        example: 8000
      swap:
        description: The details of the swap that the line item may belong to.
        nullable: true
        $ref: '#/components/schemas/Swap'
      swap_id:
        description: The ID of the swap that the line item may belong to.
        nullable: true
        type: string
      tax_lines:
        description: The details of the item's tax lines.
        type: array
        items:
          $ref: '#/components/schemas/LineItemTaxLine'
      tax_total:
        description: The total of tax of the line item
        type: integer
        example: 0
      thumbnail:
        description: A URL string to a small image of the contents of the Line Item.
        nullable: true
        type: string
        format: uri
        example: https://medusa-public-images.s3.eu-west-1.amazonaws.com/coffee-mug.png
      title:
        description: The title of the Line Item.
        type: string
        example: Medusa Coffee Mug
      total:
        description: The total amount of the line item
        type: integer
        example: 8000
      unit_price:
        description: The price of one unit of the content in the Line Item. This should
          be in the currency defined by the Cart/Order/Swap/Claim that the Line Item
          belongs to.
        type: integer
        example: 8000
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      variant:
        description: The details of the product variant that this item was created
          from.
        nullable: true
        $ref: '#/components/schemas/ProductVariant'
      variant_id:
        description: The id of the Product Variant contained in the Line Item.
        nullable: true
        type: string
        example: variant_01G1G5V2MRX2V3PVSR2WXYPFB6
  LineItemAdjustment:
    description: A Line Item Adjustment includes details on discounts applied on a
      line item.
    required:
    - amount
    - description
    - discount_id
    - id
    - item_id
    - metadata
    type: object
    properties:
      amount:
        description: The adjustment amount
        type: number
        example: 1000
      description:
        description: The line item's adjustment description
        type: string
        example: Adjusted item's price.
      discount:
        description: The details of the discount associated with the adjustment.
        nullable: true
        $ref: '#/components/schemas/Discount'
      discount_id:
        description: The ID of the discount associated with the adjustment
        nullable: true
        type: string
        example: disc_01F0YESMW10MGHWJKZSDDMN0VN
      id:
        description: The Line Item Adjustment's ID
        type: string
        example: lia_01G8TKE4XYCTHSCK2GDEP47RE1
      item:
        description: The details of the line item.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      item_id:
        description: The ID of the line item
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
  LineItemTaxLine:
    description: A Line Item Tax Line represents the taxes applied on a line item.
    required:
    - code
    - created_at
    - id
    - item_id
    - metadata
    - name
    - rate
    - updated_at
    type: object
    properties:
      code:
        description: A code to identify the tax type by
        nullable: true
        type: string
        example: tax01
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      id:
        description: The line item tax line's ID
        type: string
        example: litl_01G1G5V2DRX1SK6NQQ8VVX4HQ8
      item:
        description: The details of the line item.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      item_id:
        description: The ID of the line item
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: A human friendly name for the tax
        type: string
        example: Tax Example
      rate:
        description: The numeric rate to charge tax by
        type: number
        example: 10
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  MoneyAmount:
    description: A Money Amount represent a price amount, for example, a product variant's
      price or a price in a price list. Each Money Amount either has a Currency or
      Region associated with it to indicate the pricing in a given Currency or, for
      fully region-based pricing, the given price in a specific Region. If region-based
      pricing is used, the amount will be in the currency defined for the Region.
    required:
    - amount
    - created_at
    - currency_code
    - deleted_at
    - id
    - max_quantity
    - min_quantity
    - price_list_id
    - region_id
    - updated_at
    - variant_id
    type: object
    properties:
      amount:
        description: The amount in the smallest currecny unit (e.g. cents 100 cents
          to charge $1) that the Product Variant will cost.
        type: integer
        example: 100
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      currency:
        description: The details of the currency that the money amount may belong
          to.
        nullable: true
        $ref: '#/components/schemas/Currency'
      currency_code:
        description: The 3 character currency code that the money amount may belong
          to.
        type: string
        example: usd
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The money amount's ID
        type: string
        example: ma_01F0YESHRFQNH5S8Q0PK84YYZN
      max_quantity:
        description: The maximum quantity that the Money Amount applies to. If this
          value is not set, the Money Amount applies to all quantities.
        nullable: true
        type: integer
        example: 1
      min_quantity:
        description: The minimum quantity that the Money Amount applies to. If this
          value is not set, the Money Amount applies to all quantities.
        nullable: true
        type: integer
        example: 1
      price_list:
        description: The details of the price list that the money amount may belong
          to.
        nullable: true
        $ref: '#/components/schemas/PriceList'
      price_list_id:
        description: The ID of the price list that the money amount may belong to.
        nullable: true
        type: string
        example: pl_01G8X3CKJXCG5VXVZ87H9KC09W
      region:
        description: The details of the region that the money amount may belong to.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The region's ID
        nullable: true
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      variant:
        description: The details of the product variant that the money amount may
          belong to.
        nullable: true
        $ref: '#/components/schemas/ProductVariant'
      variant_id:
        description: The ID of the Product Variant contained in the Line Item.
        nullable: true
        type: string
        example: variant_01G1G5V2MRX2V3PVSR2WXYPFB6
  Note:
    description: A Note is an element that can be used in association with different
      resources to allow admin users to describe additional information. For example,
      they can be used to add additional information about orders.
    required:
    - author_id
    - created_at
    - deleted_at
    - id
    - metadata
    - resource_id
    - resource_type
    - updated_at
    - value
    type: object
    properties:
      author:
        description: The details of the user that created the note.
        nullable: true
        $ref: '#/components/schemas/User'
      author_id:
        description: The ID of the user that created the note.
        nullable: true
        type: string
        example: usr_01G1G5V26F5TB3GPAPNJ8X1S3V
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The note's ID
        type: string
        example: note_01G8TM8ENBMC7R90XRR1G6H26Q
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      resource_id:
        description: The ID of the resource that the Note refers to.
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      resource_type:
        description: The type of resource that the Note refers to.
        type: string
        example: order
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The contents of the note.
        type: string
        example: This order must be fulfilled on Monday
  Notification:
    description: A notification is an alert sent, typically to customers, using the
      installed Notification Provider as a reaction to internal events such as `order.placed`.
      Notifications can be resent.
    required:
    - created_at
    - customer_id
    - data
    - event_name
    - id
    - parent_id
    - provider_id
    - resource_type
    - resource_id
    - to
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      customer:
        description: The details of the customer that this notification was sent to.
        nullable: true
        $ref: '#/components/schemas/Customer'
      customer_id:
        description: The ID of the customer that this notification was sent to.
        nullable: true
        type: string
        example: cus_01G2SG30J8C85S4A5CHM2S1NS2
      data:
        description: The data that the Notification was sent with. This contains all
          the data necessary for the Notification Provider to initiate a resend.
        type: object
        example: {}
      event_name:
        description: The name of the event that the notification was sent for.
        nullable: true
        type: string
        example: order.placed
      id:
        description: The notification's ID
        type: string
        example: noti_01G53V9Y6CKMCGBM1P0X7C28RX
      parent_id:
        description: The notification's parent ID
        nullable: true
        type: string
        example: noti_01G53V9Y6CKMCGBM1P0X7C28RX
      parent_notification:
        description: The details of the parent notification.
        nullable: true
        $ref: '#/components/schemas/Notification'
      provider:
        description: The notification provider used to send the notification.
        nullable: true
        $ref: '#/components/schemas/NotificationProvider'
      provider_id:
        description: The ID of the notification provider used to send the notification.
        nullable: true
        type: string
        example: sengrid
      resends:
        description: The details of all resends of the notification.
        type: array
        items:
          $ref: '#/components/schemas/Notification'
      resource_id:
        description: The ID of the resource that the Notification refers to.
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      resource_type:
        description: The type of resource that the Notification refers to.
        type: string
        example: order
      to:
        description: The address that the Notification was sent to. This will usually
          be an email address, but can represent other addresses such as a chat bot
          user ID.
        type: string
        example: user@example.com
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  NotificationProvider:
    description: A notification provider represents a notification service installed
      in the Medusa backend, either through a plugin or backend customizations. It
      holds the notification service's installation status.
    required:
    - id
    - is_installed
    type: object
    properties:
      id:
        description: The ID of the notification provider as given by the notification
          service.
        type: string
        example: sendgrid
      is_installed:
        description: Whether the notification service is installed in the current
          version. If a notification service is no longer installed, the `is_installed`
          attribute is set to `false`.
        type: boolean
  Order:
    description: An order is a purchase made by a customer. It holds details about
      payment and fulfillment of the order. An order may also be created from a draft
      order, which is created by an admin user.
    required:
    - billing_address_id
    - canceled_at
    - cart_id
    - created_at
    - currency_code
    - customer_id
    - draft_order_id
    - display_id
    - email
    - external_id
    - fulfillment_status
    - id
    - idempotency_key
    - metadata
    - no_notification
    - object
    - payment_status
    - region_id
    - shipping_address_id
    - status
    - tax_rate
    - updated_at
    type: object
    properties:
      billing_address:
        description: The details of the billing address associated with the order.
        nullable: true
        $ref: '#/components/schemas/Address'
      billing_address_id:
        description: The ID of the billing address associated with the order
        nullable: true
        type: string
        example: addr_01G8ZH853YPY9B94857DY91YGW
      canceled_at:
        description: The date the order was canceled on.
        nullable: true
        type: string
        format: date-time
      cart:
        description: The details of the cart associated with the order.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart associated with the order
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      claims:
        description: The details of the claims created for the order.
        type: array
        items:
          $ref: '#/components/schemas/ClaimOrder'
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      currency:
        description: The details of the currency used in the order.
        nullable: true
        $ref: '#/components/schemas/Currency'
      currency_code:
        description: The 3 character currency code that is used in the order
        type: string
        example: usd
      customer:
        description: The details of the customer associated with the order.
        nullable: true
        $ref: '#/components/schemas/Customer'
      customer_id:
        description: The ID of the customer associated with the order
        type: string
        example: cus_01G2SG30J8C85S4A5CHM2S1NS2
      discount_total:
        description: The total of discount rounded
        type: integer
        example: 800
      discounts:
        description: The details of the discounts applied on the order.
        type: array
        items:
          $ref: '#/components/schemas/Discount'
      display_id:
        description: The order's display ID
        type: integer
        example: 2
      draft_order:
        description: The details of the draft order this order was created from.
        nullable: true
        $ref: '#/components/schemas/DraftOrder'
      draft_order_id:
        description: The ID of the draft order this order was created from.
        nullable: true
        type: string
      edits:
        description: The details of the order edits done on the order.
        type: array
        items:
          $ref: '#/components/schemas/OrderEdit'
      email:
        description: The email associated with the order
        type: string
        format: email
      external_id:
        description: The ID of an external order.
        nullable: true
        type: string
      fulfillment_status:
        description: The order's fulfillment status
        type: string
        enum:
        - not_fulfilled
        - partially_fulfilled
        - fulfilled
        - partially_shipped
        - shipped
        - partially_returned
        - returned
        - canceled
        - requires_action
      fulfillments:
        description: The details of the fulfillments created for the order.
        type: array
        items:
          $ref: '#/components/schemas/Fulfillment'
      gift_card_tax_total:
        description: The total of gift cards with taxes
        type: integer
        example: 0
      gift_card_total:
        description: The total of gift cards
        type: integer
        example: 0
      gift_card_transactions:
        description: The gift card transactions made in the order.
        type: array
        items:
          $ref: '#/components/schemas/GiftCardTransaction'
      gift_cards:
        description: The details of the gift card used in the order.
        type: array
        items:
          $ref: '#/components/schemas/GiftCard'
      id:
        description: The order's ID
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      idempotency_key:
        description: Randomly generated key used to continue the processing of the
          order in case of failure.
        nullable: true
        type: string
      item_tax_total:
        description: The tax total applied on items
        nullable: true
        type: integer
        example: 0
      items:
        description: The details of the line items that belong to the order.
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      no_notification:
        description: Flag for describing whether or not notifications related to this
          should be send.
        nullable: true
        type: boolean
        example: false
      paid_total:
        description: The total amount paid
        type: integer
        example: 8000
      payment_status:
        description: The order's payment status
        type: string
        enum:
        - not_paid
        - awaiting
        - captured
        - partially_refunded
        - refunded
        - canceled
        - requires_action
      payments:
        description: The details of the payments used in the order.
        type: array
        items:
          $ref: '#/components/schemas/Payment'
      raw_discount_total:
        description: The total of discount
        type: integer
        example: 800
      refundable_amount:
        description: The amount that can be refunded
        type: integer
        example: 8200
      refunded_total:
        description: The total amount refunded if the order is returned.
        type: integer
        example: 0
      refunds:
        description: The details of the refunds created for the order.
        type: array
        items:
          $ref: '#/components/schemas/Refund'
      region:
        description: The details of the region this order was created in.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The ID of the region this order was created in.
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      returnable_items:
        description: The details of the line items that are returnable as part of
          the order, swaps, or claims
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      returns:
        description: The details of the returns created for the order.
        type: array
        items:
          $ref: '#/components/schemas/Return'
      sales_channel:
        description: The details of the sales channel this order belongs to.
        nullable: true
        $ref: '#/components/schemas/SalesChannel'
      sales_channel_id:
        description: The ID of the sales channel this order belongs to.
        nullable: true
        type: string
      sales_channels:
        description: The associated sales channels.
        nullable: true
        type: array
        items:
          $ref: '#/components/schemas/SalesChannel'
      shipping_address:
        description: The details of the shipping address associated with the order.
        nullable: true
        $ref: '#/components/schemas/Address'
      shipping_address_id:
        description: The ID of the shipping address associated with the order
        nullable: true
        type: string
        example: addr_01G8ZH853YPY9B94857DY91YGW
      shipping_methods:
        description: The details of the shipping methods used in the order.
        type: array
        items:
          $ref: '#/components/schemas/ShippingMethod'
      shipping_tax_total:
        description: The tax total applied on shipping
        type: integer
        example: 1000
      shipping_total:
        description: The total of shipping
        nullable: true
        type: integer
        example: 1000
      status:
        description: The order's status
        type: string
        enum:
        - pending
        - completed
        - archived
        - canceled
        - requires_action
      subtotal:
        description: The subtotal of the order
        type: integer
        example: 8000
      swaps:
        description: The details of the swaps created for the order.
        type: array
        items:
          $ref: '#/components/schemas/Swap'
      tax_rate:
        description: The order's tax rate
        nullable: true
        type: number
        example: 0
      tax_total:
        description: The total of tax
        type: integer
        example: 0
      total:
        description: The total amount of the order
        type: integer
        example: 8200
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  OrderEdit:
    description: Order edit allows modifying items in an order, such as adding, updating,
      or deleting items from the original order. Once the order edit is confirmed,
      the changes are reflected on the original order.
    required:
    - canceled_at
    - canceled_by
    - confirmed_by
    - confirmed_at
    - created_at
    - created_by
    - declined_at
    - declined_by
    - declined_reason
    - id
    - internal_note
    - order_id
    - payment_collection_id
    - requested_at
    - requested_by
    - status
    - updated_at
    type: object
    properties:
      canceled_at:
        description: The date with timezone at which the edit was cancelled.
        nullable: true
        type: string
        format: date-time
      canceled_by:
        description: The unique identifier of the user or customer who cancelled the
          order edit.
        nullable: true
        type: string
      changes:
        description: The details of all the changes on the original order's line items.
        type: array
        items:
          $ref: '#/components/schemas/OrderItemChange'
      confirmed_at:
        description: The date with timezone at which the edit was confirmed.
        nullable: true
        type: string
        format: date-time
      confirmed_by:
        description: The unique identifier of the user or customer who confirmed the
          order edit.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      created_by:
        description: The unique identifier of the user or customer who created the
          order edit.
        type: string
      declined_at:
        description: The date with timezone at which the edit was declined.
        nullable: true
        type: string
        format: date-time
      declined_by:
        description: The unique identifier of the user or customer who declined the
          order edit.
        nullable: true
        type: string
      declined_reason:
        description: An optional note why  the order edit is declined.
        nullable: true
        type: string
      difference_due:
        description: The difference between the total amount of the order and total
          amount of edited order.
        type: integer
        example: 8200
      discount_total:
        description: The total of discount
        type: integer
        example: 800
      gift_card_tax_total:
        description: The total of the gift card tax amount
        type: integer
        example: 800
      gift_card_total:
        description: The total of the gift card amount
        type: integer
        example: 800
      id:
        description: The order edit's ID
        type: string
        example: oe_01G8TJSYT9M6AVS5N4EMNFS1EK
      internal_note:
        description: An optional note with additional details about the order edit.
        nullable: true
        type: string
        example: Included two more items B to the order.
      items:
        description: The details of the cloned items from the original order with
          the new changes. Once the order edit is confirmed, these line items are
          associated with the original order.
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      order:
        description: The details of the order that this order edit was created for.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that is edited
        type: string
        example: order_01G2SG30J8C85S4A5CHM2S1NS2
      payment_collection:
        description: The details of the payment collection used to authorize additional
          payment if necessary.
        nullable: true
        $ref: '#/components/schemas/PaymentCollection'
      payment_collection_id:
        description: The ID of the payment collection
        nullable: true
        type: string
        example: paycol_01G8TJSYT9M6AVS5N4EMNFS1EK
      requested_at:
        description: The date with timezone at which the edit was requested.
        nullable: true
        type: string
        format: date-time
      requested_by:
        description: The unique identifier of the user or customer who requested the
          order edit.
        nullable: true
        type: string
      shipping_total:
        description: The total of the shipping amount
        type: integer
        example: 800
      status:
        description: The status of the order edit.
        type: string
        enum:
        - confirmed
        - declined
        - requested
        - created
        - canceled
      subtotal:
        description: The total of subtotal
        type: integer
        example: 8000
      tax_total:
        description: The total of tax
        type: integer
        example: 0
      total:
        description: The total amount of the edited order.
        type: integer
        example: 8200
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  OrderItemChange:
    description: An order item change is a change made within an order edit to an
      order's items. These changes are not reflected on the original order until the
      order edit is confirmed.
    required:
    - created_at
    - deleted_at
    - id
    - line_item_id
    - order_edit_id
    - original_line_item_id
    - type
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The order item change's ID
        type: string
        example: oic_01G8TJSYT9M6AVS5N4EMNFS1EK
      line_item:
        description: The details of the resulting line item after the item change.
          This line item is then used in the original order once the order edit is
          confirmed.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      line_item_id:
        description: The ID of the cloned line item.
        nullable: true
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      order_edit:
        description: The details of the order edit the item change is associated with.
        nullable: true
        $ref: '#/components/schemas/OrderEdit'
      order_edit_id:
        description: The ID of the order edit
        type: string
        example: oe_01G2SG30J8C85S4A5CHM2S1NS2
      original_line_item:
        description: The details of the original line item this item change references.
          This is used if the item change updates or deletes the original item.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      original_line_item_id:
        description: The ID of the original line item in the order
        nullable: true
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      type:
        description: The order item change's status
        type: string
        enum:
        - item_add
        - item_remove
        - item_update
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  Payment:
    description: A payment is originally created from a payment session. Once a payment
      session is authorized, the payment is created to represent the authorized amount
      with a given payment method. Payments can be captured, canceled or refunded.
      Payments can be made towards orders, swaps, order edits, or other resources.
    required:
    - amount
    - amount_refunded
    - canceled_at
    - captured_at
    - cart_id
    - created_at
    - currency_code
    - data
    - id
    - idempotency_key
    - metadata
    - order_id
    - provider_id
    - swap_id
    - updated_at
    type: object
    properties:
      amount:
        description: The amount that the Payment has been authorized for.
        type: integer
        example: 100
      amount_refunded:
        description: The amount of the original Payment amount that has been refunded
          back to the Customer.
        type: integer
        example: 0
      canceled_at:
        description: The date with timezone at which the Payment was canceled.
        nullable: true
        type: string
        format: date-time
      captured_at:
        description: The date with timezone at which the Payment was captured.
        nullable: true
        type: string
        format: date-time
      cart:
        description: The details of the cart that the payment session was potentially
          created for.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart that the payment session was potentially created
          for.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      currency:
        description: The details of the currency of the payment.
        nullable: true
        $ref: '#/components/schemas/Currency'
      currency_code:
        description: The 3 character ISO currency code of the payment.
        type: string
        example: usd
      data:
        description: The data required for the Payment Provider to identify, modify
          and process the Payment. Typically this will be an object that holds an
          id to the external payment session, but can be an empty object if the Payment
          Provider doesn't hold any state.
        type: object
        example: {}
      id:
        description: The payment's ID
        type: string
        example: pay_01G2SJNT6DEEWDFNAJ4XWDTHKE
      idempotency_key:
        description: Randomly generated key used to continue the completion of a payment
          in case of failure.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      order:
        description: The details of the order that the payment session was potentially
          created for.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the payment session was potentially
          created for.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      provider_id:
        description: The id of the Payment Provider that is responsible for the Payment
        type: string
        example: manual
      swap:
        description: The details of the swap that this payment was potentially created
          for.
        nullable: true
        $ref: '#/components/schemas/Swap'
      swap_id:
        description: The ID of the swap that this payment was potentially created
          for.
        nullable: true
        type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  PaymentCollection:
    description: A payment collection allows grouping and managing a list of payments
      at one. This can be helpful when making additional payment for order edits or
      integrating installment payments.
    required:
    - amount
    - authorized_amount
    - created_at
    - created_by
    - currency_code
    - deleted_at
    - description
    - id
    - metadata
    - region_id
    - status
    - type
    - updated_at
    type: object
    properties:
      amount:
        description: Amount of the payment collection.
        type: integer
      authorized_amount:
        description: Authorized amount of the payment collection.
        nullable: true
        type: integer
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      created_by:
        description: The ID of the user that created the payment collection.
        type: string
      currency:
        description: The details of the currency this payment collection is associated
          with.
        nullable: true
        $ref: '#/components/schemas/Currency'
      currency_code:
        description: The three character ISO code for the currency this payment collection
          is associated with.
        type: string
        example: usd
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      description:
        description: Description of the payment collection
        nullable: true
        type: string
      id:
        description: The payment collection's ID
        type: string
        example: paycol_01G8TJSYT9M6AVS5N4EMNFS1EK
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      payment_sessions:
        description: The details of the payment sessions created as part of the payment
          collection.
        type: array
        items:
          $ref: '#/components/schemas/PaymentSession'
      payments:
        description: The details of the payments created as part of the payment collection.
        type: array
        items:
          $ref: '#/components/schemas/Payment'
      region:
        description: The details of the region this payment collection is associated
          with.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The ID of the region this payment collection is associated with.
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      status:
        description: The type of the payment collection
        type: string
        enum:
        - not_paid
        - awaiting
        - authorized
        - partially_authorized
        - canceled
      type:
        description: The type of the payment collection
        type: string
        enum:
        - order_edit
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  PaymentProvider:
    description: A payment provider represents a payment service installed in the
      Medusa backend, either through a plugin or backend customizations. It holds
      the payment service's installation status.
    required:
    - id
    - is_installed
    type: object
    properties:
      id:
        description: The ID of the payment provider as given by the payment service.
        type: string
        example: manual
      is_installed:
        description: Whether the payment service is installed in the current version.
          If a payment service is no longer installed, the `is_installed` attribute
          is set to `false`.
        type: boolean
  PaymentSession:
    description: A Payment Session is created when a Customer initilizes the checkout
      flow, and can be used to hold the state of a payment flow. Each Payment Session
      is controlled by a Payment Provider, which is responsible for the communication
      with external payment services. Authorized Payment Sessions will eventually
      get promoted to Payments to indicate that they are authorized for payment processing
      such as capture or refund. Payment sessions can also be used as part of payment
      collections.
    required:
    - amount
    - cart_id
    - created_at
    - data
    - id
    - is_initiated
    - is_selected
    - idempotency_key
    - payment_authorized_at
    - provider_id
    - status
    - updated_at
    type: object
    properties:
      amount:
        description: The amount that the Payment Session has been authorized for.
        nullable: true
        type: integer
        example: 100
      cart:
        description: The details of the cart that the payment session was created
          for.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart that the payment session was created for.
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      data:
        description: The data required for the Payment Provider to identify, modify
          and process the Payment Session. Typically this will be an object that holds
          an id to the external payment session, but can be an empty object if the
          Payment Provider doesn't hold any state.
        type: object
        example: {}
      id:
        description: The payment session's ID
        type: string
        example: ps_01G901XNSRM2YS3ASN9H5KG3FZ
      idempotency_key:
        description: Randomly generated key used to continue the completion of a cart
          in case of failure.
        nullable: true
        type: string
      is_initiated:
        description: A flag to indicate if a communication with the third party provider
          has been initiated.
        type: boolean
        example: true
      is_selected:
        description: A flag to indicate if the Payment Session has been selected as
          the method that will be used to complete the purchase.
        nullable: true
        type: boolean
        example: true
      payment_authorized_at:
        description: The date with timezone at which the Payment Session was authorized.
        nullable: true
        type: string
        format: date-time
      provider_id:
        description: The ID of the Payment Provider that is responsible for the Payment
          Session
        type: string
        example: manual
      status:
        description: Indicates the status of the Payment Session. Will default to
          `pending`, and will eventually become `authorized`. Payment Sessions may
          have the status of `requires_more` to indicate that further actions are
          to be completed by the Customer.
        type: string
        enum:
        - authorized
        - pending
        - requires_more
        - error
        - canceled
        example: pending
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  PostAuthReq:
    description: The admin's credentials used to log in.
    required:
    - email
    - password
    type: object
    properties:
      email:
        description: The user's email.
        type: string
        format: email
      password:
        description: The user's password.
        type: string
        format: password
  PostCustomersCustomerReq:
    description: The details of the customer to update.
    type: object
    properties:
      email:
        description: The Customer's email. You can't update the email of a registered
          customer.
        type: string
        format: email
      first_name:
        description: The Customer's first name.
        type: string
      groups:
        description: A list of customer groups to which the customer belongs.
        type: array
        items:
          properties:
            id:
              description: The ID of a customer group
              type: string
          required:
          - id
          type: object
      last_name:
        description: The Customer's last name.
        type: string
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      password:
        description: The Customer's password.
        type: string
        format: password
      phone:
        description: The Customer's phone number.
        type: string
  PostCustomersReq:
    description: The details of the customer to create.
    required:
    - email
    - first_name
    - last_name
    - password
    type: object
    properties:
      email:
        description: The customer's email.
        type: string
        format: email
      first_name:
        description: The customer's first name.
        type: string
      last_name:
        description: The customer's last name.
        type: string
      metadata:
        description: An optional set of key-value pairs to hold additional information.
        type: object
      password:
        description: The customer's password.
        type: string
        format: password
      phone:
        description: The customer's phone number.
        type: string
  PriceList:
    description: A Price List represents a set of prices that override the default
      price for one or more product variants.
    required:
    - created_at
    - deleted_at
    - description
    - ends_at
    - id
    - name
    - starts_at
    - status
    - type
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      customer_groups:
        description: The details of the customer groups that the Price List can apply
          to.
        type: array
        items:
          $ref: '#/components/schemas/CustomerGroup'
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      description:
        description: The price list's description
        type: string
        example: Prices for VIP customers
      ends_at:
        description: The date with timezone that the Price List stops being valid.
        nullable: true
        type: string
        format: date-time
      id:
        description: The price list's ID
        type: string
        example: pl_01G8X3CKJXCG5VXVZ87H9KC09W
      includes_tax:
        description: Whether the price list prices include tax
        type: boolean
      name:
        description: The price list's name
        type: string
        example: VIP Prices
      prices:
        description: The prices that belong to the price list, represented as a Money
          Amount.
        type: array
        items:
          $ref: '#/components/schemas/MoneyAmount'
      starts_at:
        description: The date with timezone that the Price List starts being valid.
        nullable: true
        type: string
        format: date-time
      status:
        description: The status of the Price List
        type: string
        enum:
        - active
        - draft
      type:
        description: The type of Price List. This can be one of either `sale` or `override`.
        type: string
        enum:
        - sale
        - override
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ProductCategory:
    description: A product category can be used to categorize products into a hierarchy
      of categories.
    required:
    - category_children
    - created_at
    - handle
    - id
    - is_active
    - is_internal
    - metadata
    - mpath
    - name
    - parent_category_id
    - updated_at
    type: object
    properties:
      category_children:
        description: The details of the category's children.
        type: array
        items:
          $ref: '#/components/schemas/ProductCategory'
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      description:
        description: The product category's description.
        type: string
      handle:
        description: A unique string that identifies the Product Category - can for
          example be used in slug structures.
        type: string
        example: regular-fit
      id:
        description: The product category's ID
        type: string
        example: pcat_01G2SG30J8C85S4A5CHM2S1NS2
      is_active:
        description: A flag to make product category visible/hidden in the store front
        type: boolean
      is_internal:
        description: A flag to make product category an internal category for admins
        type: boolean
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      mpath:
        description: A string for Materialized Paths - used for finding ancestors
          and descendents
        nullable: true
        type: string
        example: pcat_id1.pcat_id2.pcat_id3
      name:
        description: The product category's name
        type: string
        example: Regular Fit
      parent_category:
        description: The details of the parent of this category.
        nullable: true
        $ref: '#/components/schemas/ProductCategory'
      parent_category_id:
        description: The ID of the parent category.
        nullable: true
        type: string
      products:
        description: The details of the products that belong to this category.
        type: array
        items:
          $ref: '#/components/schemas/Product'
      rank:
        description: An integer that depicts the rank of category in a tree node
        type: integer
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ProductCollection:
    description: A Product Collection allows grouping together products for promotional
      purposes. For example, an admin can create a Summer collection, add products
      to it, and showcase it on the storefront.
    required:
    - created_at
    - deleted_at
    - handle
    - id
    - metadata
    - title
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      handle:
        description: A unique string that identifies the Product Collection - can
          for example be used in slug structures.
        nullable: true
        type: string
        example: summer-collection
      id:
        description: The product collection's ID
        type: string
        example: pcol_01F0YESBFAZ0DV6V831JXWH0BG
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      products:
        description: The details of the products that belong to this product collection.
        type: array
        items:
          $ref: '#/components/schemas/Product'
      title:
        description: The title that the Product Collection is identified by.
        type: string
        example: Summer Collection
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ProductOption:
    description: A Product Option defines properties that may vary between different
      variants of a Product. Common Product Options are "Size" and "Color". Admins
      are free to create any product options.
    required:
    - created_at
    - deleted_at
    - id
    - metadata
    - product_id
    - title
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The product option's ID
        type: string
        example: opt_01F0YESHQBZVKCEXJ24BS6PCX3
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product:
        description: The details of the product that this product option belongs to.
        nullable: true
        $ref: '#/components/schemas/Product'
      product_id:
        description: The ID of the product that this product option belongs to.
        type: string
        example: prod_01G1G5V2MBA328390B5AXJ610F
      title:
        description: The title that the Product Option is defined by (e.g. `Size`).
        type: string
        example: Size
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      values:
        description: The details of the values of the product option.
        type: array
        items:
          $ref: '#/components/schemas/ProductOptionValue'
  ProductOptionValue:
    description: An option value is one of the possible values of a Product Option.
      Product Variants specify a unique combination of product option values.
    required:
    - created_at
    - deleted_at
    - id
    - metadata
    - option_id
    - updated_at
    - value
    - variant_id
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The product option value's ID
        type: string
        example: optval_01F0YESHR7S6ECD03RF6W12DSJ
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      option:
        description: The details of the product option that the Product Option Value
          belongs to.
        nullable: true
        $ref: '#/components/schemas/ProductOption'
      option_id:
        description: The ID of the Product Option that the Product Option Value belongs
          to.
        type: string
        example: opt_01F0YESHQBZVKCEXJ24BS6PCX3
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value that the Product Variant has defined for the specific
          Product Option (e.g. if the Product Option is "Size" this value could be
          `Small`, `Medium` or `Large`).
        type: string
        example: large
      variant:
        description: The details of the product variant that uses this product option
          value.
        nullable: true
        $ref: '#/components/schemas/ProductVariant'
      variant_id:
        description: The ID of the product variant that uses this product option value.
        type: string
        example: variant_01G1G5V2MRX2V3PVSR2WXYPFB6
  ProductTag:
    description: A Product Tag can be added to Products for easy filtering and grouping.
    required:
    - created_at
    - deleted_at
    - id
    - metadata
    - updated_at
    - value
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The product tag's ID
        type: string
        example: ptag_01G8K2MTMG9168F2B70S1TAVK3
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value that the Product Tag represents
        type: string
        example: Pants
  ProductTaxRate:
    description: This represents the association between a tax rate and a product
      to indicate that the product is taxed in a way different than the default.
    required:
    - created_at
    - metadata
    - product_id
    - rate_id
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product:
        description: The details of the product.
        nullable: true
        $ref: '#/components/schemas/Product'
      product_id:
        description: The ID of the Product
        type: string
        example: prod_01G1G5V2MBA328390B5AXJ610F
      rate_id:
        description: The ID of the Tax Rate
        type: string
        example: txr_01G8XDBAWKBHHJRKH0AV02KXBR
      tax_rate:
        description: The details of the tax rate.
        nullable: true
        $ref: '#/components/schemas/TaxRate'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ProductType:
    description: A Product Type can be added to Products for filtering and reporting
      purposes.
    required:
    - created_at
    - deleted_at
    - id
    - metadata
    - updated_at
    - value
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The product type's ID
        type: string
        example: ptyp_01G8X9A7ESKAJXG2H0E6F1MW7A
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value that the Product Type represents.
        type: string
        example: Clothing
  ProductTypeTaxRate:
    description: This represents the association between a tax rate and a product
      type to indicate that the product type is taxed in a different way than the
      default.
    required:
    - created_at
    - metadata
    - product_type_id
    - rate_id
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      product_type:
        description: The details of the product type.
        nullable: true
        $ref: '#/components/schemas/ProductType'
      product_type_id:
        description: The ID of the Product type
        type: string
        example: ptyp_01G8X9A7ESKAJXG2H0E6F1MW7A
      rate_id:
        description: The id of the Tax Rate
        type: string
        example: txr_01G8XDBAWKBHHJRKH0AV02KXBR
      tax_rate:
        description: The details of the tax rate.
        nullable: true
        $ref: '#/components/schemas/TaxRate'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ProductVariant:
    description: A Product Variant represents a Product with a specific set of Product
      Option configurations. The maximum number of Product Variants that a Product
      can have is given by the number of available Product Option combinations. A
      product must at least have one product variant.
    required:
    - allow_backorder
    - barcode
    - created_at
    - deleted_at
    - ean
    - height
    - hs_code
    - id
    - inventory_quantity
    - length
    - manage_inventory
    - material
    - metadata
    - mid_code
    - origin_country
    - product_id
    - sku
    - title
    - upc
    - updated_at
    - weight
    - width
    type: object
    properties:
      allow_backorder:
        description: Whether the Product Variant should be purchasable when `inventory_quantity`
          is 0.
        type: boolean
      barcode:
        description: A generic field for a GTIN number that can be used to identify
          the Product Variant.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      ean:
        description: An EAN barcode number that can be used to identify the Product
          Variant.
        nullable: true
        type: string
      height:
        description: The height of the Product Variant. May be used in shipping rate
          calculations.
        nullable: true
        type: number
      hs_code:
        description: The Harmonized System code of the Product Variant. May be used
          by Fulfillment Providers to pass customs information to shipping carriers.
        nullable: true
        type: string
      id:
        description: The product variant's ID
        type: string
        example: variant_01G1G5V2MRX2V3PVSR2WXYPFB6
      inventory_items:
        description: The details inventory items of the product variant.
        type: array
        items:
          $ref: '#/components/schemas/ProductVariantInventoryItem'
      inventory_quantity:
        description: The current quantity of the item that is stocked.
        type: integer
        example: 100
      length:
        description: The length of the Product Variant. May be used in shipping rate
          calculations.
        nullable: true
        type: number
      manage_inventory:
        description: Whether Medusa should manage inventory for the Product Variant.
        type: boolean
      material:
        description: The material and composition that the Product Variant is made
          of, May be used by Fulfillment Providers to pass customs information to
          shipping carriers.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      mid_code:
        description: The Manufacturers Identification code that identifies the manufacturer
          of the Product Variant. May be used by Fulfillment Providers to pass customs
          information to shipping carriers.
        nullable: true
        type: string
      options:
        description: The details of the product options that this product variant
          defines values for.
        type: array
        items:
          $ref: '#/components/schemas/ProductOptionValue'
      origin_country:
        description: The country in which the Product Variant was produced. May be
          used by Fulfillment Providers to pass customs information to shipping carriers.
        nullable: true
        type: string
      prices:
        description: The details of the prices of the Product Variant, each represented
          as a Money Amount. Each Money Amount represents a price in a given currency
          or a specific Region.
        type: array
        items:
          $ref: '#/components/schemas/MoneyAmount'
      product:
        description: The details of the product that the product variant belongs to.
        nullable: true
        $ref: '#/components/schemas/Product'
      product_id:
        description: The ID of the product that the product variant belongs to.
        type: string
        example: prod_01G1G5V2MBA328390B5AXJ610F
      purchasable:
        description: |
          Only used with the inventory modules.
          A boolean value indicating whether the Product Variant is purchasable.
          A variant is purchasable if:
            - inventory is not managed
            - it has no inventory items
            - it is in stock
            - it is backorderable.
        type: boolean
      sku:
        description: The unique stock keeping unit used to identify the Product Variant.
          This will usually be a unique identifer for the item that is to be shipped,
          and can be referenced across multiple systems.
        nullable: true
        type: string
        example: shirt-123
      title:
        description: A title that can be displayed for easy identification of the
          Product Variant.
        type: string
        example: Small
      upc:
        description: A UPC barcode number that can be used to identify the Product
          Variant.
        nullable: true
        type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      variant_rank:
        description: The ranking of this variant
        nullable: true
        type: number
      weight:
        description: The weight of the Product Variant. May be used in shipping rate
          calculations.
        nullable: true
        type: number
      width:
        description: The width of the Product Variant. May be used in shipping rate
          calculations.
        nullable: true
        type: number
  ProductVariantInventoryItem:
    description: A Product Variant Inventory Item links variants with inventory items
      and denotes the required quantity of the variant.
    required:
    - created_at
    - deleted_at
    - id
    - inventory_item_id
    - required_quantity
    - updated_at
    - variant_id
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The product variant inventory item's ID
        type: string
        example: pvitem_01G8X9A7ESKAJXG2H0E6F1MW7A
      inventory_item_id:
        description: The id of the inventory item
        type: string
      required_quantity:
        description: The quantity of an inventory item required for the variant.
        type: integer
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      variant:
        description: The details of the product variant.
        nullable: true
        $ref: '#/components/schemas/ProductVariant'
      variant_id:
        description: The id of the variant.
        type: string
  PublishableApiKey:
    description: A Publishable API key defines scopes that resources are available
      in. Then, it can be used in request to infer the resources without having to
      directly pass them. For example, a publishable API key can be associated with
      one or more sales channels. Then, when the publishable API key is passed in
      the header of a request, it is inferred what sales channel is being used without
      having to pass the sales channel as a query or body parameter of the request.
      Publishable API keys can only be used with sales channels, at the moment.
    required:
    - created_at
    - created_by
    - id
    - revoked_by
    - revoked_at
    - title
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      created_by:
        description: The unique identifier of the user that created the key.
        nullable: true
        type: string
        example: usr_01G1G5V26F5TB3GPAPNJ8X1S3V
      id:
        description: The key's ID
        type: string
        example: pk_01G1G5V27GYX4QXNARRQCW1N8T
      revoked_at:
        description: The date with timezone at which the key was revoked.
        nullable: true
        type: string
        format: date-time
      revoked_by:
        description: The unique identifier of the user that revoked the key.
        nullable: true
        type: string
        example: usr_01G1G5V26F5TB3GPAPNJ8X1S3V
      title:
        description: The key's title.
        type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  PublishableApiKeySalesChannel:
    description: This represents the association between the Publishable API keys
      and Sales Channels
    required:
    - publishable_key_id
    - sales_channel_id
    - created_at
    - updated_at
    - deleted_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The relation's ID
        type: string
        example: pksc_01G8X9A7ESKAJXG2H0E6F1MW7A
      publishable_key_id:
        description: The publishable API key's ID
        type: string
        example: pak_01G1G5V21KADXNGH29BJMAJ4B4
      sales_channel_id:
        description: The sales channel's ID
        type: string
        example: sc_01G1G5V21KADXNGH29BJMAJ4B4
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  Refund:
    description: A refund represents an amount of money transfered back to the customer
      for a given reason. Refunds may occur in relation to Returns, Swaps and Claims,
      but can also be initiated by an admin for an order.
    required:
    - amount
    - created_at
    - id
    - idempotency_key
    - metadata
    - note
    - order_id
    - payment_id
    - reason
    - updated_at
    type: object
    properties:
      amount:
        description: The amount that has be refunded to the Customer.
        type: integer
        example: 1000
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      id:
        description: The refund's ID
        type: string
        example: ref_01G1G5V27GYX4QXNARRQCW1N8T
      idempotency_key:
        description: Randomly generated key used to continue the completion of the
          refund in case of failure.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      note:
        description: An optional note explaining why the amount was refunded.
        nullable: true
        type: string
        example: I didn't like it
      order:
        description: The details of the order this refund was created for.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order this refund was created for.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      payment:
        description: The details of the payment associated with the refund.
        nullable: true
        $ref: '#/components/schemas/Payment'
      payment_id:
        description: The payment's ID, if available.
        nullable: true
        type: string
        example: pay_01G8ZCC5W42ZNY842124G7P5R9
      reason:
        description: The reason given for the Refund, will automatically be set when
          processed as part of a Swap, Claim or Return.
        type: string
        enum:
        - discount
        - return
        - swap
        - claim
        - other
        example: return
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  Region:
    description: A region holds settings specific to a geographical location, including
      the currency, tax rates, and fulfillment and payment providers. A Region can
      consist of multiple countries to accomodate common shopping settings across
      countries.
    required:
    - automatic_taxes
    - created_at
    - currency_code
    - deleted_at
    - gift_cards_taxable
    - id
    - metadata
    - name
    - tax_code
    - tax_provider_id
    - tax_rate
    - updated_at
    type: object
    properties:
      automatic_taxes:
        description: Whether taxes should be automated in this region.
        type: boolean
      countries:
        description: The details of the countries included in this region.
        type: array
        items:
          $ref: '#/components/schemas/Country'
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      currency:
        description: The details of the currency used in the region.
        nullable: true
        $ref: '#/components/schemas/Currency'
      currency_code:
        description: The three character currency code used in the region.
        type: string
        example: usd
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      fulfillment_providers:
        description: The details of the fulfillment providers that can be used to
          fulfill items of orders and similar resources in the region.
        type: array
        items:
          $ref: '#/components/schemas/FulfillmentProvider'
      gift_cards_taxable:
        description: Whether the gift cards are taxable or not in this region.
        type: boolean
      id:
        description: The region's ID
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      includes_tax:
        description: Whether the prices for the region include tax
        type: boolean
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: The name of the region as displayed to the customer. If the Region
          only has one country it is recommended to write the country name.
        type: string
        example: EU
      payment_providers:
        description: The details of the payment providers that can be used to process
          payments in the region.
        type: array
        items:
          $ref: '#/components/schemas/PaymentProvider'
      tax_code:
        description: The tax code used on purchases in the Region. This may be used
          by other systems for accounting purposes.
        nullable: true
        type: string
      tax_provider:
        description: The details of the tax provider used in the region.
        nullable: true
        $ref: '#/components/schemas/TaxProvider'
      tax_provider_id:
        description: The ID of the tax provider used in this region
        nullable: true
        type: string
      tax_rate:
        description: The tax rate that should be charged on purchases in the Region.
        type: number
        example: 0
      tax_rates:
        description: The details of the tax rates used in the region, aside from the
          default rate.
        type: array
        items:
          $ref: '#/components/schemas/TaxRate'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ResetPasswordRequest:
    description: The details of the password reset request.
    required:
    - token
    - password
    type: object
    properties:
      email:
        description: The User's email.
        type: string
        format: email
      password:
        description: The User's new password.
        type: string
        format: password
      token:
        description: The password-reset token generated when the password reset was
          requested.
        type: string
  ResetPasswordTokenRequest:
    description: The details of the password reset token request.
    required:
    - email
    type: object
    properties:
      email:
        description: The User's email.
        type: string
        format: email
  Return:
    description: A Return holds information about Line Items that a Customer wishes
      to send back, along with how the items will be returned. Returns can also be
      used as part of a Swap or a Claim.
    required:
    - claim_order_id
    - created_at
    - id
    - idempotency_key
    - location_id
    - metadata
    - no_notification
    - order_id
    - received_at
    - refund_amount
    - shipping_data
    - status
    - swap_id
    - updated_at
    type: object
    properties:
      claim_order:
        description: The details of the claim that the return may belong to.
        nullable: true
        $ref: '#/components/schemas/ClaimOrder'
      claim_order_id:
        description: The ID of the claim that the return may belong to.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      id:
        description: The return's ID
        type: string
        example: ret_01F0YET7XPCMF8RZ0Y151NZV2V
      idempotency_key:
        description: Randomly generated key used to continue the completion of the
          return in case of failure.
        nullable: true
        type: string
      items:
        description: The details of the items that the customer is returning.
        type: array
        items:
          $ref: '#/components/schemas/ReturnItem'
      location_id:
        description: The ID of the stock location the return will be added back.
        nullable: true
        type: string
        example: sloc_01G8TJSYT9M6AVS5N4EMNFS1EK
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      no_notification:
        description: When set to true, no notification will be sent related to this
          return.
        nullable: true
        type: boolean
        example: false
      order:
        description: The details of the order that the return was created for.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the return was created for.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      received_at:
        description: The date with timezone at which the return was received.
        nullable: true
        type: string
        format: date-time
      refund_amount:
        description: The amount that should be refunded as a result of the return.
        type: integer
        example: 1000
      shipping_data:
        description: Data about the return shipment as provided by the Fulfilment
          Provider that handles the return shipment.
        nullable: true
        type: object
        example: {}
      shipping_method:
        description: The details of the Shipping Method that will be used to send
          the Return back. Can be null if the Customer will handle the return shipment
          themselves.
        nullable: true
        $ref: '#/components/schemas/ShippingMethod'
      status:
        description: Status of the Return.
        type: string
        enum:
        - requested
        - received
        - requires_action
        - canceled
      swap:
        description: The details of the swap that the return may belong to.
        nullable: true
        $ref: '#/components/schemas/Swap'
      swap_id:
        description: The ID of the swap that the return may belong to.
        nullable: true
        type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ReturnItem:
    description: A return item represents a line item in an order that is to be returned.
      It includes details related to the return and the reason behind it.
    required:
    - is_requested
    - item_id
    - metadata
    - note
    - quantity
    - reason_id
    - received_quantity
    - requested_quantity
    - return_id
    type: object
    properties:
      is_requested:
        description: Whether the Return Item was requested initially or received unexpectedly
          in the warehouse.
        type: boolean
      item:
        description: The details of the line item in the original order to be returned.
        nullable: true
        $ref: '#/components/schemas/LineItem'
      item_id:
        description: The ID of the Line Item that the Return Item references.
        type: string
        example: item_01G8ZC9GWT6B2GP5FSXRXNFNGN
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      note:
        description: An optional note with additional details about the Return.
        nullable: true
        type: string
        example: I didn't like it.
      quantity:
        description: The quantity of the Line Item to be returned.
        type: integer
        example: 1
      reason:
        description: The details of the reason for returning the item.
        nullable: true
        $ref: '#/components/schemas/ReturnReason'
      reason_id:
        description: The ID of the reason for returning the item.
        nullable: true
        type: string
        example: rr_01G8X82GCCV2KSQHDBHSSAH5TQ
      received_quantity:
        description: The quantity that was received in the warehouse.
        nullable: true
        type: integer
        example: 1
      requested_quantity:
        description: The quantity that was originally requested to be returned.
        nullable: true
        type: integer
        example: 1
      return_id:
        description: The ID of the Return that the Return Item belongs to.
        type: string
        example: ret_01F0YET7XPCMF8RZ0Y151NZV2V
      return_order:
        description: Details of the Return that the Return Item belongs to.
        nullable: true
        $ref: '#/components/schemas/Return'
  ReturnReason:
    description: A Return Reason is a value defined by an admin. It can be used on
      Return Items in order to indicate why a Line Item was returned.
    required:
    - created_at
    - deleted_at
    - description
    - id
    - label
    - metadata
    - parent_return_reason_id
    - updated_at
    - value
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      description:
        description: A description of the Reason.
        nullable: true
        type: string
        example: Items that are damaged
      id:
        description: The return reason's ID
        type: string
        example: rr_01G8X82GCCV2KSQHDBHSSAH5TQ
      label:
        description: A text that can be displayed to the Customer as a reason.
        type: string
        example: Damaged goods
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      parent_return_reason:
        description: The details of the parent reason.
        nullable: true
        $ref: '#/components/schemas/ReturnReason'
      parent_return_reason_id:
        description: The ID of the parent reason.
        nullable: true
        type: string
      return_reason_children:
        description: The details of the child reasons.
        $ref: '#/components/schemas/ReturnReason'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      value:
        description: The value to identify the reason by.
        type: string
        example: damaged
  SalesChannelLocation:
    description: This represents the association between a sales channel and a stock
      locations.
    required:
    - created_at
    - deleted_at
    - id
    - location_id
    - sales_channel_id
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The Sales Channel Stock Location's ID
        type: string
        example: scloc_01G8X9A7ESKAJXG2H0E6F1MW7A
      location_id:
        description: The ID of the Location Stock.
        type: string
      sales_channel:
        description: The details of the sales channel the location is associated with.
        nullable: true
        $ref: '#/components/schemas/SalesChannel'
      sales_channel_id:
        description: The ID of the Sales Channel
        type: string
        example: sc_01G8X9A7ESKAJXG2H0E6F1MW7A
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ShippingMethod:
    description: A Shipping Method represents a way in which an Order or Return can
      be shipped. Shipping Methods are created from a Shipping Option, but may contain
      additional details that can be necessary for the Fulfillment Provider to handle
      the shipment. If the shipping method is created for a return, it may be associated
      with a claim or a swap that the return is part of.
    required:
    - cart_id
    - claim_order_id
    - data
    - id
    - order_id
    - price
    - return_id
    - shipping_option_id
    - swap_id
    type: object
    properties:
      cart:
        description: The details of the cart that the shipping method is used in.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart that the shipping method is used in.
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      claim_order:
        description: The details of the claim that the shipping method is used in.
        nullable: true
        $ref: '#/components/schemas/ClaimOrder'
      claim_order_id:
        description: The ID of the claim that the shipping method is used in.
        nullable: true
        type: string
      data:
        description: Additional data that the Fulfillment Provider needs to fulfill
          the shipment. This is used in combination with the Shipping Options data,
          and may contain information such as a drop point id.
        type: object
        example: {}
      id:
        description: The shipping method's ID
        type: string
        example: sm_01F0YET7DR2E7CYVSDHM593QG2
      includes_tax:
        description: Whether the shipping method price include tax
        type: boolean
      order:
        description: The details of the order that the shipping method is used in.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the shipping method is used in.
        nullable: true
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      price:
        description: The amount to charge for the Shipping Method. The currency of
          the price is defined by the Region that the Order that the Shipping Method
          belongs to is a part of.
        type: integer
        example: 200
      return_id:
        description: The ID of the return that the shipping method is used in.
        nullable: true
        type: string
      return_order:
        description: The details of the return that the shipping method is used in.
        nullable: true
        $ref: '#/components/schemas/Return'
      shipping_option:
        description: The details of the shipping option the method was created from.
        nullable: true
        $ref: '#/components/schemas/ShippingOption'
      shipping_option_id:
        description: The ID of the Shipping Option that the Shipping Method is built
          from.
        type: string
        example: so_01G1G5V27GYX4QXNARRQCW1N8T
      subtotal:
        description: The subtotal of the shipping
        type: integer
        example: 8000
      swap:
        description: The details of the swap that the shipping method is used in.
        nullable: true
        $ref: '#/components/schemas/Swap'
      swap_id:
        description: The ID of the swap that the shipping method is used in.
        nullable: true
        type: string
      tax_lines:
        description: The details of the tax lines applied on the shipping method.
        type: array
        items:
          $ref: '#/components/schemas/ShippingMethodTaxLine'
      tax_total:
        description: The total of tax
        type: integer
        example: 0
      total:
        description: The total amount of the shipping
        type: integer
        example: 8200
  ShippingOption:
    description: A Shipping Option represents a way in which an Order or Return can
      be shipped. Shipping Options have an associated Fulfillment Provider that will
      be used when the fulfillment of an Order is initiated. Shipping Options themselves
      cannot be added to Carts, but serve as a template for Shipping Methods. This
      distinction makes it possible to customize individual Shipping Methods with
      additional information.
    required:
    - admin_only
    - amount
    - created_at
    - data
    - deleted_at
    - id
    - is_return
    - metadata
    - name
    - price_type
    - profile_id
    - provider_id
    - region_id
    - updated_at
    type: object
    properties:
      admin_only:
        description: Flag to indicate if the Shipping Option usage is restricted to
          admin users.
        type: boolean
      amount:
        description: The amount to charge for shipping when the Shipping Option price
          type is `flat_rate`.
        nullable: true
        type: integer
        example: 200
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      data:
        description: The data needed for the Fulfillment Provider to identify the
          Shipping Option.
        type: object
        example: {}
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The shipping option's ID
        type: string
        example: so_01G1G5V27GYX4QXNARRQCW1N8T
      includes_tax:
        description: Whether the shipping option price include tax
        type: boolean
      is_return:
        description: Flag to indicate if the Shipping Option can be used for Return
          shipments.
        type: boolean
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: The name given to the Shipping Option - this may be displayed
          to the Customer.
        type: string
        example: PostFake Standard
      price_type:
        description: The type of pricing calculation that is used when creatin Shipping
          Methods from the Shipping Option. Can be `flat_rate` for fixed prices or
          `calculated` if the Fulfillment Provider can provide price calulations.
        type: string
        enum:
        - flat_rate
        - calculated
        example: flat_rate
      profile:
        description: The details of the shipping profile that the shipping option
          belongs to.
        nullable: true
        $ref: '#/components/schemas/ShippingProfile'
      profile_id:
        description: The ID of the Shipping Profile that the shipping option belongs
          to.
        type: string
        example: sp_01G1G5V239ENSZ5MV4JAR737BM
      provider:
        description: The details of the fulfillment provider that will be used to
          later to process the shipping method created from this shipping option and
          its fulfillments.
        nullable: true
        $ref: '#/components/schemas/FulfillmentProvider'
      provider_id:
        description: The ID of the fulfillment provider that will be used to later
          to process the shipping method created from this shipping option and its
          fulfillments.
        type: string
        example: manual
      region:
        description: The details of the region this shipping option can be used in.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The ID of the region this shipping option can be used in.
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      requirements:
        description: The details of the requirements that must be satisfied for the
          Shipping Option to be available for usage in a Cart.
        type: array
        items:
          $ref: '#/components/schemas/ShippingOptionRequirement'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ShippingOptionRequirement:
    description: A shipping option requirement defines conditions that a Cart must
      satisfy for the Shipping Option to be available for usage in the Cart.
    required:
    - amount
    - deleted_at
    - id
    - shipping_option_id
    - type
    type: object
    properties:
      amount:
        description: The amount to compare the Cart subtotal to.
        type: integer
        example: 100
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The shipping option requirement's ID
        type: string
        example: sor_01G1G5V29AB4CTNDRFSRWSRKWD
      shipping_option:
        description: The details of the shipping option that the requirements belong
          to.
        nullable: true
        $ref: '#/components/schemas/ShippingOption'
      shipping_option_id:
        description: The ID of the shipping option that the requirements belong to.
        type: string
        example: so_01G1G5V27GYX4QXNARRQCW1N8T
      type:
        description: The type of the requirement, this defines how the value will
          be compared to the Cart's total. `min_subtotal` requirements define the
          minimum subtotal that is needed for the Shipping Option to be available,
          while the `max_subtotal` defines the maximum subtotal that the Cart can
          have for the Shipping Option to be available.
        type: string
        enum:
        - min_subtotal
        - max_subtotal
        example: min_subtotal
  ShippingProfile:
    description: A Shipping Profile has a set of defined Shipping Options that can
      be used to fulfill a given set of Products. For example, gift cards are shipped
      differently than physical products, so a shipping profile with the type `gift_card`
      groups together the shipping options that can only be used for gift cards.
    required:
    - created_at
    - deleted_at
    - id
    - metadata
    - name
    - type
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      id:
        description: The shipping profile's ID
        type: string
        example: sp_01G1G5V239ENSZ5MV4JAR737BM
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: The name given to the Shipping profile - this may be displayed
          to the Customer.
        type: string
        example: Default Shipping Profile
      products:
        description: The details of the products that the Shipping Profile defines
          Shipping Options for. Available if the relation `products` is expanded.
        type: array
        items:
          $ref: '#/components/schemas/Product'
      shipping_options:
        description: The details of the shipping options that can be used to create
          shipping methods for the Products in the Shipping Profile.
        type: array
        items:
          $ref: '#/components/schemas/ShippingOption'
      type:
        description: The type of the Shipping Profile, may be `default`, `gift_card`
          or `custom`.
        type: string
        enum:
        - default
        - gift_card
        - custom
        example: default
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  ShippingTaxRate:
    description: This represents the tax rates applied on a shipping option.
    required:
    - created_at
    - metadata
    - rate_id
    - shipping_option_id
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      rate_id:
        description: The ID of the associated tax rate.
        type: string
        example: txr_01G8XDBAWKBHHJRKH0AV02KXBR
      shipping_option:
        description: The details of the shipping option.
        nullable: true
        $ref: '#/components/schemas/ShippingOption'
      shipping_option_id:
        description: The ID of the shipping option.
        type: string
        example: so_01G1G5V27GYX4QXNARRQCW1N8T
      tax_rate:
        description: The details of the associated tax rate.
        nullable: true
        $ref: '#/components/schemas/TaxRate'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  StagedJob:
    description: A staged job resource
    required:
    - data
    - event_name
    - id
    - options
    type: object
    properties:
      data:
        description: Data necessary for the job
        type: object
        example: {}
      event_name:
        description: The name of the event
        type: string
        example: order.placed
      id:
        description: The staged job's ID
        type: string
        example: job_01F0YET7BZTARY9MKN1SJ7AAXF
      option:
        description: The staged job's option
        type: object
        example: {}
  Store:
    description: A store holds the main settings of the commerce shop. By default,
      only one store is created and used within the Medusa backend. It holds settings
      related to the name of the store, available currencies, and more.
    required:
    - created_at
    - default_currency_code
    - default_location_id
    - id
    - invite_link_template
    - metadata
    - name
    - payment_link_template
    - swap_link_template
    - updated_at
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      currencies:
        description: The details of the enabled currencies in the store.
        type: array
        items:
          $ref: '#/components/schemas/Currency'
      default_currency:
        description: The details of the store's default currency.
        nullable: true
        $ref: '#/components/schemas/Currency'
      default_currency_code:
        description: The three character currency code that is the default of the
          store.
        type: string
        example: usd
      default_location_id:
        description: The location ID the store is associated with.
        nullable: true
        type: string
      default_sales_channel:
        description: The details of the store's default sales channel.
        nullable: true
        $ref: '#/components/schemas/SalesChannel'
      default_sales_channel_id:
        description: The ID of the store's default sales channel.
        nullable: true
        type: string
      id:
        description: The store's ID
        type: string
        example: store_01G1G5V21KADXNGH29BJMAJ4B4
      invite_link_template:
        description: A template to generate Invite links from
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: The name of the Store - this may be displayed to the Customer.
        type: string
        example: Medusa Store
      payment_link_template:
        description: A template to generate Payment links from. Use {{cart_id}} to
          include the payment's `cart_id` in the link.
        nullable: true
        type: string
      swap_link_template:
        description: A template to generate Swap links from. Use {{cart_id}} to include
          the Swap's `cart_id` in the link.
        nullable: true
        type: string
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  StorePostCartReq:
    description: The details of the cart to be created.
    type: object
    properties:
      context:
        description: An object to provide context to the Cart. The `context` field
          is automatically populated with `ip` and `user_agent`
        type: object
        example:
          ip: ::1
          user_agent: Chrome
      country_code:
        description: The two character ISO country code to create the Cart in. Setting
          this parameter will set the country code of the shipping address.
        type: string
      items:
        description: An array of product variants to generate line items from.
        type: array
        items:
          properties:
            quantity:
              description: The quantity to add into the cart.
              type: integer
            variant_id:
              description: The ID of the Product Variant.
              type: string
          required:
          - variant_id
          - quantity
          type: object
      region_id:
        description: The ID of the Region to create the Cart in. Setting the cart's
          region can affect the pricing of the items in the cart as well as the used
          currency. If this parameter is not provided, the first region in the store
          is used by default.
        type: string
      sales_channel_id:
        description: The ID of the Sales channel to create the Cart in. The cart's
          sales channel affects which products can be added to the cart. If a product
          does not exist in the cart's sales channel, it cannot be added to the cart.
          If you add a publishable API key in the header of this request and specify
          a sales channel ID, the specified sales channel must be within the scope
          of the publishable API key's resources. If you add a publishable API key
          in the header of this request, you don't specify a sales channel ID, and
          the publishable API key is associated with one sales channel, that sales
          channel will be attached to the cart. If no sales channel is passed and
          no publishable API key header is passed or the publishable API key isn't
          associated with any sales channel, the cart will not be associated with
          any sales channel.
        type: string
  StorePostCartsCartLineItemsItemReq:
    description: The details to update of the line item.
    required:
    - quantity
    type: object
    properties:
      metadata:
        description: An optional key-value map with additional details about the Line
          Item. If omitted, the metadata will remain unchanged."
        type: object
      quantity:
        description: The quantity of the line item in the cart.
        type: number
  StorePostCartsCartPaymentSessionReq:
    description: The details of the payment session to set.
    required:
    - provider_id
    type: object
    properties:
      provider_id:
        description: The ID of the Payment Provider.
        type: string
  StorePostCartsCartPaymentSessionUpdateReq:
    required:
    - data
    type: object
    properties:
      data:
        description: The data to update the payment session with.
        type: object
  StorePostCartsCartReq:
    description: The details to update of the cart.
    type: object
    properties:
      billing_address:
        description: The Address to be used for billing purposes.
      context:
        description: An object to provide context to the Cart. The `context` field
          is automatically populated with `ip` and `user_agent`
        type: object
        example:
          ip: ::1
          user_agent: Chrome
      country_code:
        description: The 2 character ISO country code to create the Cart in. Setting
          this parameter will set the country code of the shipping address.
        type: string
      customer_id:
        description: The ID of the Customer to associate the Cart with.
        type: string
      discounts:
        description: An array of Discount codes to add to the Cart.
        type: array
        items:
          properties:
            code:
              description: The code of the discount.
              type: string
          required:
          - code
          type: object
      email:
        description: An email to be used on the Cart.
        type: string
        format: email
      gift_cards:
        description: An array of Gift Card codes to add to the Cart.
        type: array
        items:
          properties:
            code:
              description: The code of a gift card.
              type: string
          required:
          - code
          type: object
      region_id:
        description: The ID of the Region to create the Cart in. Setting the cart's
          region can affect the pricing of the items in the cart as well as the used
          currency.
        type: string
      sales_channel_id:
        description: The ID of the Sales channel to create the Cart in. The cart's
          sales channel affects which products can be added to the cart. If a product
          does not exist in the cart's sales channel, it cannot be added to the cart.
          If you add a publishable API key in the header of this request and specify
          a sales channel ID, the specified sales channel must be within the scope
          of the publishable API key's resources.
        type: string
      shipping_address:
        description: The Address to be used for shipping purposes.
  StorePostCartsCartShippingMethodReq:
    description: The details of the shipping method to add to the cart.
    required:
    - option_id
    type: object
    properties:
      data:
        description: Used to hold any data that the shipping method may need to process
          the fulfillment of the order. This depends on the fulfillment provider you're
          using.
        type: object
      option_id:
        description: ID of the shipping option to create the method from.
        type: string
  StorePostCustomersCustomerAcceptClaimReq:
    description: The details necessary to grant order access.
    required:
    - token
    type: object
    properties:
      token:
        description: The claim token generated by previous request to the Claim Order
          API Route.
        type: string
  StorePostCustomersCustomerAddressesAddressReq: {}
  StorePostCustomersCustomerAddressesReq:
    required:
    - address
    type: object
    properties:
      address:
        description: The Address to add to the Customer's saved addresses.
        $ref: '#/components/schemas/AddressCreatePayload'
  StorePostCustomersCustomerOrderClaimReq:
    description: The details of the orders to claim.
    required:
    - order_ids
    type: object
    properties:
      order_ids:
        description: The ID of the orders to claim
        type: array
        items:
          type: string
  StorePostOrderEditsOrderEditDecline:
    description: The details of the order edit's decline.
    type: object
    properties:
      declined_reason:
        description: The reason for declining the Order Edit.
        type: string
  StorePostPaymentCollectionsBatchSessionsAuthorizeReq:
    description: The details of the payment sessions to authorize.
    required:
    - session_ids
    type: object
    properties:
      session_ids:
        description: List of Payment Session IDs to authorize.
        type: array
        items:
          type: string
  StorePostPaymentCollectionsBatchSessionsReq:
    description: The details of the payment sessions to manage.
    required:
    - sessions
    type: object
    properties:
      sessions:
        description: Payment sessions related to the Payment Collection. Existing
          sessions that are not added in this array will be deleted.
        type: array
        items:
          properties:
            amount:
              description: The payment amount
              type: integer
            provider_id:
              description: The ID of the Payment Provider.
              type: string
            session_id:
              description: The ID of the Payment Session to be updated. If no ID is
                provided, a new payment session is created.
              type: string
          required:
          - provider_id
          - amount
          type: object
  StorePostReturnsReq:
    description: The details of the return to create.
    required:
    - order_id
    - items
    type: object
    properties:
      items:
        description: The items to include in the return.
        type: array
        items:
          properties:
            item_id:
              description: The ID of the line item to return.
              type: string
            note:
              description: A note to add to the item returned.
              type: string
            quantity:
              description: The quantity to return.
              type: integer
            reason_id:
              description: The ID of the return reason. Return reasons can be retrieved
                from the List Return Reasons API Route.
              type: string
          required:
          - item_id
          - quantity
          type: object
      order_id:
        description: The ID of the Order to create the return for.
        type: string
      return_shipping:
        description: The return shipping method used to return the items. If provided,
          a fulfillment is automatically created for the return.
        required:
        - option_id
        type: object
        properties:
          option_id:
            description: The ID of the Shipping Option to create the Shipping Method
              from.
            type: string
  StorePostSearchReq:
    type: object
    properties:
      filter:
        description: Pass filters based on the search service.
      limit:
        description: Limit the number of products returned.
        type: number
      offset:
        description: The number of products to skip when retrieving the products.
        type: number
      q:
        description: The search query.
        type: string
  StorePostSwapsReq:
    description: The details of the swap to create.
    required:
    - order_id
    - return_items
    - additional_items
    type: object
    properties:
      additional_items:
        description: The items to exchange the returned items with.
        type: array
        items:
          properties:
            quantity:
              description: The quantity of the variant.
              type: integer
            variant_id:
              description: The ID of the Product Variant.
              type: string
          required:
          - variant_id
          - quantity
          type: object
      order_id:
        description: The ID of the Order to create the Swap for.
        type: string
      return_items:
        description: The items to include in the Return.
        type: array
        items:
          properties:
            item_id:
              description: The ID of the order's line item to return.
              type: string
            note:
              description: The note to add to the item being swapped.
              type: string
            quantity:
              description: The quantity to return.
              type: integer
            reason_id:
              description: The ID of the reason of this return. Return reasons can
                be retrieved from the List Return Reasons API Route.
              type: string
          required:
          - item_id
          - quantity
          type: object
      return_shipping_option:
        description: The ID of the Shipping Option to create the Shipping Method from.
        type: string
  Swap:
    description: A swap can be created when a Customer wishes to exchange Products
      that they have purchased with different Products. It consists of a Return of
      previously purchased Products and a Fulfillment of new Products. It also includes
      information on any additional payment or refund required based on the difference
      between the exchanged products.
    required:
    - allow_backorder
    - canceled_at
    - cart_id
    - confirmed_at
    - created_at
    - deleted_at
    - difference_due
    - fulfillment_status
    - id
    - idempotency_key
    - metadata
    - no_notification
    - order_id
    - payment_status
    - shipping_address_id
    - updated_at
    type: object
    properties:
      additional_items:
        description: The details of the new products to send to the customer, represented
          as line items.
        type: array
        items:
          $ref: '#/components/schemas/LineItem'
      allow_backorder:
        description: If true, swaps can be completed with items out of stock
        type: boolean
      canceled_at:
        description: The date with timezone at which the Swap was canceled.
        nullable: true
        type: string
        format: date-time
      cart:
        description: The details of the cart that the customer uses to complete the
          swap.
        nullable: true
        $ref: '#/components/schemas/Cart'
      cart_id:
        description: The ID of the cart that the customer uses to complete the swap.
        nullable: true
        type: string
        example: cart_01G8ZH853Y6TFXWPG5EYE81X63
      confirmed_at:
        description: The date with timezone at which the Swap was confirmed by the
          Customer.
        nullable: true
        type: string
        format: date-time
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      difference_due:
        description: The difference amount between the order’s original total and
          the new total imposed by the swap. If its value is negative, a refund must
          be issues to the customer. If it's positive, additional payment must be
          authorized by the customer. Otherwise, no payment processing is required.
        nullable: true
        type: integer
        example: 0
      fulfillment_status:
        description: The status of the Fulfillment of the Swap.
        type: string
        enum:
        - not_fulfilled
        - fulfilled
        - shipped
        - partially_shipped
        - canceled
        - requires_action
        example: not_fulfilled
      fulfillments:
        description: The details of the fulfillments that are used to send the new
          items to the customer.
        type: array
        items:
          $ref: '#/components/schemas/Fulfillment'
      id:
        description: The swap's ID
        type: string
        example: swap_01F0YET86Y9G92D3YDR9Y6V676
      idempotency_key:
        description: Randomly generated key used to continue the completion of the
          swap in case of failure.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      no_notification:
        description: If set to true, no notification will be sent related to this
          swap
        nullable: true
        type: boolean
        example: false
      order:
        description: The details of the order that the swap belongs to.
        nullable: true
        $ref: '#/components/schemas/Order'
      order_id:
        description: The ID of the order that the swap belongs to.
        type: string
        example: order_01G8TJSYT9M6AVS5N4EMNFS1EK
      payment:
        description: The details of the additional payment authorized by the customer
          when `difference_due` is positive.
        nullable: true
        $ref: '#/components/schemas/Payment'
      payment_status:
        description: The status of the Payment of the Swap. The payment may either
          refer to the refund of an amount or the authorization of a new amount.
        type: string
        enum:
        - not_paid
        - awaiting
        - captured
        - confirmed
        - canceled
        - difference_refunded
        - partially_refunded
        - refunded
        - requires_action
        example: not_paid
      return_order:
        description: The details of the return that belongs to the swap, which holds
          the details on the items being returned.
        nullable: true
        $ref: '#/components/schemas/Return'
      shipping_address:
        description: The details of the shipping address that the new items should
          be sent to.
        nullable: true
        $ref: '#/components/schemas/Address'
      shipping_address_id:
        description: The Address to send the new Line Items to - in most cases this
          will be the same as the shipping address on the Order.
        nullable: true
        type: string
        example: addr_01G8ZH853YPY9B94857DY91YGW
      shipping_methods:
        description: The details of the shipping methods used to fulfill the additional
          items purchased.
        type: array
        items:
          $ref: '#/components/schemas/ShippingMethod'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  TaxLine:
    description: A tax line represents the taxes amount applied to a line item.
    required:
    - code
    - created_at
    - id
    - metadata
    - name
    - rate
    - updated_at
    type: object
    properties:
      code:
        description: A code to identify the tax type by
        nullable: true
        type: string
        example: tax01
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      id:
        description: The tax line's ID
        type: string
        example: tl_01G1G5V2DRX1SK6NQQ8VVX4HQ8
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: A human friendly name for the tax
        type: string
        example: Tax Example
      rate:
        description: The numeric rate to charge tax by
        type: number
        example: 10
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  TaxProvider:
    description: A tax provider represents a tax service installed in the Medusa backend,
      either through a plugin or backend customizations. It holds the tax service's
      installation status.
    required:
    - id
    - is_installed
    type: object
    properties:
      id:
        description: The ID of the tax provider as given by the tax service.
        type: string
        example: manual
      is_installed:
        description: Whether the tax service is installed in the current version.
          If a tax service is no longer installed, the `is_installed` attribute is
          set to `false`.
        type: boolean
  TaxRate:
    description: A Tax Rate can be used to define a custom rate to charge on specified
      products, product types, and shipping options within a given region.
    required:
    - code
    - created_at
    - id
    - metadata
    - name
    - rate
    - region_id
    - updated_at
    type: object
    properties:
      code:
        description: A code to identify the tax type by
        nullable: true
        type: string
        example: tax01
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      id:
        description: The tax rate's ID
        type: string
        example: txr_01G8XDBAWKBHHJRKH0AV02KXBR
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      name:
        description: A human friendly name for the tax
        type: string
        example: Tax Example
      product_count:
        description: The count of products
        type: integer
        example: 10
      product_type_count:
        description: The count of product types
        type: integer
        example: 2
      product_types:
        description: The details of the product types that belong to this tax rate.
        type: array
        items:
          $ref: '#/components/schemas/ProductType'
      products:
        description: The details of the products that belong to this tax rate.
        type: array
        items:
          $ref: '#/components/schemas/Product'
      rate:
        description: The numeric rate to charge
        nullable: true
        type: number
        example: 10
      region:
        description: The details of the region that the rate belongs to.
        nullable: true
        $ref: '#/components/schemas/Region'
      region_id:
        description: The ID of the region that the rate belongs to.
        type: string
        example: reg_01G1G5V26T9H8Y0M4JNE3YGA4G
      shipping_option_count:
        description: The count of shipping options
        type: integer
        example: 1
      shipping_options:
        description: The details of the shipping options that belong to this tax rate.
        type: array
        items:
          $ref: '#/components/schemas/ShippingOption'
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  TrackingLink:
    description: A tracking link holds information about tracking numbers for a Fulfillment.
      Tracking Links can optionally contain a URL that can be visited to see the status
      of the shipment. Typically, the tracking link is provided from the third-party
      service integrated through the used fulfillment provider.
    required:
    - created_at
    - deleted_at
    - fulfillment_id
    - id
    - idempotency_key
    - metadata
    - tracking_number
    - updated_at
    - url
    type: object
    properties:
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      fulfillment:
        description: The details of the fulfillment that the tracking link belongs
          to.
        nullable: true
        $ref: '#/components/schemas/Fulfillment'
      fulfillment_id:
        description: The ID of the fulfillment that the tracking link belongs to.
        type: string
        example: ful_01G8ZRTMQCA76TXNAT81KPJZRF
      id:
        description: The tracking link's ID
        type: string
        example: tlink_01G8ZH853Y6TFXWPG5EYE81X63
      idempotency_key:
        description: Randomly generated key used to continue the completion of a process
          in case of failure.
        nullable: true
        type: string
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      tracking_number:
        description: The tracking number given by the shipping carrier.
        type: string
        format: RH370168054CN
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
      url:
        description: The URL at which the status of the shipment can be tracked.
        nullable: true
        type: string
        format: uri
  User:
    description: A User is an administrator who can manage store settings and data.
    required:
    - api_token
    - created_at
    - deleted_at
    - email
    - first_name
    - id
    - last_name
    - metadata
    - role
    - updated_at
    type: object
    properties:
      api_token:
        description: An API token associated with the user.
        nullable: true
        type: string
      created_at:
        description: The date with timezone at which the resource was created.
        type: string
        format: date-time
      deleted_at:
        description: The date with timezone at which the resource was deleted.
        nullable: true
        type: string
        format: date-time
      email:
        description: The email of the User
        type: string
        format: email
      first_name:
        description: The first name of the User
        nullable: true
        type: string
        example: Levi
      id:
        description: The user's ID
        type: string
        example: usr_01G1G5V26F5TB3GPAPNJ8X1S3V
      last_name:
        description: The last name of the User
        nullable: true
        type: string
        example: Bogan
      metadata:
        description: An optional key-value map with additional details
        nullable: true
        type: object
        example:
          car: white
      role:
        description: The user's role. These roles don't provide any different privileges.
        type: string
        enum:
        - admin
        - member
        - developer
      updated_at:
        description: The date with timezone at which the resource was updated.
        type: string
        format: date-time
  examples:
    database_error:
      summary: Database Error
      value:
        code: api_error
        message: An error occured while hashing password
        type: database_error
    default_error:
      summary: Default Error
      value:
        code: unknown_error
        message: An unknown error occurred.
        type: unknown_error
    invalid_argument_error:
      summary: Invalid Argument Error
      value:
        message: cart.total must be defined
        type: unexpected_state
    invalid_data_error:
      summary: Invalid Data Error
      value:
        message: first_name must be a string
        type: invalid_data
    multiple_errors:
      summary: Multiple Errors
      value:
        errors:
        - message: first_name must be a string
          type: invalid_data
        - message: Discount must be set to dynamic
          type: not_allowed
        message: Provided request body contains errors. Please check the data and
          retry the request
    not_allowed_error:
      summary: Not Allowed Error
      value:
        message: Discount must be set to dynamic
        type: not_allowed
    unexpected_state_error:
      summary: Unexpected State Error
      value:
        message: cart.total must be defined
        type: unexpected_state
  responses:
    400_error:
      content:
        application/json:
          examples:
            MultipleErrors:
              $ref: '#/components/examples/multiple_errors'
            invalid_data:
              $ref: '#/components/examples/invalid_data_error'
            not_allowed:
              $ref: '#/components/examples/not_allowed_error'
          schema:
            oneOf:
            - $ref: '#/components/schemas/Error'
            - $ref: '#/components/schemas/MultipleErrors'
      description: Client Error or Multiple Errors
    500_error:
      content:
        application/json:
          examples:
            database:
              $ref: '#/components/examples/database_error'
            default_error:
              $ref: '#/components/examples/default_error'
            invalid_argument:
              $ref: '#/components/examples/invalid_argument_error'
            unexpected_state:
              $ref: '#/components/examples/unexpected_state_error'
          schema:
            $ref: '#/components/schemas/Error'
      description: Server Error
    default_error:
      content:
        application/json:
          example:
            code: unknown_error
            message: An unknown error occurred.
            type: unknown_error
          schema:
            $ref: '#/components/schemas/Error'
      description: Default Error
    incorrect_credentials:
      content:
        text/plain:
          schema:
            default: Unauthorized
            example: Unauthorized
            type: string
      description: User does not exist or incorrect credentials
    invalid_request_error:
      content:
        application/json:
          example:
            code: invalid_request_error
            message: Discount with code TEST already exists.
            type: duplicate_error
          schema:
            $ref: '#/components/schemas/Error'
      description: Invalid Request Error
    invalid_state_error:
      content:
        application/json:
          example:
            code: unknown_error
            message: The request conflicted with another request. You may retry the
              request with the provided Idempotency-Key.
            type: QueryRunnerAlreadyReleasedError
          schema:
            $ref: '#/components/schemas/Error'
      description: Invalid State Error
    not_found_error:
      content:
        application/json:
          example:
            message: Entity with id 1 was not found
            type: not_found
          schema:
            $ref: '#/components/schemas/Error'
      description: Not Found Error
    unauthorized:
      content:
        text/plain:
          schema:
            default: Unauthorized
            example: Unauthorized
            type: string
      description: User is not authorized. Must log in first
  securitySchemes:
    cookie_auth:
      description: |-
        Use a cookie session to send authenticated requests.

        ### How to Obtain the Cookie Session

        If you're sending requests through a browser, using JS Client, or using tools like Postman, the cookie session should be automatically set when the customer is logged in.

        If you're sending requests using cURL, you must set the Session ID in the cookie manually.

        To do that, send a request to [authenticate the customer](#tag/Auth/operation/PostAuth) and pass the cURL option `-v`:

        ```bash
        curl -v --location --request POST 'https://medusa-url.com/store/auth' \
        --header 'Content-Type: application/json' \
        --data-raw '{
          "email": "user@example.com",
          "password": "supersecret"
        }'
        ```

        The headers will be logged in the terminal as well as the response. You should find in the headers a Cookie header similar to this:

        ```bash
        Set-Cookie: connect.sid=s%3A2Bu8BkaP9JUfHu9rG59G16Ma0QZf6Gj1.WT549XqX37PN8n0OecqnMCq798eLjZC5IT7yiDCBHPM;
        ```

        Copy the value after `connect.sid` (without the `;` at the end) and pass it as a cookie in subsequent requests as the following:

        ```bash
        curl --location --request GET 'https://medusa-url.com/store/customers/me/orders' \
        --header 'Cookie: connect.sid={sid}'
        ```

        Where `{sid}` is the value of `connect.sid` that you copied.
      in: cookie
      name: connect.sid
      type: apiKey
      x-displayName: Cookie Session ID
    jwt_token:
      scheme: bearer
      type: http
      x-displayName: JWT Token
